/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    PyBytes_AsStringAndSize(str, &cstr, &len);
    newstr = (char *) malloc(len+1);
    memcpy(newstr, cstr, len+1);
    Py_XDECREF(str);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    Py_XDECREF(value);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
# error "This version of SWIG only supports Python 3 >= 3.2"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
      data->delargs = !(flags & (METH_O));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          PyObject_SetAttr(inst, SWIG_This(), swig_this);
          Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, "__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        return -1;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifdef __cplusplus
extern "C" {
#endif

/* Method creation and docstring support functions */

SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_DeviceWrapper swig_types[0]
#define SWIGTYPE_p_Tools swig_types[1]
#define SWIGTYPE_p_char swig_types[2]
#define SWIGTYPE_p_fz_colorspace_s swig_types[3]
#define SWIGTYPE_p_fz_display_list_s swig_types[4]
#define SWIGTYPE_p_fz_document_s swig_types[5]
#define SWIGTYPE_p_fz_link_s swig_types[6]
#define SWIGTYPE_p_fz_outline_s swig_types[7]
#define SWIGTYPE_p_fz_page_s swig_types[8]
#define SWIGTYPE_p_fz_pixmap_s swig_types[9]
#define SWIGTYPE_p_fz_stext_page_s swig_types[10]
#define SWIGTYPE_p_pdf_annot_s swig_types[11]
#define SWIGTYPE_p_pdf_graft_map_s swig_types[12]
static swig_type_info *swig_types[14];
static swig_module_info swig_module = {swig_types, 13, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _fitz.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__fitz

#else
#  define SWIG_init    init_fitz

#endif
#define SWIG_name    "_fitz"

#define SWIGVERSION 0x040001 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#define MEMDEBUG 0
#if MEMDEBUG == 1
#define DEBUGMSG1(x) PySys_WriteStderr("[DEBUG] free %s ", x)
#define DEBUGMSG2 PySys_WriteStderr("... done!\n")
#else
#define DEBUGMSG1(x)
#define DEBUGMSG2
#endif

#ifndef FLT_EPSILON
  #define FLT_EPSILON 1e-5
#endif

#define return_none Py_RETURN_NONE
#define SWIG_FILE_WITH_INIT
#define SWIG_PYTHON_2_UNICODE

// memory allocation macros
#define JM_MEMORY 1
#if  PY_VERSION_HEX < 0x03000000
#undef JM_MEMORY
#define JM_MEMORY 0
#endif

#if JM_MEMORY == 1
#define JM_Alloc(type, len) PyMem_New(type, len)
#define JM_Free(x) PyMem_Del(x)
#else
#define JM_Alloc(type, len) (type *) malloc(sizeof(type)*len)
#define JM_Free(x) free(x)
#endif

#define EXISTS(x) (PyObject_IsTrue(x)==1)
#define THROWMSG(msg) fz_throw(gctx, FZ_ERROR_GENERIC, msg)
#define assert_PDF(cond) if (cond == NULL) THROWMSG("not a PDF")
#define INRANGE(v, low, high) ((low) <= v && v <= (high))
#define MAX(a, b) ((a) < (b)) ? (b) : (a)
#define MIN(a, b) ((a) < (b)) ? (a) : (b)

#define JM_PyErr_Clear if (PyErr_Occurred()) PyErr_Clear()

// binary output depends on Python major
# if PY_VERSION_HEX >= 0x03000000
#define JM_BinFromChar(x) PyBytes_FromString(x)
#define JM_BinFromCharSize(x, y) PyBytes_FromStringAndSize(x, (Py_ssize_t) y)
# else
#define JM_BinFromChar(x) PyByteArray_FromStringAndSize(x, (Py_ssize_t) strlen(x))
#define JM_BinFromCharSize(x, y) PyByteArray_FromStringAndSize(x, (Py_ssize_t) y)
# endif

#include <fitz.h>
#include <pdf.h>
#include <time.h>
char *JM_Python_str_AsChar(PyObject *str);
pdf_obj *pdf_lookup_page_loc(fz_context *ctx, pdf_document *doc, int needle, pdf_obj **parentp, int *indexp);
PyObject *JM_mupdf_warnings_store;
PyObject *JM_mupdf_show_errors;


fz_context *gctx;
int JM_UNIQUE_ID = 0;

struct DeviceWrapper {
    fz_device *device;
    fz_display_list *list;
};


//----------------------------------------------------------------------------
// general
//----------------------------------------------------------------------------
#define EPSILON 1e-5
//----------------------------------------------------------------------------
// annotation types
//----------------------------------------------------------------------------
#define PDF_ANNOT_TEXT 0
#define PDF_ANNOT_LINK 1
#define PDF_ANNOT_FREE_TEXT 2
#define PDF_ANNOT_LINE 3
#define PDF_ANNOT_SQUARE 4
#define PDF_ANNOT_CIRCLE 5
#define PDF_ANNOT_POLYGON 6
#define PDF_ANNOT_POLYLINE 7
#define PDF_ANNOT_HIGHLIGHT 8
#define PDF_ANNOT_UNDERLINE 9
#define PDF_ANNOT_SQUIGGLY 10
#define PDF_ANNOT_STRIKEOUT 11
#define PDF_ANNOT_REDACT 12
#define PDF_ANNOT_STAMP 13
#define PDF_ANNOT_CARET 14
#define PDF_ANNOT_INK 15
#define PDF_ANNOT_POPUP 16
#define PDF_ANNOT_FILEATTACHMENT 17
#define PDF_ANNOT_SOUND 18
#define PDF_ANNOT_MOVIE 19
#define PDF_ANNOT_WIDGET 20
#define PDF_ANNOT_SCREEN 21
#define PDF_ANNOT_PRINTERMARK 22
#define PDF_ANNOT_TRAPNET 23
#define PDF_ANNOT_WATERMARK 24
#define PDF_ANNOT_3D 25
#define PDF_ANNOT_UNKNOWN -1

// deprecated aliases
#define ANNOT_TEXT PDF_ANNOT_TEXT
#define ANNOT_LINK PDF_ANNOT_LINK
#define ANNOT_FREETEXT PDF_ANNOT_FREE_TEXT
#define ANNOT_LINE PDF_ANNOT_LINE
#define ANNOT_SQUARE PDF_ANNOT_SQUARE
#define ANNOT_CIRCLE PDF_ANNOT_CIRCLE
#define ANNOT_POLYGON PDF_ANNOT_POLYGON
#define ANNOT_POLYLINE PDF_ANNOT_POLYLINE
#define ANNOT_HIGHLIGHT PDF_ANNOT_HIGHLIGHT
#define ANNOT_UNDERLINE PDF_ANNOT_UNDERLINE
#define ANNOT_SQUIGGLY PDF_ANNOT_SQUIGGLY
#define ANNOT_STRIKEOUT PDF_ANNOT_STRIKEOUT
#define ANNOT_STAMP PDF_ANNOT_STAMP
#define ANNOT_CARET PDF_ANNOT_CARET
#define ANNOT_INK PDF_ANNOT_INK
#define ANNOT_POPUP PDF_ANNOT_POPUP
#define ANNOT_FILEATTACHMENT PDF_ANNOT_FILEATTACHMENT
#define ANNOT_SOUND PDF_ANNOT_SOUND
#define ANNOT_MOVIE PDF_ANNOT_MOVIE
#define ANNOT_WIDGET PDF_ANNOT_WIDGET
#define ANNOT_SCREEN PDF_ANNOT_WIDGET
#define ANNOT_PRINTERMARK PDF_ANNOT_PRINTERMARK
#define ANNOT_TRAPNET PDF_ANNOT_TRAPNET
#define ANNOT_WATERMARK PDF_ANNOT_WATERMARK
#define ANNOT_3D PDF_ANNOT_3D

//----------------------------------------------------------------------------
// annotation flag bits
//----------------------------------------------------------------------------
#define PDF_ANNOT_IS_Invisible 1 << (1-1)
#define PDF_ANNOT_IS_Hidden 1 << (2-1)
#define PDF_ANNOT_IS_Print 1 << (3-1)
#define PDF_ANNOT_IS_NoZoom 1 << (4-1)
#define PDF_ANNOT_IS_NoRotate 1 << (5-1)
#define PDF_ANNOT_IS_NoView 1 << (6-1)
#define PDF_ANNOT_IS_ReadOnly 1 << (7-1)
#define PDF_ANNOT_IS_Locked 1 << (8-1)
#define PDF_ANNOT_IS_ToggleNoView 1 << (9-1)
#define PDF_ANNOT_IS_LockedContents 1 << (10-1)

// deprecated aliases
#define ANNOT_XF_Invisible PDF_ANNOT_IS_Invisible
#define ANNOT_XF_Hidden PDF_ANNOT_IS_Hidden
#define ANNOT_XF_Print PDF_ANNOT_IS_Print
#define ANNOT_XF_NoZoom PDF_ANNOT_IS_NoZoom
#define ANNOT_XF_NoRotate PDF_ANNOT_IS_NoRotate
#define ANNOT_XF_NoView PDF_ANNOT_IS_NoView
#define ANNOT_XF_ReadOnly PDF_ANNOT_IS_ReadOnly
#define ANNOT_XF_Locked PDF_ANNOT_IS_Locked
#define ANNOT_XF_ToggleNoView PDF_ANNOT_IS_ToggleNoView
#define ANNOT_XF_LockedContents PDF_ANNOT_IS_LockedContents

//----------------------------------------------------------------------------
// annotation line ending styles
//----------------------------------------------------------------------------
#define PDF_ANNOT_LE_NONE 0
#define PDF_ANNOT_LE_SQUARE 1
#define PDF_ANNOT_LE_CIRCLE 2
#define PDF_ANNOT_LE_DIAMOND 3
#define PDF_ANNOT_LE_OPEN_ARROW 4
#define PDF_ANNOT_LE_CLOSED_ARROW 5
#define PDF_ANNOT_LE_BUTT 6
#define PDF_ANNOT_LE_R_OPEN_ARROW 7
#define PDF_ANNOT_LE_R_CLOSED_ARROW 8
#define PDF_ANNOT_LE_SLASH 9

// deprecated aliases
#define ANNOT_LE_None PDF_ANNOT_LE_NONE
#define ANNOT_LE_Square PDF_ANNOT_LE_SQUARE
#define ANNOT_LE_Circle PDF_ANNOT_LE_CIRCLE
#define ANNOT_LE_Diamond PDF_ANNOT_LE_DIAMOND
#define ANNOT_LE_OpenArrow PDF_ANNOT_LE_OPEN_ARROW
#define ANNOT_LE_ClosedArrow PDF_ANNOT_LE_CLOSED_ARROW
#define ANNOT_LE_Butt PDF_ANNOT_LE_BUTT
#define ANNOT_LE_ROpenArrow PDF_ANNOT_LE_R_OPEN_ARROW
#define ANNOT_LE_RClosedArrow PDF_ANNOT_LE_R_CLOSED_ARROW
#define ANNOT_LE_Slash PDF_ANNOT_LE_SLASH

//----------------------------------------------------------------------------
// annotation field (widget) types
//----------------------------------------------------------------------------
#define PDF_WIDGET_TYPE_UNKNOWN 0
#define PDF_WIDGET_TYPE_BUTTON 1
#define PDF_WIDGET_TYPE_CHECKBOX 2
#define PDF_WIDGET_TYPE_COMBOBOX 3
#define PDF_WIDGET_TYPE_LISTBOX 4
#define PDF_WIDGET_TYPE_RADIOBUTTON 5
#define PDF_WIDGET_TYPE_SIGNATURE 6
#define PDF_WIDGET_TYPE_TEXT 7

// deprecated aliases
#define ANNOT_WG_NOT_WIDGET PDF_WIDGET_TYPE_UNKNOWN
#define ANNOT_WG_PUSHBUTTON PDF_WIDGET_TYPE_BUTTON
#define ANNOT_WG_CHECKBOX PDF_WIDGET_TYPE_CHECKBOX
#define ANNOT_WG_RADIOBUTTON PDF_WIDGET_TYPE_RADIOBUTTON
#define ANNOT_WG_TEXT PDF_WIDGET_TYPE_TEXT
#define ANNOT_WG_LISTBOX PDF_WIDGET_TYPE_LISTBOX
#define ANNOT_WG_COMBOBOX PDF_WIDGET_TYPE_COMBOBOX
#define ANNOT_WG_SIGNATURE PDF_WIDGET_TYPE_SIGNATURE

//----------------------------------------------------------------------------
// annotation text widget subtypes
//----------------------------------------------------------------------------
#define PDF_WIDGET_TX_FORMAT_NONE 0
#define PDF_WIDGET_TX_FORMAT_NUMBER 1
#define PDF_WIDGET_TX_FORMAT_SPECIAL 2
#define PDF_WIDGET_TX_FORMAT_DATE 3
#define PDF_WIDGET_TX_FORMAT_TIME 4

// deprecated aliases
#define ANNOT_WG_TEXT_UNRESTRAINED PDF_WIDGET_TX_FORMAT_NONE
#define ANNOT_WG_TEXT_NUMBER PDF_WIDGET_TX_FORMAT_NUMBER
#define ANNOT_WG_TEXT_SPECIAL PDF_WIDGET_TX_FORMAT_SPECIAL
#define ANNOT_WG_TEXT_DATE PDF_WIDGET_TX_FORMAT_DATE
#define ANNOT_WG_TEXT_TIME PDF_WIDGET_TX_FORMAT_TIME

//----------------------------------------------------------------------------
// annotation widget flags
//----------------------------------------------------------------------------
// Common to all field types
#define PDF_FIELD_IS_READ_ONLY 1
#define PDF_FIELD_IS_REQUIRED 1 << 1
#define PDF_FIELD_IS_NO_EXPORT 1 << 2

// deprecated aliases
#define WIDGET_Ff_ReadOnly PDF_FIELD_IS_READ_ONLY
#define WIDGET_Ff_Required PDF_FIELD_IS_REQUIRED
#define WIDGET_Ff_NoExport PDF_FIELD_IS_NO_EXPORT

// Text fields
#define PDF_TX_FIELD_IS_MULTILINE  1 << 12
#define PDF_TX_FIELD_IS_PASSWORD  1 << 13
#define PDF_TX_FIELD_IS_FILE_SELECT  1 << 20
#define PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK  1 << 22
#define PDF_TX_FIELD_IS_DO_NOT_SCROLL  1 << 23
#define PDF_TX_FIELD_IS_COMB  1 << 24
#define PDF_TX_FIELD_IS_RICH_TEXT  1 << 25

// deprecated aliases
#define WIDGET_Ff_Multiline PDF_TX_FIELD_IS_MULTILINE
#define WIDGET_Ff_Password PDF_TX_FIELD_IS_PASSWORD
#define WIDGET_Ff_FileSelect PDF_TX_FIELD_IS_FILE_SELECT
#define WIDGET_Ff_DoNotSpellCheck PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK
#define WIDGET_Ff_DoNotScroll PDF_TX_FIELD_IS_DO_NOT_SCROLL
#define WIDGET_Ff_Comb PDF_TX_FIELD_IS_COMB
#define WIDGET_Ff_RichText PDF_TX_FIELD_IS_RICH_TEXT

// Button fields
#define PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF  1 << 14
#define PDF_BTN_FIELD_IS_RADIO  1 << 15
#define PDF_BTN_FIELD_IS_PUSHBUTTON  1 << 16
#define PDF_BTN_FIELD_IS_RADIOS_IN_UNISON  1 << 25

// deprecated aliases
#define WIDGET_Ff_NoToggleToOff PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF
#define WIDGET_Ff_Radio PDF_BTN_FIELD_IS_RADIO
#define WIDGET_Ff_Pushbutton PDF_BTN_FIELD_IS_PUSHBUTTON
#define WIDGET_Ff_RadioInUnison PDF_BTN_FIELD_IS_RADIOS_IN_UNISON

// Choice fields
#define PDF_CH_FIELD_IS_COMBO  1 << 17
#define PDF_CH_FIELD_IS_EDIT  1 << 18
#define PDF_CH_FIELD_IS_SORT  1 << 19
#define PDF_CH_FIELD_IS_MULTI_SELECT  1 << 21
#define PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK  1 << 22
#define PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE  1 << 26

// deprecated aliases
#define WIDGET_Ff_Combo PDF_CH_FIELD_IS_COMBO
#define WIDGET_Ff_Edit PDF_CH_FIELD_IS_EDIT
#define WIDGET_Ff_Sort PDF_CH_FIELD_IS_SORT
#define WIDGET_Ff_MultiSelect PDF_CH_FIELD_IS_MULTI_SELECT
#define WIDGET_Ff_CommitOnSelCHange PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE

//----------------------------------------------------------------------------
// colorspace identifiers
//----------------------------------------------------------------------------
#define CS_RGB  1
#define CS_GRAY 2
#define CS_CMYK 3

//----------------------------------------------------------------------------
// PDF encryption algorithms
//----------------------------------------------------------------------------
#define PDF_ENCRYPT_KEEP 0
#define PDF_ENCRYPT_NONE 1
#define PDF_ENCRYPT_RC4_40 2
#define PDF_ENCRYPT_RC4_128 3
#define PDF_ENCRYPT_AES_128 4
#define PDF_ENCRYPT_AES_256 5
#define PDF_ENCRYPT_UNKNOWN 6

//----------------------------------------------------------------------------
// PDF permission codes
//----------------------------------------------------------------------------
#define PDF_PERM_PRINT 1 << 2
#define PDF_PERM_MODIFY 1 << 3
#define PDF_PERM_COPY 1 << 4
#define PDF_PERM_ANNOTATE 1 << 5
#define PDF_PERM_FORM 1 << 8
#define PDF_PERM_ACCESSIBILITY 1 << 9
#define PDF_PERM_ASSEMBLE 1 << 10
#define PDF_PERM_PRINT_HQ 1 << 11

//----------------------------------------------------------------------------
// PDF Blend Modes
//----------------------------------------------------------------------------
#define PDF_BM_Color "Color"
#define PDF_BM_ColorBurn "ColorBurn"
#define PDF_BM_ColorDodge "ColorDodge"
#define PDF_BM_Darken "Darken"
#define PDF_BM_Difference "Difference"
#define PDF_BM_Exclusion "Exclusion"
#define PDF_BM_HardLight "HardLight"
#define PDF_BM_Hue "Hue"
#define PDF_BM_Lighten "Lighten"
#define PDF_BM_Luminosity "Luminosity"
#define PDF_BM_Multiply "Multiply"
#define PDF_BM_Normal "Normal"
#define PDF_BM_Overlay "Overlay"
#define PDF_BM_Saturation "Saturation"
#define PDF_BM_Screen "Screen"
#define PDF_BM_SoftLight "Softlight"


// General text flags
#define TEXT_FONT_SUPERSCRIPT 1
#define TEXT_FONT_ITALIC 2
#define TEXT_FONT_SERIFED 4
#define TEXT_FONT_MONOSPACED 8
#define TEXT_FONT_BOLD 16



  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
#else
      return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


// Global Constants - Python dictionary keys
PyObject *dictkey_align;
PyObject *dictkey_bbox;
PyObject *dictkey_blocks;
PyObject *dictkey_bpc;
PyObject *dictkey_c;
PyObject *dictkey_chars;
PyObject *dictkey_color;
PyObject *dictkey_colorspace;
PyObject *dictkey_content;
PyObject *dictkey_creationDate;
PyObject *dictkey_cs_name;
PyObject *dictkey_da;
PyObject *dictkey_dashes;
PyObject *dictkey_desc;
PyObject *dictkey_dir;
PyObject *dictkey_effect;
PyObject *dictkey_ext;
PyObject *dictkey_filename;
PyObject *dictkey_fill;
PyObject *dictkey_flags;
PyObject *dictkey_font;
PyObject *dictkey_height;
PyObject *dictkey_id;
PyObject *dictkey_image;
PyObject *dictkey_length;
PyObject *dictkey_lines;
PyObject *dictkey_modDate;
PyObject *dictkey_name;
PyObject *dictkey_origin;
PyObject *dictkey_size;
PyObject *dictkey_smask;
PyObject *dictkey_spans;
PyObject *dictkey_stroke;
PyObject *dictkey_style;
PyObject *dictkey_subject;
PyObject *dictkey_text;
PyObject *dictkey_title;
PyObject *dictkey_type;
PyObject *dictkey_ufilename;
PyObject *dictkey_width;
PyObject *dictkey_wmode;
PyObject *dictkey_xref;
PyObject *dictkey_xres;
PyObject *dictkey_yres;




//-----------------------------------------------------------------------------
// Functions converting betwenn PySequences and fitz geometry objects
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// fz_quad from PySequence. Four-floats-seq is treated as rect.
// Else must be four pairs of floats.
//-----------------------------------------------------------------------------
fz_quad JM_quad_from_py(PyObject *r)
{
    fz_quad q;
    fz_point p[4];
    size_t i;
    q.ul = q.ur = q.ll = q.lr = fz_make_point(0, 0);

    if (!PySequence_Check(r) || PySequence_Size(r) != 4)
        return q;

    float x0 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 0));
    if (!PyErr_Occurred())             // assume case 1: a rect is given
    {
        float y0 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 1));
        if (PyErr_Occurred()) goto return_simple;

        float x1 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 2));
        if (PyErr_Occurred()) goto return_simple;

        float y1 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 3));
        if (PyErr_Occurred()) goto return_simple;

        q.ul = fz_make_point(x0, y0);
        q.ur = fz_make_point(x1, y0);
        q.ll = fz_make_point(x0, y1);
        q.lr = fz_make_point(x1, y1);

        return_simple: ;
        PyErr_Clear();
        return q;
    }

    PyErr_Clear();
    for (i = 0; i < 4; i++)
    {
        PyObject *o = PySequence_ITEM(r, i);
        p[i].x = p[i].y = 0;
        if (!PySequence_Check(o) || PySequence_Size(o) != 2)
            goto weiter;

        p[i].x = (float) PyFloat_AsDouble(PySequence_ITEM(o, 0));
        if (PyErr_Occurred())
            p[i].x = 0;

        p[i].y = (float) PyFloat_AsDouble(PySequence_ITEM(o, 1));
        if (PyErr_Occurred())
            p[i].y = 0;

        PyErr_Clear();
        weiter: ;
        Py_CLEAR(o);
    }
    q.ul = p[0];
    q.ur = p[1];
    q.ll = p[2];
    q.lr = p[3];
    return q;
}

//-----------------------------------------------------------------------------
// PySequence from fz_quad.
//-----------------------------------------------------------------------------
PyObject *JM_py_from_quad(fz_quad quad)
{
    PyObject *pquad = PyTuple_New(4);
    PyTuple_SET_ITEM(pquad, 0, Py_BuildValue("ff", quad.ul.x, quad.ul.y));
    PyTuple_SET_ITEM(pquad, 1, Py_BuildValue("ff", quad.ur.x, quad.ur.y));
    PyTuple_SET_ITEM(pquad, 2, Py_BuildValue("ff", quad.ll.x, quad.ll.y));
    PyTuple_SET_ITEM(pquad, 3, Py_BuildValue("ff", quad.lr.x, quad.lr.y));
    return pquad;
}

//-----------------------------------------------------------------------------
// PySequence to fz_rect. Default: infinite rect
//-----------------------------------------------------------------------------
fz_rect JM_rect_from_py(PyObject *r)
{
    if (!PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_rect;

    float x0 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 0));
    if (PyErr_Occurred()) goto return_empty;

    float y0 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 1));
    if (PyErr_Occurred()) goto return_empty;

    float x1 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 2));
    if (PyErr_Occurred()) goto return_empty;

    float y1 = (float) PyFloat_AsDouble(PySequence_ITEM(r, 3));
    if (PyErr_Occurred()) goto return_empty;

    return fz_make_rect(x0, y0, x1, y1);

    return_empty: ;
    PyErr_Clear();
    return fz_infinite_rect;
}

//-----------------------------------------------------------------------------
// PySequence from fz_rect
//-----------------------------------------------------------------------------
PyObject *JM_py_from_rect(fz_rect r)
{
    return Py_BuildValue("ffff", r.x0, r.y0, r.x1, r.y1);
}

//-----------------------------------------------------------------------------
// PySequence to fz_irect. Default: infinite irect
//-----------------------------------------------------------------------------
fz_irect JM_irect_from_py(PyObject *r)
{
    if (!PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_irect;

    int x0 = (int) PyLong_AsLong(PySequence_ITEM(r, 0));
    if (PyErr_Occurred()) goto return_empty;

    int y0 = (int) PyLong_AsLong(PySequence_ITEM(r, 1));
    if (PyErr_Occurred()) goto return_empty;

    int x1 = (int) PyLong_AsLong(PySequence_ITEM(r, 2));
    if (PyErr_Occurred()) goto return_empty;

    int y1 = (int) PyLong_AsLong(PySequence_ITEM(r, 3));
    if (PyErr_Occurred()) goto return_empty;

    return fz_make_irect(x0, y0, x1, y1);

    return_empty: ;
    PyErr_Clear();
    return fz_infinite_irect;
}

//-----------------------------------------------------------------------------
// PySequence from fz_irect
//-----------------------------------------------------------------------------
PyObject *JM_py_from_irect(fz_irect r)
{
    return Py_BuildValue("iiii", r.x0, r.y0, r.x1, r.y1);
}


//-----------------------------------------------------------------------------
// PySequence to fz_point. Default: (0, 0)
//-----------------------------------------------------------------------------
fz_point JM_point_from_py(PyObject *p)
{
    fz_point p0 = fz_make_point(0, 0);
    if (!PySequence_Check(p) || PySequence_Size(p) != 2)
        return p0;

    float x = (float) PyFloat_AsDouble(PySequence_ITEM(p, 0));
    if (PyErr_Occurred()) goto zero_point;

    float y = (float) PyFloat_AsDouble(PySequence_ITEM(p, 1));
    if (PyErr_Occurred()) goto zero_point;

    return fz_make_point(x, y);

    zero_point: ;
    PyErr_Clear();
    return p0;
}

//-----------------------------------------------------------------------------
// PySequence from fz_point
//-----------------------------------------------------------------------------
PyObject *JM_py_from_point(fz_point p)
{
    return Py_BuildValue("ff", p.x, p.y);
}


//-----------------------------------------------------------------------------
// PySequence to fz_matrix. Default: fz_identity
//-----------------------------------------------------------------------------
fz_matrix JM_matrix_from_py(PyObject *m)
{
    fz_matrix m0 = fz_identity;
    if (!PySequence_Check(m) || PySequence_Size(m) != 6)
        return m0;

    float a = (float) PyFloat_AsDouble(PySequence_ITEM(m, 0));
    if (PyErr_Occurred()) goto fertig;

    float b = (float) PyFloat_AsDouble(PySequence_ITEM(m, 1));
    if (PyErr_Occurred()) goto fertig;

    float c = (float) PyFloat_AsDouble(PySequence_ITEM(m, 2));
    if (PyErr_Occurred()) goto fertig;

    float d = (float) PyFloat_AsDouble(PySequence_ITEM(m, 3));
    if (PyErr_Occurred()) goto fertig;

    float e = (float) PyFloat_AsDouble(PySequence_ITEM(m, 4));
    if (PyErr_Occurred()) goto fertig;

    float f = (float) PyFloat_AsDouble(PySequence_ITEM(m, 5));
    if (PyErr_Occurred()) goto fertig;

    m0.a = a;
    m0.b = b;
    m0.c = c;
    m0.d = d;
    m0.e = e;
    m0.f = f;

    fertig: ;
    PyErr_Clear();
    return m0;
}

//-----------------------------------------------------------------------------
// PySequence from fz_matrix
//-----------------------------------------------------------------------------
PyObject *JM_py_from_matrix(fz_matrix m)
{
    return Py_BuildValue("ffffff", m.a, m.b, m.c, m.d, m.e, m.f);
}




int LIST_APPEND_DROP(PyObject *list, PyObject *item)
{
    if (!list || !PyList_Check(list) || !item) return -2;
    int rc = PyList_Append(list, item);
    Py_DECREF(item);
    return rc;
}

int DICT_SETITEM_DROP(PyObject *dict, PyObject *key, PyObject *value)
{
    if (!dict || !PyDict_Check(dict) || !key || !value) return -2;
    int rc = PyDict_SetItem(dict, key, value);
    Py_DECREF(value);
    return rc;
}

int DICT_SETITEMSTR_DROP(PyObject *dict, const char *key, PyObject *value)
{
    if (!dict || !PyDict_Check(dict) || !key || !value) return -2;
    int rc = PyDict_SetItemString(dict, key, value);
    Py_DECREF(value);
    return rc;
}

PyObject *JM_EscapeStrFromBuffer(fz_context *ctx, fz_buffer *buff)
{
    if (!buff) return PyUnicode_FromString("");
    unsigned char *s = NULL;
    size_t len = fz_buffer_storage(ctx, buff, &s);
    PyObject *val = PyUnicode_DecodeRawUnicodeEscape(s, (Py_ssize_t) len, "replace");
    if (!val)
    {
        val = PyUnicode_FromString("");
        PyErr_Clear();
    }
    return val;
}

PyObject *JM_UnicodeFromStr(const char *c)
{
    if (!c) return PyUnicode_FromString("");
    PyObject *val = Py_BuildValue("s", c);
    if (!val)
    {
        val = PyUnicode_FromString("");
        PyErr_Clear();
    }
    return val;
}

PyObject *JM_EscapeStrFromStr(const char *c)
{
    if (!c) return PyUnicode_FromString("");
    PyObject *val = PyUnicode_DecodeRawUnicodeEscape(c, (Py_ssize_t) strlen(c), "replace");
    if (!val)
    {
        val = PyUnicode_FromString("");
        PyErr_Clear();
    }
    return val;
}

// redirect MuPDF warnings
void JM_mupdf_warning(void *user, const char *message)
{
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message));
}

// redirect MuPDF errors
void JM_mupdf_error(void *user, const char *message)
{
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message));
    if (JM_mupdf_show_errors == Py_True)
        PySys_WriteStderr("mupdf: %s\n", message);
}

// a simple tracer
void JM_TRACE(const char *id)
{
    PySys_WriteStdout("%s\n", id);
}

// put a warning on Python-stdout
void JM_Warning(const char *id)
{
    PySys_WriteStdout("warning: %s\n", id);
}

#if JM_MEMORY == 1
//-----------------------------------------------------------------------------
// The following 3 functions replace MuPDF standard memory allocation.
// This will ensure, that MuPDF memory handling becomes part of Python's
// memory management.
//-----------------------------------------------------------------------------
static void *JM_Py_Malloc(void *opaque, size_t size)
{
    return PyMem_Malloc(size);
}

static void *JM_Py_Realloc(void *opaque, void *old, size_t size)
{
    return PyMem_Realloc(old, size);
}

static void JM_PY_Free(void *opaque, void *ptr)
{
    PyMem_Free(ptr);
}

const fz_alloc_context JM_Alloc_Context =
{
	NULL,
	JM_Py_Malloc,
	JM_Py_Realloc,
	JM_PY_Free
};
#endif

// return Python bools for a given integer
PyObject *JM_BOOL(int v)
{
    if (v == 0)
        Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

PyObject *JM_fitz_config()
{
#if defined(TOFU)
#define have_TOFU JM_BOOL(0)
#else
#define have_TOFU JM_BOOL(1)
#endif
#if defined(TOFU_CJK)
#define have_TOFU_CJK JM_BOOL(0)
#else
#define have_TOFU_CJK JM_BOOL(1)
#endif
#if defined(TOFU_CJK_EXT)
#define have_TOFU_CJK_EXT JM_BOOL(0)
#else
#define have_TOFU_CJK_EXT JM_BOOL(1)
#endif
#if defined(TOFU_CJK_LANG)
#define have_TOFU_CJK_LANG JM_BOOL(0)
#else
#define have_TOFU_CJK_LANG JM_BOOL(1)
#endif
#if defined(TOFU_EMOJI)
#define have_TOFU_EMOJI JM_BOOL(0)
#else
#define have_TOFU_EMOJI JM_BOOL(1)
#endif
#if defined(TOFU_HISTORIC)
#define have_TOFU_HISTORIC JM_BOOL(0)
#else
#define have_TOFU_HISTORIC JM_BOOL(1)
#endif
#if defined(TOFU_SYMBOL)
#define have_TOFU_SYMBOL JM_BOOL(0)
#else
#define have_TOFU_SYMBOL JM_BOOL(1)
#endif
#if defined(TOFU_SIL)
#define have_TOFU_SIL JM_BOOL(0)
#else
#define have_TOFU_SIL JM_BOOL(1)
#endif
#if defined(TOFU_BASE14)
#define have_TOFU_BASE14 JM_BOOL(0)
#else
#define have_TOFU_BASE14 JM_BOOL(1)
#endif
    PyObject *dict = PyDict_New();
    DICT_SETITEMSTR_DROP(dict, "plotter-g", JM_BOOL(FZ_PLOTTERS_G));
    DICT_SETITEMSTR_DROP(dict, "plotter-rgb", JM_BOOL(FZ_PLOTTERS_RGB));
    DICT_SETITEMSTR_DROP(dict, "plotter-cmyk", JM_BOOL(FZ_PLOTTERS_CMYK));
    DICT_SETITEMSTR_DROP(dict, "plotter-n", JM_BOOL(FZ_PLOTTERS_N));
    DICT_SETITEMSTR_DROP(dict, "pdf", JM_BOOL(FZ_ENABLE_PDF));
    DICT_SETITEMSTR_DROP(dict, "xps", JM_BOOL(FZ_ENABLE_XPS));
    DICT_SETITEMSTR_DROP(dict, "svg", JM_BOOL(FZ_ENABLE_SVG));
    DICT_SETITEMSTR_DROP(dict, "cbz", JM_BOOL(FZ_ENABLE_CBZ));
    DICT_SETITEMSTR_DROP(dict, "img", JM_BOOL(FZ_ENABLE_IMG));
    DICT_SETITEMSTR_DROP(dict, "html", JM_BOOL(FZ_ENABLE_HTML));
    DICT_SETITEMSTR_DROP(dict, "epub", JM_BOOL(FZ_ENABLE_EPUB));
    DICT_SETITEMSTR_DROP(dict, "jpx", JM_BOOL(FZ_ENABLE_JPX));
    DICT_SETITEMSTR_DROP(dict, "js", JM_BOOL(FZ_ENABLE_JS));
    DICT_SETITEMSTR_DROP(dict, "tofu", have_TOFU);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk", have_TOFU_CJK);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-ext", have_TOFU_CJK_EXT);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-lang", have_TOFU_CJK_LANG);
    DICT_SETITEMSTR_DROP(dict, "tofu-emoji", have_TOFU_EMOJI);
    DICT_SETITEMSTR_DROP(dict, "tofu-historic", have_TOFU_HISTORIC);
    DICT_SETITEMSTR_DROP(dict, "tofu-symbol", have_TOFU_SYMBOL);
    DICT_SETITEMSTR_DROP(dict, "tofu-sil", have_TOFU_SIL);
    DICT_SETITEMSTR_DROP(dict, "icc", JM_BOOL(FZ_ENABLE_ICC));
    DICT_SETITEMSTR_DROP(dict, "base14", have_TOFU_BASE14);
    DICT_SETITEMSTR_DROP(dict, "py-memory", JM_BOOL(JM_MEMORY));
    return dict;
}

//----------------------------------------------------------------------------
// Update a color float array with values from a Python sequence.
// Any error condition is treated as a no-op.
//----------------------------------------------------------------------------
void JM_color_FromSequence(PyObject *color, int *n, float col[4])
{
    if (!color || (!PySequence_Check(color) && !PyFloat_Check(color)))
    {
        *n = 1;
        return;
    }
    if (PyFloat_Check(color)) // maybe just a single float
    {
        float c = (float) PyFloat_AsDouble(color);
        if (!INRANGE(c, 0.0f, 1.0f))
        {
            *n = 1;
            return;
        }
        col[0] = c;
        *n = 1;
        return;
    }

    int len = (int) PySequence_Size(color), i;
    if (!INRANGE(len, 1, 4) || len == 2)
    {
        *n = 1;
        return;
    }

    float mcol[4] = {0,0,0,0}; // local color storage
    for (i = 0; i < len; i++)
    {
        mcol[i] = (float) PyFloat_AsDouble(PySequence_ITEM(color, i));
        if (PyErr_Occurred())
        {
            PyErr_Clear(); // reset Py error indicator
            return;
        }
        if (!INRANGE(mcol[i], 0.0f, 1.0f)) return;
    }

    *n = len;
    for (i = 0; i < len; i++)
        col[i] = mcol[i];
    return;
}

// return extension for fitz image type
const char *JM_image_extension(int type)
{
    switch (type)
    {
        case(FZ_IMAGE_RAW): return "raw";
        case(FZ_IMAGE_FLATE): return "flate";
        case(FZ_IMAGE_LZW): return "lzw";
        case(FZ_IMAGE_RLD): return "rld";
        case(FZ_IMAGE_BMP): return "bmp";
        case(FZ_IMAGE_GIF): return "gif";
        case(FZ_IMAGE_JBIG2): return "jbig2";
        case(FZ_IMAGE_JPEG): return "jpeg";
        case(FZ_IMAGE_JPX): return "jpx";
        case(FZ_IMAGE_JXR): return "jxr";
        case(FZ_IMAGE_PNG): return "png";
        case(FZ_IMAGE_PNM): return "pnm";
        case(FZ_IMAGE_TIFF): return "tiff";
        default: return "n/a";
    }
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytes object
//----------------------------------------------------------------------------
PyObject *JM_BinFromBuffer(fz_context *ctx, fz_buffer *buffer)
{

#if  PY_VERSION_HEX < 0x03000000
 #define PyBytes_FromString(x) PyString_FromString(x)
 #define PyBytes_FromStringAndSize(c, l) PyString_FromStringAndSize(c, l)
#endif

    if (!buffer)
    {
        return PyBytes_FromString("");
    }
    char *c = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, &c);
    return PyBytes_FromStringAndSize(c, (Py_ssize_t) len);
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytearray object
//----------------------------------------------------------------------------
PyObject *JM_BArrayFromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    if (!buffer)
    {
        return PyByteArray_FromStringAndSize("", 0);
    }
    char *c = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, &c);
    return PyByteArray_FromStringAndSize(c, (Py_ssize_t) len);
}

//----------------------------------------------------------------------------
// Turn fz_buffer to a base64 encoded bytes object
//----------------------------------------------------------------------------
PyObject *JM_B64FromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    PyObject *bytes = PyBytes_FromString("");
    char *c = NULL;
    char *b64 = NULL;
    if (buffer)
    {
        size_t len = fz_buffer_storage(ctx, buffer, &c);
        fz_buffer *res = fz_new_buffer(ctx, len);
        fz_output *out = fz_new_output_with_buffer(ctx, res);
        fz_write_base64(ctx, out, (const unsigned char *) c, (int) len, 0);
        size_t nlen = fz_buffer_storage(ctx, res, &b64);
        Py_DECREF(bytes);
        bytes = PyBytes_FromStringAndSize(b64, (Py_ssize_t) nlen);
        fz_drop_buffer(ctx, res);
        fz_drop_output(ctx, out);
    }
    return bytes;
}

//----------------------------------------------------------------------------
// compress char* into a new buffer
//----------------------------------------------------------------------------
fz_buffer *JM_compress_buffer(fz_context *ctx, fz_buffer *inbuffer)
{
    fz_buffer *buf = NULL;
    fz_try(ctx)
    {
        size_t compressed_length = 0;
        unsigned char *data = fz_new_deflated_data_from_buffer(ctx,
                              &compressed_length, inbuffer, FZ_DEFLATE_BEST);
        if (data == NULL || compressed_length == 0)
            return NULL;
        buf = fz_new_buffer_from_data(ctx, data, compressed_length);
        fz_resize_buffer(ctx, buf, compressed_length);
    }
    fz_catch(ctx)
    {
        fz_drop_buffer(ctx, buf);
        fz_rethrow(ctx);
    }
    return buf;
}

//----------------------------------------------------------------------------
// update a stream object
// compress stream when beneficial
//----------------------------------------------------------------------------
void JM_update_stream(fz_context *ctx, pdf_document *doc, pdf_obj *obj, fz_buffer *buffer, int compress)
{
    
    fz_buffer *nres = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, NULL);
    size_t nlen = len;

    if (len > 30)       // ignore small stuff
    {
        nres = JM_compress_buffer(ctx, buffer);
        nlen = fz_buffer_storage(ctx, nres, NULL);
    }

    if (nlen < len && nres && compress==1)  // was it worth the effort?
    {
        pdf_dict_put(ctx, obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
        pdf_update_stream(ctx, doc, obj, nres, 1);
    }
    else
    {
        pdf_update_stream(ctx, doc, obj, buffer, 0);
    }
    fz_drop_buffer(ctx, nres);
}

//-----------------------------------------------------------------------------
// return hex characters for n characters in input 'in'
//-----------------------------------------------------------------------------
void hexlify(int n, unsigned char *in, unsigned char *out)
{
    const unsigned char hdigit[17] = "0123456789abcedf";
    int i, i1, i2;
    for (i = 0; i < n; i++)
    {
        i1 = in[i]>>4;
        i2 = in[i] - i1*16;
        out[2*i] = hdigit[i1];
        out[2*i + 1] = hdigit[i2];
    }
    out[2*n] = 0;
}

//----------------------------------------------------------------------------
// Make fz_buffer from a PyBytes, PyByteArray, io.BytesIO object
//----------------------------------------------------------------------------
fz_buffer *JM_BufferFromBytes(fz_context *ctx, PyObject *stream)
{
    if (!stream) return NULL;
    if (stream == Py_None) return NULL;
    char *c = NULL;
    PyObject *mybytes = NULL;
    size_t len = 0;
    fz_buffer *res = NULL;
    fz_var(res);
    fz_try(ctx)
    {
        if (PyBytes_Check(stream))
        {
            c = PyBytes_AS_STRING(stream);
            len = (size_t) PyBytes_GET_SIZE(stream);
        }
        else if (PyByteArray_Check(stream))
        {
            c = PyByteArray_AS_STRING(stream);
            len = (size_t) PyByteArray_GET_SIZE(stream);
        }
        else if (PyObject_HasAttrString(stream, "getvalue"))
        {   // we assume here that this delivers what we expect
            mybytes = PyObject_CallMethod(stream, "getvalue", NULL);
            c = PyBytes_AS_STRING(mybytes);
            len = (size_t) PyBytes_GET_SIZE(mybytes);
        }
        // all the above leave c as NULL pointer if unsuccessful
        if (c) res = fz_new_buffer_from_copied_data(ctx, c, len);
    }
    fz_always(ctx)
    {
        Py_CLEAR(mybytes);
        PyErr_Clear();
    }
    fz_catch(ctx)
    {
        fz_drop_buffer(ctx, res);
        fz_rethrow(ctx);
    }
    return res;
}

//----------------------------------------------------------------------------
// Modified copy of SWIG_Python_str_AsChar
// If Py3, the SWIG original v3.0.12 does *not* deliver NULL for a
// non-string input, as does PyString_AsString in Py2.
//----------------------------------------------------------------------------
char *JM_Python_str_AsChar(PyObject *str)
{
    if (!str) return NULL;
#if PY_VERSION_HEX >= 0x03000000
  char *newstr = NULL;
  PyObject *xstr = PyUnicode_AsUTF8String(str);
  if (xstr)
  {
    char *cstr;
    Py_ssize_t len;
    PyBytes_AsStringAndSize(xstr, &cstr, &len);
    size_t l = len + 1;
    newstr = JM_Alloc(char, l);
    memcpy(newstr, cstr, l);
    Py_XDECREF(xstr);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define JM_Python_str_DelForPy3(x) JM_Free(x)
#else
#  define JM_Python_str_DelForPy3(x)
#endif

//----------------------------------------------------------------------------
// Deep-copies a specified source page to the target location.
// Modified copy of function of pdfmerge.c: we also copy annotations, but
// we skip **link** annotations. In addition we rotate output.
//----------------------------------------------------------------------------
void page_merge(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int page_from, int page_to, int rotate, int links, int copy_annots, pdf_graft_map *graft_map)
{
    pdf_obj *page_ref = NULL;
    pdf_obj *page_dict = NULL;
    pdf_obj *obj = NULL, *ref = NULL;

    // list of object types (per page) we want to copy
    pdf_obj *known_page_objs[] = {
        PDF_NAME(Contents),
        PDF_NAME(Resources),
        PDF_NAME(MediaBox),
        PDF_NAME(CropBox),
        PDF_NAME(BleedBox),
        PDF_NAME(TrimBox),
        PDF_NAME(ArtBox),
        PDF_NAME(Rotate),
        PDF_NAME(UserUnit)
    };
    int i, n = nelem(known_page_objs);  // number of list elements
    fz_var(obj);
    fz_var(ref);
    fz_var(page_dict);
    fz_try(ctx)
    {
        page_ref = pdf_lookup_page_obj(ctx, doc_src, page_from);
        pdf_flatten_inheritable_page_items(ctx, page_ref);

        // make a new page
        page_dict = pdf_new_dict(ctx, doc_des, 4);
        pdf_dict_put(ctx, page_dict, PDF_NAME(Type), PDF_NAME(Page));

        // copy objects of source page into it
        for (i = 0; i < n; i++)
        {
            obj = pdf_dict_get(ctx, page_ref, known_page_objs[i]);
            if (obj != NULL)
                pdf_dict_put_drop(ctx, page_dict, known_page_objs[i], pdf_graft_mapped_object(ctx, graft_map, obj));
        }

        if (copy_annots)  // we shall copy annotations also
        {
            pdf_obj *old_annots = pdf_dict_get(ctx, page_ref, PDF_NAME(Annots));
            if (old_annots)  // there is an annot array
            {
                n = pdf_array_len(ctx, old_annots);
                pdf_obj *new_annots = pdf_new_array(ctx, doc_des, n);
                for (i = 0; i < n; i++)
                {
                    pdf_obj *o = pdf_array_get(ctx, old_annots, i);
                    if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)),
                                     PDF_NAME(Link)))
                    {
                        pdf_array_push_drop(ctx, new_annots,
                                pdf_graft_mapped_object(ctx, graft_map, o));
                    }
                }
                if (pdf_array_len(ctx, new_annots))
                {
                    pdf_dict_put_drop(ctx, page_dict, PDF_NAME(Annots), new_annots);
                }
                else
                {
                    pdf_drop_obj(ctx, new_annots);
                }
            }
        }
        // rotate the page as requested
        if (rotate != -1)
        {
            pdf_dict_put_int(ctx, page_dict, PDF_NAME(Rotate), (int64_t) rotate);
        }
        // Now add the page dictionary to dest PDF
        obj = pdf_add_object(ctx, doc_des, page_dict);

        // Get indirect ref of the new page
        int num = pdf_to_num(ctx, obj);
        ref = pdf_new_indirect(ctx, doc_des, num, 0);

        // Insert new page at specified location
        pdf_insert_page(ctx, doc_des, page_to, ref);

    }
    fz_always(ctx)
    {
        pdf_drop_obj(ctx, obj);
        pdf_drop_obj(ctx, ref);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

//-----------------------------------------------------------------------------
// Copy a range of pages (spage, epage) from a source PDF to a specified
// location (apage) of the target PDF.
// If spage > epage, the sequence of source pages is reversed.
//-----------------------------------------------------------------------------
void merge_range(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int spage, int epage, int apage, int rotate, int links, int annots)
{
    int page, afterpage, count;
    pdf_graft_map *graft_map;
    afterpage = apage;
    count = pdf_count_pages(ctx, doc_src);
    graft_map = pdf_new_graft_map(ctx, doc_des);

    fz_try(ctx)
    {
        if (spage < epage)
            for (page = spage; page <= epage; page++, afterpage++)
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
        else
            for (page = spage; page >= epage; page--, afterpage++)
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
    }

    fz_always(ctx)
    {
        pdf_drop_graft_map(ctx, graft_map);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

//----------------------------------------------------------------------------
// Return list of outline xref numbers. Recursive function. Arguments:
// 'obj' first OL item
// 'xrefs' empty Python list
//----------------------------------------------------------------------------
PyObject *JM_outline_xrefs(fz_context *ctx, pdf_obj *obj, PyObject *xrefs)
{
    pdf_obj *first, *parent, *thisobj;
    if (!obj) return xrefs;
    thisobj = obj;
    while (thisobj)
    {
        LIST_APPEND_DROP(xrefs, Py_BuildValue("i", pdf_to_num(ctx, thisobj)));
        first = pdf_dict_get(ctx, thisobj, PDF_NAME(First));   // try go down
        if (first) xrefs = JM_outline_xrefs(ctx, first, xrefs);
        thisobj = pdf_dict_get(ctx, thisobj, PDF_NAME(Next));  // try go next
        parent = pdf_dict_get(ctx, thisobj, PDF_NAME(Parent)); // get parent
        if (!thisobj) thisobj = parent;      /* goto parent if no next exists */
    }
    return xrefs;
}

//-----------------------------------------------------------------------------
// Return the contents of a font file
//-----------------------------------------------------------------------------
fz_buffer *JM_get_fontbuffer(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return NULL;
    pdf_obj *o, *obj = NULL, *desft, *stream = NULL;
    char *ext = "";
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    if (desft)
    {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    }
    else
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));

    if (!obj)
    {
        pdf_drop_obj(ctx, o);
        PySys_WriteStdout("invalid font - FontDescriptor missing");
        return NULL;
    }
    pdf_drop_obj(ctx, o);
    o = obj;

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) stream = obj;             // ext = "pfa"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) stream = obj;             // ext = "ttf"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj)
    {
        stream = obj;

        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj))
        {
            PySys_WriteStdout("invalid font descriptor subtype");
            return NULL;
        }

        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            ext = "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            ext = "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            ext = "otf";
        else
            PySys_WriteStdout("warning: unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    if (!stream)
    {
        PySys_WriteStdout("warning: unhandled font type");
        return NULL;
    }

    return pdf_load_stream(ctx, stream);
}

//-----------------------------------------------------------------------------
// Return the file extension of an embedded font file
//-----------------------------------------------------------------------------
char *JM_get_fontextension(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return "n/a";
    pdf_obj *o, *obj = NULL, *desft;
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    if (desft)
    {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    }
    else
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));

    pdf_drop_obj(ctx, o);
    if (!obj) return "n/a";           // this is a base-14 font

    o = obj;                           // we have the FontDescriptor

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) return "pfa";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) return "ttf";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj)
    {
        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj))
        {
            PySys_WriteStdout("invalid font descriptor subtype");
            return "n/a";
        }
        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            return "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            return "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            return "otf";
        else
            PySys_WriteStdout("unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    return "n/a";
}


//-----------------------------------------------------------------------------
// version of fz_show_string, also covering UCDN script
//-----------------------------------------------------------------------------
fz_matrix JM_show_string(fz_context *ctx, fz_text *text, fz_font *user_font, fz_matrix trm, const char *s, int wmode, int bidi_level, fz_bidi_direction markup_dir, fz_text_language language, int script)
{
    fz_font *font;
    int gid, ucs;
    float adv;

    while (*s)
    {
        s += fz_chartorune(&ucs, s);
        gid = fz_encode_character_with_fallback(ctx, user_font, ucs, script, language, &font);
        fz_show_glyph(ctx, text, font, trm, gid, ucs, wmode, bidi_level, markup_dir, language);
        adv = fz_advance_glyph(ctx, font, gid, wmode);
        if (wmode == 0)
            trm = fz_pre_translate(trm, adv, 0);
        else
            trm = fz_pre_translate(trm, 0, -adv);
    }

    return trm;
}


//-----------------------------------------------------------------------------
// return fz_font from given alternatives
//-----------------------------------------------------------------------------
fz_font *JM_get_font(fz_context *ctx,
    char *fontname,
    char *fontfile,
    PyObject *fontbuffer,
    int script,
    int lang,
    int ordering,
    int is_bold,
    int is_italic)
{
    const unsigned char *data = NULL;
    int size, index=0;
    fz_buffer *res = NULL;
    fz_font *font = NULL;
    fz_try(ctx)
    {
        if (fontfile) goto have_file;
        if (EXISTS(fontbuffer)) goto have_buffer;
        if (ordering > -1) goto have_cjk;
        if (fontname) goto have_base14;
        goto have_noto;
        // Base-14 font
        have_base14:;
        data = fz_lookup_base14_font(ctx, fontname, &size);
        if (data)
        {
            font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
            goto fertig;
        }
        data = fz_lookup_builtin_font(gctx, fontname, is_bold, is_italic, &size);
        if (data)
        {
            font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
        }
        goto fertig;

        // CJK font
        have_cjk:;
        data = fz_lookup_cjk_font(ctx, ordering, &size, &index);
        if (data)
        {
            font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
        }
        goto fertig;

        // fontfile
        have_file:;
        font = fz_new_font_from_file(ctx, NULL, fontfile, index, 0);
        goto fertig;

        // fontbuffer
        have_buffer:;
        res = JM_BufferFromBytes(ctx, fontbuffer);
        font = fz_new_font_from_buffer(ctx, NULL, res, index, 0);
        goto fertig;

        // Check for NOTO font
        have_noto:;
        data = fz_lookup_noto_font(ctx, script, lang, &size, &index);
        if (data)
        {
            font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
        }
        goto fertig;

        fertig:;
    }
    fz_always(ctx)
    {
        fz_drop_buffer(ctx, res);
    }
    fz_catch(ctx)
    {
        PySys_WriteStderr("error allocating the font");
        fz_rethrow(ctx);
    }
    return font;
}


//-----------------------------------------------------------------------------
// create PDF object from given string (new in v1.14.0: MuPDF dropped it)
//-----------------------------------------------------------------------------
pdf_obj *JM_pdf_obj_from_str(fz_context *ctx, pdf_document *doc, char *src)
{
    pdf_obj *result = NULL;
    pdf_lexbuf lexbuf;
    fz_stream *stream = fz_open_memory(ctx, (unsigned char *)src, strlen(src));

    pdf_lexbuf_init(ctx, &lexbuf, PDF_LEXBUF_SMALL);

    fz_try(ctx)
        result = pdf_parse_stm_obj(ctx, doc, stream, &lexbuf);

    fz_always(ctx)
    {
        pdf_lexbuf_fin(ctx, &lexbuf);
        fz_drop_stream(ctx, stream);
    }

    fz_catch(ctx)
        fz_rethrow(ctx);

    return result;

}

//-----------------------------------------------------------------------------
// dummy structure for various tools and utilities
//-----------------------------------------------------------------------------
struct Tools {int index;};

typedef struct fz_item_s fz_item;

struct fz_item_s
{
	void *key;
	fz_storable *val;
	size_t size;
	fz_item *next;
	fz_item *prev;
	fz_store *store;
	const fz_store_type *type;
};

struct fz_store_s
{
	int refs;

	/* Every item in the store is kept in a doubly linked list, ordered
	 * by usage (so LRU entries are at the end). */
	fz_item *head;
	fz_item *tail;

	/* We have a hash table that allows to quickly find a subset of the
	 * entries (those whose keys are indirect objects). */
	fz_hash_table *hash;

	/* We keep track of the size of the store, and keep it below max. */
	size_t max;
	size_t size;

	int defer_reap_count;
	int needs_reaping;
};


//----------------------------------------------------------------------------
// return normalized /Rotate value
//----------------------------------------------------------------------------
int JM_norm_rotation(int rotate)
{
    while (rotate < 0) rotate += 360;
    while (rotate >= 360) rotate -= 360;
    if (rotate % 90 != 0) return 0;
    return rotate;
}


//----------------------------------------------------------------------------
// return a PDF page's /Rotate value
//----------------------------------------------------------------------------
int JM_page_rotation(fz_context *ctx, pdf_page *page)
{
    int rotate = 0;
    fz_try(ctx)
    {
        rotate = pdf_to_int(ctx,
                pdf_dict_get_inheritable(ctx, page->obj, PDF_NAME(Rotate)));
        rotate = JM_norm_rotation(rotate);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return rotate;
}


//----------------------------------------------------------------------------
// return a PDF page's MediaBox
//----------------------------------------------------------------------------
fz_rect JM_mediabox(fz_context *ctx, pdf_page *page)
{
    fz_rect mediabox, page_mediabox;
    pdf_obj *obj;
    float userunit = 1;

    obj = pdf_dict_get(ctx, page->obj, PDF_NAME(UserUnit));
    if (pdf_is_real(ctx, obj))
        userunit = pdf_to_real(ctx, obj);

    mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, page->obj,
        PDF_NAME(MediaBox)));
    if (fz_is_empty_rect(mediabox) || fz_is_infinite_rect(mediabox))
    {
        mediabox.x0 = 0;
        mediabox.y0 = 0;
        mediabox.x1 = 612;
        mediabox.y1 = 792;
    }

    page_mediabox.x0 = fz_min(mediabox.x0, mediabox.x1);
    page_mediabox.y0 = fz_min(mediabox.y0, mediabox.y1);
    page_mediabox.x1 = fz_max(mediabox.x0, mediabox.x1);
    page_mediabox.y1 = fz_max(mediabox.y0, mediabox.y1);

    if (page_mediabox.x1 - page_mediabox.x0 < 1 ||
        page_mediabox.y1 - page_mediabox.y0 < 1)
        page_mediabox = fz_unit_rect;

    return page_mediabox;
}


//----------------------------------------------------------------------------
// return a PDF page's CropBox
//----------------------------------------------------------------------------
fz_rect JM_cropbox(fz_context *ctx, pdf_page *page)
{
    fz_rect mediabox = JM_mediabox(ctx, page);
    fz_rect cropbox = pdf_to_rect(ctx,
                pdf_dict_get_inheritable(ctx, page->obj, PDF_NAME(CropBox)));
    if (fz_is_infinite_rect(cropbox) || fz_is_empty_rect(cropbox))
        cropbox = mediabox;
    float y0 = mediabox.y1 - cropbox.y1;
    float y1 = mediabox.y1 - cropbox.y0;
    cropbox.y0 = y0;
    cropbox.y1 = y1;
    return cropbox;
}


//----------------------------------------------------------------------------
// determine width and height of the unrotated page
//----------------------------------------------------------------------------
fz_point JM_cropbox_size(fz_context *ctx, pdf_page *page)
{
    fz_point size;
    fz_try(ctx)
    {
        fz_rect rect = JM_cropbox(ctx, page);
        float w = (rect.x0 < rect.x1 ? rect.x1 - rect.x0 : rect.x0 - rect.x1);
        float h = (rect.y0 < rect.y1 ? rect.y1 - rect.y0 : rect.y0 - rect.y1);
        size = fz_make_point(w, h);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return size;
}


//----------------------------------------------------------------------------
// calculate NON-ROTATED point coordinates
//----------------------------------------------------------------------------
fz_point JM_derotate_point(fz_context *ctx, pdf_page *page, fz_point point)
{
    fz_point newp;
    fz_try(ctx)
    {
        fz_point cb_size = JM_cropbox_size(ctx, page);
        float w = cb_size.x;
        float h = cb_size.y;
        int rotate = JM_page_rotation(ctx, page);
        if (rotate == 0)
            newp = point;
        else if (rotate == 90)
            newp = fz_make_point(point.y, h - point.x);
        else if (rotate == 180)
            newp = fz_make_point(w - point.x, h - point.y);
        else  // rotate == 270
            newp = fz_make_point(w - point.y, point.x);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return newp;
}


//----------------------------------------------------------------------------
// calculate ROTATED point coordinates
//----------------------------------------------------------------------------
fz_point JM_rotate_point(fz_context *ctx, pdf_page *page, fz_point point)
{
    fz_point newp;
    fz_try(ctx)
    {
        fz_point cb_size = JM_cropbox_size(ctx, page);
        float w = cb_size.x;
        float h = cb_size.y;
        int rotate = JM_page_rotation(ctx, page);
        if (rotate == 0)
            newp = point;
        else if (rotate == 90)
            newp = fz_make_point(h - point.y, point.x);
        else if (rotate == 180)
            newp = fz_make_point(w - point.x, h - point.y);
        else  // rotate == 270
            newp = fz_make_point(point.y, w - point.x);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return newp;
}


//----------------------------------------------------------------------------
// calculate ROTATED rect coordinates
//----------------------------------------------------------------------------
fz_rect JM_rotate_rect(fz_context *ctx, pdf_page *page, fz_rect rect)
{
    fz_rect newr;
    fz_try(ctx)
    {
        fz_point p;
        p = JM_rotate_point(ctx, page, fz_make_point(rect.x0, rect.y0));
        newr.x0 = p.x;
        newr.y0 = p.y;
        newr.x1 = p.x;
        newr.y1 = p.y;
        p = JM_rotate_point(ctx, page, fz_make_point(rect.x1, rect.y0));
        newr = fz_include_point_in_rect(newr, p);
        p = JM_rotate_point(ctx, page, fz_make_point(rect.x0, rect.y1));
        newr = fz_include_point_in_rect(newr, p);
        p = JM_rotate_point(ctx, page, fz_make_point(rect.x1, rect.y1));
        newr = fz_include_point_in_rect(newr, p);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return newr;
}


//----------------------------------------------------------------------------
// calculate NON-ROTATED rect coordinates
//----------------------------------------------------------------------------
fz_rect JM_derotate_rect(fz_context *ctx, pdf_page *page, fz_rect rect)
{
    fz_rect newr;
    fz_try(ctx)
    {
        fz_point p;
        p = JM_derotate_point(ctx, page, fz_make_point(rect.x0, rect.y0));
        newr.x0 = p.x;
        newr.y0 = p.y;
        newr.x1 = p.x;
        newr.y1 = p.y;
        p = JM_derotate_point(ctx, page, fz_make_point(rect.x1, rect.y0));
        newr = fz_include_point_in_rect(newr, p);
        p = JM_derotate_point(ctx, page, fz_make_point(rect.x0, rect.y1));
        newr = fz_include_point_in_rect(newr, p);
        p = JM_derotate_point(ctx, page, fz_make_point(rect.x1, rect.y1));
        newr = fz_include_point_in_rect(newr, p);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return newr;
}


//-----------------------------------------------------------------------------
// pixmap helper functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Clear a pixmap rectangle - my version also supports non-alpha pixmaps
//-----------------------------------------------------------------------------
int
JM_clear_pixmap_rect_with_value(fz_context *ctx, fz_pixmap *dest, int value, fz_irect b)
{
    unsigned char *destp;
    int x, y, w, k, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));

    /* CMYK needs special handling (and potentially any other subtractive colorspaces) */
    if (fz_colorspace_n(ctx, dest->colorspace) == 4)
    {
        value = 255 - value;
        do
        {
            unsigned char *s = destp;
            for (x = 0; x < w; x++)
            {
                *s++ = 0;
                *s++ = 0;
                *s++ = 0;
                *s++ = value;
                if (dest->alpha) *s++ = 255;
            }
            destp += destspan;
        }
        while (--y);
        return 1;
    }

    do
    {
        unsigned char *s = destp;
        for (x = 0; x < w; x++)
        {
            for (k = 0; k < dest->n - 1; k++)
                *s++ = value;
            if (dest->alpha) *s++ = 255;
            else *s++ = value;
        }
        destp += destspan;
    }
    while (--y);
    return 1;
}

//-----------------------------------------------------------------------------
// fill a rect with a color tuple
//-----------------------------------------------------------------------------
int
JM_fill_pixmap_rect_with_color(fz_context *ctx, fz_pixmap *dest, unsigned char col[5], fz_irect b)
{
    unsigned char *destp;
    int x, y, w, i, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));

    do
    {
        unsigned char *s = destp;
        for (x = 0; x < w; x++)
        {
            for (i = 0; i < dest->n; i++)
                *s++ = col[i];
        }
        destp += destspan;
    }
    while (--y);
    return 1;
}

//-----------------------------------------------------------------------------
// invert a rectangle - also supports non-alpha pixmaps
//-----------------------------------------------------------------------------
int
JM_invert_pixmap_rect(fz_context *ctx, fz_pixmap *dest, fz_irect b)
{
    unsigned char *destp;
    int x, y, w, i, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));
    int n0 = dest->n - dest->alpha;
    do
    {
        unsigned char *s = destp;
        for (x = 0; x < w; x++)
        {
            for (i = 0; i < n0; i++)
                *s++ = 255 - *s;
            if (dest->alpha) *s++;
        }
        destp += destspan;
    }
    while (--y);
    return 1;
}

//-----------------------------------------------------------------------------
// Return basic properties of an image provided as bytes or bytearray
// The function creates an fz_image and optionally returns it.
//-----------------------------------------------------------------------------
PyObject *JM_image_profile(fz_context *ctx, PyObject *imagedata, int keep_image)
{
    if (!EXISTS(imagedata))
    {
        Py_RETURN_NONE;  // nothing given
    }
    fz_image *image = NULL;
    fz_buffer *res = NULL;
    PyObject *result = NULL;
    unsigned char *c = NULL;
    Py_ssize_t len = 0;
    if (PyBytes_Check(imagedata))
    {
        c = PyBytes_AS_STRING(imagedata);
        len = PyBytes_GET_SIZE(imagedata);
    }
    else if (PyByteArray_Check(imagedata))
    {
        c = PyByteArray_AS_STRING(imagedata);
        len = PyByteArray_GET_SIZE(imagedata);
    }
    else
    {
        PySys_WriteStderr("bad image data\n");
        Py_RETURN_NONE;
    }

    if (len < 8)
    {
        PySys_WriteStderr("bad image data\n");
        Py_RETURN_NONE;
    }
    int type = fz_recognize_image_format(ctx, c);
    if (type == FZ_IMAGE_UNKNOWN)
    {
        Py_RETURN_NONE;
    }

    fz_try(ctx)
    {
        if (keep_image)  // ensure image buffer is not dropped
        {
            res = fz_new_buffer_from_copied_data(ctx, c, (size_t) len);
        }
        else
        {
            res = fz_new_buffer_from_shared_data(ctx, c, (size_t) len);
        }
        image = fz_new_image_from_buffer(ctx, res);
        int xres, yres;
        fz_image_resolution(image, &xres, &yres);
        const char *cs_name = fz_colorspace_name(gctx, image->colorspace);
        result = PyDict_New();
        DICT_SETITEM_DROP(result, dictkey_width,
                Py_BuildValue("i", image->w));
        DICT_SETITEM_DROP(result, dictkey_height,
                Py_BuildValue("i", image->h));
        DICT_SETITEM_DROP(result, dictkey_xres,
                Py_BuildValue("i", xres));
        DICT_SETITEM_DROP(result, dictkey_yres,
                Py_BuildValue("i", yres));
        DICT_SETITEM_DROP(result, dictkey_colorspace,
                Py_BuildValue("i", image->n));
        DICT_SETITEM_DROP(result, dictkey_bpc,
                Py_BuildValue("i", image->bpc));
        DICT_SETITEM_DROP(result, dictkey_ext,
                Py_BuildValue("s", JM_image_extension(type)));
        DICT_SETITEM_DROP(result, dictkey_cs_name,
                Py_BuildValue("s", cs_name));

        if (keep_image)  // hand over fz_image address and do not drop
        {
            DICT_SETITEM_DROP(result, dictkey_image,
                    PyLong_FromVoidPtr((void *) fz_keep_image(ctx, image)));
        }
    }
    fz_always(ctx)
    {
        if (!keep_image)  // drop the image
        {
            fz_drop_image(ctx, image);
        }
        else
        {
            fz_drop_buffer(ctx, res);  // drop the buffer copy
        }
    }
    fz_catch(ctx)
    {
        Py_CLEAR(result);
        Py_RETURN_NONE;
    }
    PyErr_Clear();
    return result;
}

//----------------------------------------------------------------------------
// Version of fz_new_pixmap_from_display_list (util.c) to also support
// rendering of only the 'clip' part of the displaylist rectangle
//----------------------------------------------------------------------------
fz_pixmap *
JM_pixmap_from_display_list(fz_context *ctx,
                            fz_display_list *list,
                            PyObject *ctm,
                            fz_colorspace *cs,
                            int alpha,
                            PyObject *clip,
                            fz_separations *seps
                           )
{
    fz_rect rect = fz_bound_display_list(ctx, list);
    fz_matrix matrix = JM_matrix_from_py(ctm);
    fz_pixmap *pix = NULL;
    fz_var(pix);
    fz_device *dev = NULL;
    fz_var(dev);
    fz_rect rclip = JM_rect_from_py(clip);
    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given

    rect = fz_transform_rect(rect, matrix);
    fz_irect irect = fz_round_rect(rect);

    pix = fz_new_pixmap_with_bbox(ctx, cs, irect, seps, alpha);
    if (alpha)
        fz_clear_pixmap(ctx, pix);
    else
        fz_clear_pixmap_with_value(ctx, pix, 0xFF);

    fz_try(ctx)
    {
        if (!fz_is_infinite_rect(rclip))
        {
            dev = fz_new_draw_device_with_bbox(ctx, matrix, pix, &irect);
            fz_run_display_list(ctx, list, dev, fz_identity, rclip, NULL);
        }
        else
        {
            dev = fz_new_draw_device(ctx, matrix, pix);
            fz_run_display_list(ctx, list, dev, fz_identity, fz_infinite_rect, NULL);
        }

        fz_close_device(ctx, dev);
    }
    fz_always(ctx)
    {
        fz_drop_device(ctx, dev);
    }
    fz_catch(ctx)
    {
        fz_drop_pixmap(ctx, pix);
        fz_rethrow(ctx);
    }
    return pix;
}

//----------------------------------------------------------------------------
// Pixmap creation directly using a short-lived displaylist, so we can support
// separations.
//----------------------------------------------------------------------------
fz_pixmap *
JM_pixmap_from_page(fz_context *ctx,
                    fz_document *doc,
                    fz_page *page,
                    PyObject *ctm,
                    fz_colorspace *cs,
                    int alpha,
                    int annots,
                    PyObject *clip
                   )
{
    enum { SPOTS_NONE, SPOTS_OVERPRINT_SIM, SPOTS_FULL };
    int spots;
    if (FZ_ENABLE_SPOT_RENDERING)
        spots = SPOTS_OVERPRINT_SIM;
    else
        spots = SPOTS_NONE;

    fz_separations *seps = NULL;
    fz_pixmap *pix = NULL;
    fz_colorspace *oi = NULL;
    fz_var(oi);
    fz_colorspace *colorspace = cs;
    fz_rect rect;
    fz_irect bbox;
    fz_device *dev = NULL;
    fz_var(dev);
    fz_matrix matrix = JM_matrix_from_py(ctm);
    rect = fz_bound_page(ctx, page);
    fz_rect rclip = JM_rect_from_py(clip);
    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given
    rect = fz_transform_rect(rect, matrix);
    bbox = fz_round_rect(rect);

    fz_try(ctx)
    {
        // Pixmap of the document's /OutputIntents ("output intents")
        oi = fz_document_output_intent(ctx, doc);
        // if present and compatible, use it instead of the parameter
        if (oi)
        {
            if (fz_colorspace_n(ctx, oi) == fz_colorspace_n(ctx, cs))
            {
                colorspace = fz_keep_colorspace(ctx, oi);
            }
        }

        // check if spots rendering is available and if so use separations
        if (spots != SPOTS_NONE)
        {
            seps = fz_page_separations(ctx, page);
            if (seps)
            {
                int i, n = fz_count_separations(ctx, seps);
                if (spots == SPOTS_FULL)
                    for (i = 0; i < n; i++)
                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_SPOT);
                else
                    for (i = 0; i < n; i++)
                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_COMPOSITE);
            }
            else if (fz_page_uses_overprint(ctx, page))
            {
                /* This page uses overprint, so we need an empty
                 * sep object to force the overprint simulation on. */
                seps = fz_new_separations(ctx, 0);
            }
            else if (oi && fz_colorspace_n(ctx, oi) != fz_colorspace_n(ctx, colorspace))
            {
                /* We have an output intent, and it's incompatible
                 * with the colorspace our device needs. Force the
                 * overprint simulation on, because this ensures that
                 * we 'simulate' the output intent too. */
                seps = fz_new_separations(ctx, 0);
            }
        }

        pix = fz_new_pixmap_with_bbox(ctx, colorspace, bbox, seps, alpha);

        if (alpha)
        {
            fz_clear_pixmap(ctx, pix);
        }
        else
        {
            fz_clear_pixmap_with_value(ctx, pix, 0xFF);
        }

        dev = fz_new_draw_device(ctx, matrix, pix);
        if (annots)
        {
            fz_run_page(ctx, page, dev, fz_identity, NULL);
        }
        else
        {
            fz_run_page_contents(ctx, page, dev, fz_identity, NULL);
        }
        fz_close_device(ctx, dev);
    }
    fz_always(ctx)
    {
        fz_drop_device(ctx, dev);
        fz_drop_separations(ctx, seps);
        fz_drop_colorspace(ctx, oi);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
    return pix;
}



//----------------------------------------------------------------------------
// return code for line end style string
//----------------------------------------------------------------------------
int JM_le_value(fz_context *ctx, char *le)
{
    if (!le) return PDF_ANNOT_LE_NONE;
    return pdf_line_ending_from_string(ctx, le);
}

//----------------------------------------------------------------------------
// return pdf_obj "border style" from Python str
//----------------------------------------------------------------------------
pdf_obj *JM_get_border_style(fz_context *ctx, PyObject *style)
{
    pdf_obj *val = PDF_NAME(S);
    if (!style) return val;
    char *s = JM_Python_str_AsChar(style);
    JM_PyErr_Clear;
    if (!s) return val;
    if      (!strncmp(s, "b", 1) || !strncmp(s, "B", 1)) val = PDF_NAME(B);
    else if (!strncmp(s, "d", 1) || !strncmp(s, "D", 1)) val = PDF_NAME(D);
    else if (!strncmp(s, "i", 1) || !strncmp(s, "I", 1)) val = PDF_NAME(I);
    else if (!strncmp(s, "u", 1) || !strncmp(s, "U", 1)) val = PDF_NAME(U);
    JM_Python_str_DelForPy3(s);
    return val;
}

//----------------------------------------------------------------------------
// Make /DA string of annotation
//----------------------------------------------------------------------------
const char *JM_expand_fname(const char **name)
{
    if (!*name) return "Helv";
    if (!strncmp(*name, "Co", 2)) return "Cour";
    if (!strncmp(*name, "co", 2)) return "Cour";
    if (!strncmp(*name, "Ti", 2)) return "TiRo";
    if (!strncmp(*name, "ti", 2)) return "TiRo";
    if (!strncmp(*name, "Sy", 2)) return "Symb";
    if (!strncmp(*name, "sy", 2)) return "Symb";
    if (!strncmp(*name, "Za", 2)) return "ZaDb";
    if (!strncmp(*name, "za", 2)) return "ZaDb";
    return "Helv";
}

void JM_make_annot_DA(fz_context *ctx, pdf_annot *annot, int ncol, float col[4], const char *fontname, float fontsize)
{
    fz_buffer *buf = NULL;
    fz_try(ctx)
    {
        buf = fz_new_buffer(ctx, 50);
       if (ncol == 1)
            fz_append_printf(ctx, buf, "%g g ", col[0]);
        else if (ncol == 3)
            fz_append_printf(ctx, buf, "%g %g %g rg ", col[0], col[1], col[2]);
        else
            fz_append_printf(ctx, buf, "%g %g %g %g k ", col[0], col[1], col[2], col[3]);
        fz_append_printf(ctx, buf, "/%s %g Tf", JM_expand_fname(&fontname), fontsize);
        char *da = NULL;
        size_t len = fz_buffer_storage(ctx, buf, &da);
        pdf_dict_put_string(ctx, annot->obj, PDF_NAME(DA), (const char *)da, len);
    }
    fz_always(ctx) fz_drop_buffer(ctx, buf);
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}

//----------------------------------------------------------------------------
// refreshes the link and annotation tables of a page
//----------------------------------------------------------------------------
void JM_refresh_link_table(fz_context *ctx, pdf_page *page)
{
    fz_try(ctx)
    {
        pdf_obj *annots_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
        if (annots_arr)
        {
            fz_rect page_mediabox;
            fz_matrix page_ctm;
            pdf_page_transform(ctx, page, &page_mediabox, &page_ctm);
            page->links = pdf_load_link_annots(ctx, page->doc, annots_arr,
                                            pdf_to_num(ctx, page->obj), page_ctm);
            pdf_load_annots(ctx, page, annots_arr);
        }
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
    return;
}


PyObject *JM_annot_border(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *dash_py   = PyList_New(0);
    PyObject *effect_py = PyList_New(0);
    PyObject *val;
    int i;
    char *effect2 = NULL, *style = NULL;
    float width = -1.0f;
    int effect1 = -1;

    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(Border));
    if (pdf_is_array(ctx, o))
    {
        width = pdf_to_real(ctx, pdf_array_get(ctx, o, 2));
        if (pdf_array_len(ctx, o) == 4)
        {
            pdf_obj *dash = pdf_array_get(ctx, o, 3);
            for (i = 0; i < pdf_array_len(ctx, dash); i++)
            {
                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, dash, i)));
                LIST_APPEND_DROP(dash_py, val);
            }
        }
    }

    pdf_obj *bs_o = pdf_dict_get(ctx, annot_obj, PDF_NAME(BS));
    if (bs_o)
    {
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(W));
        if (o) width = pdf_to_real(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(S));
        if (o) style = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(D));
        if (o)
        {
            for (i = 0; i < pdf_array_len(ctx, o); i++)
            {
                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, o, i)));
                LIST_APPEND_DROP(dash_py, val);
            }
        }
    }

    pdf_obj *be_o = pdf_dict_gets(ctx, annot_obj, "BE");
    if (be_o)
    {
        o = pdf_dict_get(ctx, be_o, PDF_NAME(S));
        if (o) effect2 = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, be_o, PDF_NAME(I));
        if (o) effect1 = pdf_to_int(ctx, o);
    }

    LIST_APPEND_DROP(effect_py, Py_BuildValue("i", effect1));
    LIST_APPEND_DROP(effect_py, Py_BuildValue("s", effect2));
    DICT_SETITEM_DROP(res, dictkey_width, Py_BuildValue("f", width));
    DICT_SETITEM_DROP(res, dictkey_dashes, dash_py);
    DICT_SETITEM_DROP(res, dictkey_style, Py_BuildValue("s", style));
    if (effect1 > -1) PyDict_SetItem(res, dictkey_effect, effect_py);
    Py_CLEAR(effect_py);
    return res;
}

PyObject *JM_annot_set_border(fz_context *ctx, PyObject *border, pdf_document *doc, pdf_obj *annot_obj)
{
    if (!PyDict_Check(border))
    {
        JM_Warning("arg must be a dict");
        Py_RETURN_NONE;     // not a dict
    }

    double nwidth = -1;                       // new width
    double owidth = -1;                       // old width
    PyObject *ndashes = NULL;                 // new dashes
    PyObject *odashes = NULL;                 // old dashes
    PyObject *nstyle  = NULL;                 // new style
    PyObject *ostyle  = NULL;                 // old style

    nwidth = PyFloat_AsDouble(PyDict_GetItem(border, dictkey_width));
    ndashes = PyDict_GetItem(border, dictkey_dashes);
    nstyle  = PyDict_GetItem(border, dictkey_style);

    // first get old border properties
    PyObject *oborder = JM_annot_border(ctx, annot_obj);
    owidth = PyFloat_AsDouble(PyDict_GetItem(oborder, dictkey_width));
    odashes = PyDict_GetItem(oborder, dictkey_dashes);
    ostyle = PyDict_GetItem(oborder, dictkey_style);

    // then delete any relevant entries
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BS));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BE));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(Border));

    Py_ssize_t i, n;
    int d;
    // populate new border array
    if (nwidth < 0) nwidth = owidth;     // no new width: take current
    if (nwidth < 0) nwidth = 0.0f;       // default if no width given
    if (!ndashes) ndashes = odashes;     // no new dashes: take old
    if (!nstyle)  nstyle  = ostyle;      // no new style: take old

    if (ndashes && PySequence_Check(ndashes) && PySequence_Size(ndashes) > 0)
    {
        n = PySequence_Size(ndashes);
        pdf_obj *darr = pdf_new_array(ctx, doc, n);
        for (i = 0; i < n; i++)
        {
            d = (int) PyInt_AsLong(PySequence_ITEM(ndashes, i));
            pdf_array_push_int(ctx, darr, (int64_t) d);
        }
        pdf_dict_putl_drop(ctx, annot_obj, darr, PDF_NAME(BS), PDF_NAME(D), NULL);
        nstyle = PyUnicode_FromString("D");
    }

    pdf_dict_putl_drop(ctx, annot_obj, pdf_new_real(ctx, nwidth),
                               PDF_NAME(BS), PDF_NAME(W), NULL);

    pdf_obj *val = JM_get_border_style(ctx, nstyle);

    pdf_dict_putl_drop(ctx, annot_obj, val,
                               PDF_NAME(BS), PDF_NAME(S), NULL);

    PyErr_Clear();
    Py_RETURN_NONE;
}

PyObject *JM_annot_colors(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *bc = PyList_New(0);        // stroke colors
    PyObject *fc = PyList_New(0);        // fill colors
    int i;
    float col;
    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(C));
    if (pdf_is_array(ctx, o))
    {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++)
        {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            LIST_APPEND_DROP(bc, Py_BuildValue("f", col));
        }
    }
    DICT_SETITEM_DROP(res, dictkey_stroke, bc);

    o = pdf_dict_gets(ctx, annot_obj, "IC");
    if (pdf_is_array(ctx, o))
    {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++)
        {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            LIST_APPEND_DROP(fc, Py_BuildValue("f", col));
        }
    }
    DICT_SETITEM_DROP(res, dictkey_fill, fc);

    return res;
}

//----------------------------------------------------------------------------
// delete an annotation using mupdf functions, but first delete the /AP and
// /Popup dict keys in annot->obj. Also remove the 'Popup' annotation
// from the page's /Annots array which may also exist.
//----------------------------------------------------------------------------
void JM_delete_annot(fz_context *ctx, pdf_page *page, pdf_annot *annot)
{
    if (!annot) return;
    fz_try(ctx)
    {
        // first get any existing popup for the annotation
        pdf_obj *popup = pdf_dict_get(ctx, annot->obj, PDF_NAME(Popup));


        // next delete the /Popup and /AP entries from annot dictionary
        pdf_dict_del(ctx, annot->obj, PDF_NAME(Popup));
        pdf_dict_del(ctx, annot->obj, PDF_NAME(AP));

        // if there exists a /Popup, find and destroy it. The right popup
        // has a /Parent entry which points to our annotation.

        pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
        int i, n = pdf_array_len(ctx, annots);
        for (i = n - 1; i >= 0; i--)
        {
            pdf_obj *o = pdf_array_get(ctx, annots, i);
            pdf_obj *p = pdf_dict_get(ctx, o, PDF_NAME(Parent));
            if (!p)
                continue;
            if (!pdf_objcmp(ctx, p, annot->obj))
            {
                pdf_array_delete(ctx, annots, i);
            }
        }

        pdf_delete_annot(ctx, page, annot);
    }
    fz_catch(ctx)
    {
        fz_warn(ctx, "could not delete annotation");
    }
    return;
}

//----------------------------------------------------------------------------
// Return the first annotation whose /IRT key ("In Response To") points to
// annot. Used to remove the response chain of a given annotation.
//----------------------------------------------------------------------------
pdf_annot *JM_find_annot_irt(fz_context *ctx, pdf_annot *annot)
{
    pdf_annot *irt_annot = NULL;  // returning this
    pdf_obj *o = NULL;
    pdf_annot **annotptr;
    int found = 0;
    fz_try(ctx)
    {   // loop thru MuPDF's internal annots array
        pdf_page *page = annot->page;
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next)
        {
            irt_annot = *annotptr;  // check if this is what we are looking for
            o = pdf_dict_gets(ctx, irt_annot->obj, "IRT");
            if (o)
            {
                if (!pdf_objcmp(ctx, o, annot->obj))
                {
                    found = 1;
                    break;
                }
            }
        }
    }
    fz_catch(ctx) {;}
    if (found)
        return irt_annot;
    return NULL;
}

//----------------------------------------------------------------------------
// return the identifications of a page's annotations (list of /NM entries)
//----------------------------------------------------------------------------
PyObject *JM_get_annot_id_list(fz_context *ctx, pdf_page *page)
{
    PyObject *names = PyList_New(0);
    pdf_obj *o = NULL;
    pdf_annot **annotptr = NULL;
    pdf_annot *annot = NULL;
    fz_try(ctx)
    {   // loop thru MuPDF's internal annots and widget arrays
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next)
        {
            annot = *annotptr;
            o = pdf_dict_gets(ctx, annot->obj, "NM");
            if (o)
            {
                LIST_APPEND_DROP(names, Py_BuildValue("s", pdf_to_text_string(gctx, o)));
            }
        }
        //for (annotptr = &page->widgets; *annotptr; annotptr = &(*annotptr)->next)
        //{
        //    annot = *annotptr;
        //    o = pdf_dict_gets(ctx, annot->obj, "NM");
        //    if (o)
        //    {
        //        LIST_APPEND_DROP(names, Py_BuildValue("s", pdf_to_text_string(gctx, o)));
        //    }
        //}
    }
    fz_catch(ctx)
    {
        return names;
    }
    return names;
}


//----------------------------------------------------------------------------
// add a unique /NM key to an annotation or widget
//----------------------------------------------------------------------------
void JM_add_annot_id(fz_context *ctx, pdf_annot *annot, char *stem)
{
    fz_try(ctx)
    {
        PyObject *names = JM_get_annot_id_list(ctx, annot->page);
        int i = 0;
        PyObject *stem_id = NULL;
        while (1)
        {
            stem_id = PyUnicode_FromFormat("%s-%d", stem, i);
            if (!PySequence_Contains(names, stem_id))
            {
                break;
            }
            i += 1;
            Py_DECREF(stem_id);
        }
        char *response = JM_Python_str_AsChar(stem_id);
        pdf_obj *name = pdf_new_string(ctx, (const char *) response, strlen(response));
        pdf_dict_puts_drop(ctx, annot->obj, "NM", name);
        JM_Python_str_DelForPy3(response);
        Py_DECREF(stem_id);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
}

//----------------------------------------------------------------------------
// retrieve an annotation by its /NM key
//----------------------------------------------------------------------------
pdf_annot *JM_get_annot_by_name(fz_context *ctx, pdf_page *page, char *name)
{
    if (!name || strlen(name) == 0)
    {
        return NULL;
    }
    pdf_annot **annotptr = NULL;
    pdf_annot *annot = NULL;
    int found = 0;
    size_t len = 0;

    fz_try(ctx)
    {   // loop thru MuPDF's internal annots and widget arrays
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next)
        {
            annot = *annotptr;
            const char *response = pdf_to_string(ctx, pdf_dict_gets(ctx, annot->obj, "NM"), &len);
            if (strcmp(name, response) == 0)
            {
                found = 1;
                break;
            }
        }
    }
    fz_catch(ctx)
    {
        return NULL;
    }
    if (found == 1)
    {
        return pdf_keep_annot(ctx, annot);
    }
    else
    {
        return NULL;
    }
}



//-----------------------------------------------------------------------------
// Make a text page directly from an fz_page
//-----------------------------------------------------------------------------
fz_stext_page *JM_new_stext_page_from_page(fz_context *ctx, fz_page *page, int flags)
{
    if (!page) return NULL;
    fz_stext_page *text = NULL;
    fz_device *dev = NULL;
    fz_var(dev);
    fz_var(text);
    fz_stext_options options = { 0 };
    options.flags = flags;
    fz_try(ctx)
    {
        text = fz_new_stext_page(ctx, fz_bound_page(ctx, page));
        dev = fz_new_stext_device(ctx, text, &options);
        fz_run_page_contents(ctx, page, dev, fz_identity, NULL);
        fz_close_device(ctx, dev);
    }
    fz_always(ctx)
    {
        fz_drop_device(ctx, dev);
    }
    fz_catch(ctx)
    {
        fz_drop_stext_page(ctx, text);
        fz_rethrow(ctx);
    }
    return text;
}


//-----------------------------------------------------------------------------
// Replace MuPDF error rune with character 0xB7
//-----------------------------------------------------------------------------
PyObject *JM_repl_char()
{
    const unsigned char data[2] = {194, 183};
    return PyUnicode_FromStringAndSize(data, 2);
}

//-----------------------------------------------------------------------------
// append non-ascii runes in unicode escape format
//-----------------------------------------------------------------------------
void JM_append_rune(fz_context *ctx, fz_buffer *buff, int ch)
{
    if (ch >= 32 && ch <= 127)
    {
        fz_append_byte(ctx, buff, ch);
    }
    else if (ch <= 0xffff)  // 4 hex digits
    {
        fz_append_printf(ctx, buff, "\\u%04x", ch);
    }
    else  // 8 hex digits
    {
        fz_append_printf(ctx, buff, "\\U%08x", ch);
    }
}


//-----------------------------------------------------------------------------
// write non-ascii runes in unicode escape format
//-----------------------------------------------------------------------------
void JM_write_rune(fz_context *ctx, fz_output *out, int ch)
{
    if (ch >= 32 && ch <= 127)
    {
        fz_write_byte(ctx, out, ch);
    }
    else if (ch <= 0xffff)  // 4 hex digits
    {
        fz_write_printf(ctx, out, "\\u%04x", ch);
    }
    else  // 8 hex digits
    {
        fz_write_printf(ctx, out, "\\U%08x", ch);
    }
}


//-----------------------------------------------------------------------------
// Plain text output. An identical copy of fz_print_stext_page_as_text,
// but lines within a block are concatenated by space instead a new-line
// character (which else leads to 2 new-lines).
//-----------------------------------------------------------------------------
void
JM_print_stext_page_as_text(fz_context *ctx, fz_output *out, fz_stext_page *page)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;
    int last_char;

    for (block = page->first_block; block; block = block->next)
    {
        if (block->type == FZ_STEXT_BLOCK_TEXT)
        {
            int line_n = 0;
            for (line = block->u.t.first_line; line; line = line->next)
            {
                if (line_n > 0 && last_char != 10)
                {
                    fz_write_string(ctx, out, "\n");
                }
                line_n++;
                for (ch = line->first_char; ch; ch = ch->next)
                {
                    JM_write_rune(ctx, out, ch->c);
                    last_char = ch->c;
                }
            }
            fz_write_string(ctx, out, "\n");
        }
    }
}

//-----------------------------------------------------------------------------
// Functions for wordlist output
//-----------------------------------------------------------------------------
int JM_append_word(fz_context *ctx, PyObject *lines, fz_buffer *buff, fz_rect *wbbox,
                   int block_n, int line_n, int word_n)
{
    PyObject *s = JM_EscapeStrFromBuffer(ctx, buff);
    PyObject *litem = Py_BuildValue("ffffOiii",
                                    wbbox->x0,
                                    wbbox->y0,
                                    wbbox->x1,
                                    wbbox->y1,
                                    s,
                                    block_n, line_n, word_n);
    LIST_APPEND_DROP(lines, litem);
    Py_DECREF(s);
    wbbox->x0 = wbbox->y0 = wbbox->x1 = wbbox->y1 = 0;
    return word_n + 1;                 // word counter
}

//-----------------------------------------------------------------------------
// Functions for dictionary output
//-----------------------------------------------------------------------------

// create the char rect from its quad
fz_rect JM_char_bbox(fz_stext_line *line, fz_stext_char *ch)
{
    fz_rect r = fz_rect_from_quad(ch->quad);
    if (!fz_is_empty_rect(r)) return r;
    // we need to correct erroneous font!
    if ((r.y1 - r.y0) <= FLT_EPSILON) r.y0 = r.y1 - ch->size;
    if ((r.x1 - r.x0) <= FLT_EPSILON) r.x0 = r.x1 - ch->size;
    return r;
}

static int detect_super_script(fz_stext_line *line, fz_stext_char *ch)
{
    if (line->wmode == 0 && line->dir.x == 1 && line->dir.y == 0)
        return ch->origin.y < line->first_char->origin.y - ch->size * 0.1f;
    return 0;
}

static int JM_char_font_flags(fz_context *ctx, fz_font *font, fz_stext_line *line, fz_stext_char *ch)
{
    int flags = detect_super_script(line, ch);
    flags += fz_font_is_italic(ctx, font) * TEXT_FONT_ITALIC;
    flags += fz_font_is_serif(ctx, font) * TEXT_FONT_SERIFED;
    flags += fz_font_is_monospaced(ctx, font) * TEXT_FONT_MONOSPACED;
    flags += fz_font_is_bold(ctx, font) * TEXT_FONT_BOLD;
    return flags;
}


static PyObject *JM_make_spanlist(fz_context *ctx, fz_stext_line *line, int raw, fz_buffer *buff)
{
    PyObject *span = NULL, *char_list = NULL, *char_dict;
    PyObject *span_list = PyList_New(0);
    fz_clear_buffer(ctx, buff);
    fz_stext_char *ch;
    fz_rect span_rect;
    typedef struct style_s
    {float size; int flags; char *font; int color;} char_style;

    char_style old_style = { -1, -1, "", -1 }, style;

    for (ch = line->first_char; ch; ch = ch->next)
    {
        fz_rect r = JM_char_bbox(line, ch);
        int flags = JM_char_font_flags(ctx, ch->font, line, ch);
        style.size = ch->size;
        style.flags = flags;
        style.font = (char *) fz_font_name(ctx, ch->font);
        style.color = ch->color;

        if (style.size != old_style.size ||
            style.flags != old_style.flags ||
            style.color != old_style.color ||
            strcmp(style.font, old_style.font) != 0)  // changed -> new span
        {
            if (old_style.size >= 0)  // not 1st one, output previous span
            {
                if (raw)  // put character list in the span
                {
                    DICT_SETITEM_DROP(span, dictkey_chars, char_list);
                    char_list = NULL;
                }
                else  // put text string in the span
                {
                    DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
                    fz_clear_buffer(ctx, buff);
                }

                DICT_SETITEM_DROP(span, dictkey_bbox, JM_py_from_rect(span_rect));

                LIST_APPEND_DROP(span_list, span);
                span = NULL;
            }

            span = PyDict_New();

            DICT_SETITEM_DROP(span, dictkey_size, Py_BuildValue("f", style.size));
            DICT_SETITEM_DROP(span, dictkey_flags, Py_BuildValue("i", style.flags));
            DICT_SETITEM_DROP(span, dictkey_font, JM_EscapeStrFromStr(style.font));
            DICT_SETITEM_DROP(span, dictkey_color, Py_BuildValue("i", style.color));

            old_style = style;
            span_rect = r;
        }
        span_rect = fz_union_rect(span_rect, r);
        if (raw)  // make and append a char dict
        {
            char_dict = PyDict_New();

            DICT_SETITEM_DROP(char_dict, dictkey_origin,
                          Py_BuildValue("ff", ch->origin.x, ch->origin.y));

            DICT_SETITEM_DROP(char_dict, dictkey_bbox,
                          Py_BuildValue("ffff", r.x0, r.y0, r.x1, r.y1));

            DICT_SETITEM_DROP(char_dict, dictkey_c,
                          PyUnicode_FromFormat("%c", ch->c));

            if (!char_list)
            {
                char_list = PyList_New(0);
            }
            LIST_APPEND_DROP(char_list, char_dict);
        }
        else  // add character byte to buffer
        {
            JM_append_rune(ctx, buff, ch->c);
        }
    }
    // all characters processed, now flush remaining span
    if (span)
    {
        if (raw)
        {
            DICT_SETITEM_DROP(span, dictkey_chars, char_list);
            char_list = NULL;
        }
        else
        {
            DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
            fz_clear_buffer(ctx, buff);
        }
        DICT_SETITEM_DROP(span, dictkey_bbox, JM_py_from_rect(span_rect));

        LIST_APPEND_DROP(span_list, span);
        span = NULL;
    }
    return span_list;
}

static void JM_make_image_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict)
{
    fz_image *image = block->u.i.image;
    fz_buffer *buf = NULL, *freebuf = NULL;
    fz_compressed_buffer *buffer = fz_compressed_image_buffer(ctx, image);
    fz_var(buf);
    fz_var(freebuf);
    int n = fz_colorspace_n(ctx, image->colorspace);
    int w = image->w;
    int h = image->h;
    const char *ext = NULL;
    int type = FZ_IMAGE_UNKNOWN;
    if (buffer)
        type = buffer->params.type;
    if (type < FZ_IMAGE_BMP || type == FZ_IMAGE_JBIG2)
        type = FZ_IMAGE_UNKNOWN;
    PyObject *bytes = NULL;
    fz_var(bytes);
    fz_try(ctx)
    {
        if (buffer && type != FZ_IMAGE_UNKNOWN)
        {
            buf = buffer->buffer;
            ext = JM_image_extension(type);
        }
        else
        {
            buf = freebuf = fz_new_buffer_from_image_as_png(ctx, image, fz_default_color_params);
            ext = "png";
        }
        if (PY_MAJOR_VERSION > 2)
        {
            bytes = JM_BinFromBuffer(ctx, buf);
        }
        else
        {
            bytes = JM_BArrayFromBuffer(ctx, buf);
        }
    }
    fz_always(ctx)
    {
        if (!bytes)
            bytes = JM_BinFromChar("");
        DICT_SETITEM_DROP(block_dict, dictkey_width,
                          Py_BuildValue("i", w));
        DICT_SETITEM_DROP(block_dict, dictkey_height,
                          Py_BuildValue("i", h));
        DICT_SETITEM_DROP(block_dict, dictkey_ext,
                          Py_BuildValue("s", ext));
        DICT_SETITEM_DROP(block_dict, dictkey_colorspace,
                          Py_BuildValue("i", n));
        DICT_SETITEM_DROP(block_dict, dictkey_xres,
                          Py_BuildValue("i", image->xres));
        DICT_SETITEM_DROP(block_dict, dictkey_yres,
                          Py_BuildValue("i", image->xres));
        DICT_SETITEM_DROP(block_dict, dictkey_bpc,
                          Py_BuildValue("i", (int) image->bpc));
        DICT_SETITEM_DROP(block_dict, dictkey_image, bytes);

        fz_drop_buffer(ctx, freebuf);
    }
    fz_catch(ctx) {;}
    return;
}

static void JM_make_text_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict, int raw, fz_buffer *buff)
{
    fz_stext_line *line;
    PyObject *line_list = PyList_New(0), *line_dict;

    for (line = block->u.t.first_line; line; line = line->next)
    {
        line_dict = PyDict_New();

        DICT_SETITEM_DROP(line_dict, dictkey_wmode,
                      Py_BuildValue("i", line->wmode));
        DICT_SETITEM_DROP(line_dict, dictkey_dir,
                      Py_BuildValue("ff", line->dir.x, line->dir.y));
        DICT_SETITEM_DROP(line_dict, dictkey_bbox,
                      JM_py_from_rect(line->bbox));
        DICT_SETITEM_DROP(line_dict, dictkey_spans,
                       JM_make_spanlist(ctx, line, raw, buff));

        LIST_APPEND_DROP(line_list, line_dict);
    }
    DICT_SETITEM_DROP(block_dict, dictkey_lines, line_list);
    return;
}

void JM_make_textpage_dict(fz_context *ctx, fz_stext_page *tp, PyObject *page_dict, int raw)
{
    fz_stext_block *block;
    fz_buffer *text_buffer = fz_new_buffer(ctx, 64);
    PyObject *block_dict, *block_list = PyList_New(0);
    for (block = tp->first_block; block; block = block->next)
    {
        block_dict = PyDict_New();

        DICT_SETITEM_DROP(block_dict, dictkey_type, Py_BuildValue("i", block->type));
        DICT_SETITEM_DROP(block_dict, dictkey_bbox, JM_py_from_rect(block->bbox));

        if (block->type == FZ_STEXT_BLOCK_IMAGE)
        {
            JM_make_image_block(ctx, block, block_dict);
        }
        else
        {
            JM_make_text_block(ctx, block, block_dict, raw, text_buffer);
        }

        LIST_APPEND_DROP(block_list, block_dict);
    }
    DICT_SETITEM_DROP(page_dict, dictkey_blocks, block_list);
    fz_drop_buffer(ctx, text_buffer);
}

PyObject *JM_object_to_string(fz_context *ctx, pdf_obj *what, int compress, int ascii)
{
    fz_buffer *res=NULL;
    fz_output *out=NULL;
    PyObject *text=NULL;
    fz_try(ctx)
    {
        res = fz_new_buffer(ctx, 1024);
        out = fz_new_output_with_buffer(ctx, res);
        pdf_print_obj(ctx, out, what, compress, ascii);
        text = JM_EscapeStrFromBuffer(ctx, res);
    }
    fz_always(ctx)
    {
        fz_drop_output(ctx, out);
        fz_drop_buffer(ctx, res);
    }
    fz_catch(ctx)
    {
        text = PyUnicode_FromString("");
        return text;
    }
    return text;
}

PyObject *JM_merge_resources(fz_context *ctx, pdf_page *page, pdf_obj *temp_res)
{
    pdf_obj *resources = pdf_dict_get(ctx, page->obj, PDF_NAME(Resources));
    pdf_obj *main_extg = pdf_dict_get(ctx, resources, PDF_NAME(ExtGState));
    pdf_obj *main_fonts = pdf_dict_get(ctx, resources, PDF_NAME(Font));
    pdf_obj *temp_extg = pdf_dict_get(ctx, temp_res, PDF_NAME(ExtGState));
    pdf_obj *temp_fonts = pdf_dict_get(ctx, temp_res, PDF_NAME(Font));
    int max_alp = 0, max_fonts = 0, i, n;
//start-trace
    char start_alp[32] = {0};
    char text[32] = {0};
    // copy over renumbered temp alpha values
    if (pdf_is_dict(ctx, temp_extg))
    {
        n = pdf_dict_len(ctx, temp_extg);
        if (pdf_is_dict(ctx, main_extg))
        {
            for (i = 0; i < pdf_dict_len(ctx, main_extg); i++)
            {
                char *alp = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_extg, i));
                if (strncmp(alp, "Alp", 3) != 0) continue;
                if (strcmp(start_alp, alp) < 0) strcpy(start_alp, alp);
            }
            i = 0;
            while (strcmp(text, start_alp) < 0)
            {
                fz_snprintf(text, sizeof(text), "Alp%d", i);
                i++;
            }
            max_alp = i;
        }
        else
            main_extg = pdf_dict_put_dict(ctx, resources, PDF_NAME(ExtGState), n);

        for (i = 0; i < n; i++)
        {
            fz_snprintf(text, sizeof(text), "Alp%d", i + max_alp);
            pdf_obj *val = pdf_dict_get_val(ctx, temp_extg, i);
            pdf_dict_puts(ctx, main_extg, text, val);
        }
    }
    text[0] = 0;
    start_alp[0] = 0;
    
    if (pdf_is_dict(ctx, main_fonts))
    {
        for (i = 0; i < pdf_dict_len(ctx, main_fonts); i++)
        {
            char *font = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_fonts, i));
            if (strncmp(font, "F", 1) != 0) continue;
            if (strcmp(start_alp, font) < 0) strcpy(start_alp, font);
        }
        i = 0;
        while (strcmp(text, start_alp) < 0)
        {
            fz_snprintf(text, sizeof(text), "F%d", i);
            i++;
        }
        max_fonts = i;
    }
    else
    {
        main_fonts = pdf_dict_put_dict(ctx, resources, PDF_NAME(Font), 2);
    }
    for (i = 0; i < pdf_dict_len(ctx, temp_fonts); i++)
    {
        fz_snprintf(text, sizeof(text), "F%d", i + max_fonts);
        pdf_obj *val = pdf_dict_get_val(ctx, temp_fonts, i);
        pdf_dict_puts_drop(ctx, main_fonts, text, val);
    }
//end-trace
    return Py_BuildValue("ii", max_alp, max_fonts);
}


#define SETATTR(a, v) PyObject_SetAttrString(Widget, a, v)
#define SETATTR_DROP(a, v, t) t=v; PyObject_SetAttrString(Widget, a, v);Py_DECREF(t)
#define GETATTR(a) PyObject_GetAttrString(Widget, a)
#define CALLATTR(m, p) PyObject_CallMethod(Widget, m, p)
//-----------------------------------------------------------------------------
// Functions dealing with PDF form fields (widgets)
//-----------------------------------------------------------------------------
enum
{
	SigFlag_SignaturesExist = 1,
	SigFlag_AppendOnly = 2
};


// make new PDF action object from JavaScript source
// Parameters are a PDF document and a Python string.
// Returns a PDF action object.
//-----------------------------------------------------------------------------
pdf_obj *JM_new_javascript(fz_context *ctx, pdf_document *pdf, PyObject *value)
{
    fz_buffer *res = NULL;
    if (!PyObject_IsTrue(value))
    {
        return NULL;
    }
    char *data = JM_Python_str_AsChar(value);
    if (!data)
    {
        return NULL;
    }
    res = fz_new_buffer_from_copied_data(ctx, data, strlen(data));
    pdf_obj *source = pdf_add_stream(ctx, pdf, res, NULL, 0);
    pdf_obj *newaction = pdf_add_new_dict(ctx, pdf, 4);
    pdf_dict_put(ctx, newaction, PDF_NAME(S), pdf_new_name(ctx, "JavaScript"));
    pdf_dict_put(ctx, newaction, PDF_NAME(JS), source);
    JM_Python_str_DelForPy3(data);
    fz_drop_buffer(ctx, res);
    return pdf_keep_obj(ctx, newaction);
}


// JavaScript extractor
// Returns either the script source or None. Parameter is a PDF action
// dictionary, which must have keys /S and /JS. The value of /S must be
// '/JavaScript'. The value of /JS is returned.
//-----------------------------------------------------------------------------
PyObject *JM_get_script(fz_context *ctx, pdf_obj *key)
{
    pdf_obj *js = NULL;
    fz_buffer *res = NULL;
    PyObject *script = NULL;
    if (!key)
    {
        Py_RETURN_NONE;
    }
    if (!strcmp(pdf_to_name(ctx,
                pdf_dict_get(ctx, key, PDF_NAME(S))), "JavaScript"))
    {
        js = pdf_dict_get(ctx, key, PDF_NAME(JS));
    }
    if (!js)
    {
        Py_RETURN_NONE;
    }

    if (pdf_is_string(ctx, js))
    {
        script = JM_UnicodeFromStr(pdf_to_text_string(ctx, js));
    }
    else if (pdf_is_stream(ctx, js))
    {
        res = pdf_load_stream(ctx, js);
        script = JM_EscapeStrFromBuffer(ctx, res);
        fz_drop_buffer(ctx, res);
    }
    else
    {
        Py_RETURN_NONE;
    }
    if (PyObject_IsTrue(script))  // do not return an empty script
    {
        return script;
    }
    Py_CLEAR(script);
    Py_RETURN_NONE;
}


// Create a JavaScript PDF action.
// Usable for all object types which support PDF actions, even if the
// argument name suggests annotations. Up to 2 key values can be specified, so
// JavaScript actions can be stored for '/A' and '/AA/?' keys.
//-----------------------------------------------------------------------------
void JM_put_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2, PyObject *value)
{
    PyObject *script = NULL;
    pdf_obj *key1_obj = pdf_dict_get(ctx, annot_obj, key1);
    pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);  // owning PDF

    // if no new script given, just delete corresponding key
    if (!value || !PyObject_IsTrue(value))
    {
        if (!key2)
        {
            pdf_dict_del(ctx, annot_obj, key1);
        }
        else if (key1_obj)
        {
            pdf_dict_del(ctx, key1_obj, key2);
        }
        return;
    }

    // read any existing script as a PyUnicode string
    if (!key2 || !key1_obj)
    {
        script = JM_get_script(ctx, key1_obj);
    }
    else
    {
        script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
    }

    // replace old script, if different from new one
    if (!PyObject_RichCompareBool(value, script, Py_EQ))
    {
        pdf_obj *newaction = JM_new_javascript(ctx, pdf, value);
        if (!key2)
        {
            pdf_dict_put_drop(ctx, annot_obj, key1, newaction);
        }
        else
        {
            pdf_dict_putl_drop(ctx, annot_obj, newaction, key1, key2, NULL);
        }
    }
    Py_XDECREF(script);
    return;
}

/*
// Execute a JavaScript action for a annot or field.
//-----------------------------------------------------------------------------
PyObject *JM_exec_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2)
{
    PyObject *script = NULL;
    char *code = NULL;
    fz_try(ctx)
    {
        pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);
        char buf[100];
        if (!key2)
        {
            script = JM_get_script(ctx, key1_obj);
        }
        else
        {
            script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
        }
        code = JM_Python_str_AsChar(script);
        fz_snprintf(buf, sizeof buf, "%d/A", pdf_to_num(ctx, annot_obj));
        pdf_js_execute(pdf->js, buf, code);
    }
    fz_always(ctx)
    {
        JM_Python_str_DelForPy3(code);
        Py_XDECREF(string);
    }
    fz_catch(ctx)
    {
        Py_RETURN_FALSE;
    }
    Py_RETURN_TRUE;
}
*/

// String from widget type
//-----------------------------------------------------------------------------
char *JM_field_type_text(int wtype)
{
    switch(wtype)
    {
        case(PDF_WIDGET_TYPE_BUTTON):
            return "Button";
        case(PDF_WIDGET_TYPE_CHECKBOX):
            return "CheckBox";
        case(PDF_WIDGET_TYPE_RADIOBUTTON):
            return "RadioButton";
        case(PDF_WIDGET_TYPE_TEXT):
            return "Text";
        case(PDF_WIDGET_TYPE_LISTBOX):
            return "ListBox";
        case(PDF_WIDGET_TYPE_COMBOBOX):
            return "ComboBox";
        case(PDF_WIDGET_TYPE_SIGNATURE):
            return "Signature";
        default:
            return "unknown";
    }
}

// Set the field type
//-----------------------------------------------------------------------------
void JM_set_field_type(fz_context *ctx, pdf_document *doc, pdf_obj *obj, int type)
{
	int setbits = 0;
	int clearbits = 0;
	pdf_obj *typename = NULL;

	switch(type)
	{
	case PDF_WIDGET_TYPE_BUTTON:
		typename = PDF_NAME(Btn);
		setbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
		break;
	case PDF_WIDGET_TYPE_CHECKBOX:
		typename = PDF_NAME(Btn);
		clearbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
		setbits = PDF_BTN_FIELD_IS_RADIO;
		break;
	case PDF_WIDGET_TYPE_RADIOBUTTON:
		typename = PDF_NAME(Btn);
		clearbits = (PDF_BTN_FIELD_IS_PUSHBUTTON|PDF_BTN_FIELD_IS_RADIO);
		break;
	case PDF_WIDGET_TYPE_TEXT:
		typename = PDF_NAME(Tx);
		break;
	case PDF_WIDGET_TYPE_LISTBOX:
		typename = PDF_NAME(Ch);
		clearbits = PDF_CH_FIELD_IS_COMBO;
		break;
	case PDF_WIDGET_TYPE_COMBOBOX:
		typename = PDF_NAME(Ch);
		setbits = PDF_CH_FIELD_IS_COMBO;
		break;
	case PDF_WIDGET_TYPE_SIGNATURE:
		typename = PDF_NAME(Sig);
		break;
	}

	if (typename)
		pdf_dict_put_drop(ctx, obj, PDF_NAME(FT), typename);

	if (setbits != 0 || clearbits != 0)
	{
		int bits = pdf_dict_get_int(ctx, obj, PDF_NAME(Ff));
		bits &= ~clearbits;
		bits |= setbits;
		pdf_dict_put_int(ctx, obj, PDF_NAME(Ff), bits);
	}
}

// Copied from MuPDF v1.14
// Create widget
//-----------------------------------------------------------------------------
pdf_widget *JM_create_widget(fz_context *ctx, pdf_document *doc, pdf_page *page, int type, char *fieldname)
{
	pdf_obj *form = NULL;
	int old_sigflags = pdf_to_int(ctx, pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/SigFlags"));
	pdf_annot *annot = pdf_create_annot_raw(ctx, page, PDF_ANNOT_WIDGET);

	fz_try(ctx)
	{
		JM_set_field_type(ctx, doc, annot->obj, type);
		pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(T), fieldname);

		if (type == PDF_WIDGET_TYPE_SIGNATURE)
		{
			int sigflags = (old_sigflags | (SigFlag_SignaturesExist|SigFlag_AppendOnly));
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, sigflags), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);
		}

		/*
		pdf_create_annot will have linked the new widget into the page's
		annot array. We also need it linked into the document's form
		*/
		form = pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/Fields");
		if (!form)
		{
			form = pdf_new_array(ctx, doc, 1);
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc),
                               form,
                               PDF_NAME(Root),
                               PDF_NAME(AcroForm),
                               PDF_NAME(Fields),
                               NULL);
		}

		pdf_array_push(ctx, form, annot->obj); /* Cleanup relies on this statement being last */
	}
	fz_catch(ctx)
	{
		pdf_delete_annot(ctx, page, annot);

		/* An empty Fields array may have been created, but that is harmless */

		if (type == PDF_WIDGET_TYPE_SIGNATURE)
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, old_sigflags), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);

		fz_rethrow(ctx);
	}

	return (pdf_widget *)annot;
}


// PushButton get state
//-----------------------------------------------------------------------------
PyObject *JM_pushbtn_state(fz_context *ctx, pdf_annot *annot)
{   // pushed buttons do not reflect status changes in the PDF
    // always reflect them as untouched
    Py_RETURN_FALSE;
}

// CheckBox get state
//-----------------------------------------------------------------------------
PyObject *JM_checkbox_state(fz_context *ctx, pdf_annot *annot)
{
    pdf_obj *leafv = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(V));
    pdf_obj *leafas = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(AS));
    if (!leafv) Py_RETURN_FALSE;
    if (leafv == PDF_NAME(Off)) Py_RETURN_FALSE;
    if (leafv == pdf_new_name(ctx, "Yes"))
        Py_RETURN_TRUE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Off"))
        Py_RETURN_FALSE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Yes"))
        Py_RETURN_TRUE;
    if (leafas && leafas == PDF_NAME(Off)) Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

// RadioBox get state
//-----------------------------------------------------------------------------
PyObject *JM_radiobtn_state(fz_context *ctx, pdf_annot *annot)
{   // MuPDF treats radio buttons like check boxes - hence so do we
    return JM_checkbox_state(ctx, annot);
}

// Text field retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_text_value(fz_context *ctx, pdf_annot *annot)
{
    const char *text = NULL;
    fz_var(text);
    fz_try(ctx)
        text = pdf_field_value(ctx, annot->obj);
    fz_catch(ctx) Py_RETURN_NONE;
    return JM_UnicodeFromStr(text);
}

// ListBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_listbox_value(fz_context *ctx, pdf_annot *annot)
{
    int i = 0, n = 0;
    // may be single value or array
    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(V));
    if (pdf_is_string(ctx, optarr))         // a single string
        return PyString_FromString(pdf_to_text_string(ctx, optarr));

    // value is an array (may have len 0)
    n = pdf_array_len(ctx, optarr);
    PyObject *liste = PyList_New(0);

    // extract a list of strings
    // each entry may again be an array: take second entry then
    for (i = 0; i < n; i++)
    {
        pdf_obj *elem = pdf_array_get(ctx, optarr, i);
        if (pdf_is_array(ctx, elem))
            elem = pdf_array_get(ctx, elem, 1);
        LIST_APPEND_DROP(liste, JM_UnicodeFromStr(pdf_to_text_string(ctx, elem)));
    }
    return liste;
}

// ComboBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_combobox_value(fz_context *ctx, pdf_annot *annot)
{   // combobox values are treated like listbox values
    return JM_listbox_value(ctx, annot);
}

// Signature field retrieve value
PyObject *JM_signature_value(fz_context *ctx, pdf_annot *annot)
{   // signatures are currently not supported
    Py_RETURN_NONE;
}

// retrieve ListBox / ComboBox choice values
//-----------------------------------------------------------------------------
PyObject *JM_choice_options(fz_context *ctx, pdf_annot *annot)
{   // return list of choices for list or combo boxes
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    PyObject *val;
    int n = pdf_choice_widget_options(ctx, pdf, (pdf_widget *) annot, 0, NULL);
    if (n == 0) Py_RETURN_NONE;                     // wrong widget type

    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(Opt));
    int i, m;
    PyObject *liste = PyList_New(0);

    for (i = 0; i < n; i++)
    {
        m = pdf_array_len(ctx, pdf_array_get(ctx, optarr, i));
        if (m == 2)
        {
            val = Py_BuildValue("ss",
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 0)),
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 1)));
            LIST_APPEND_DROP(liste, val);
        }
        else
        {
            val = JM_UnicodeFromStr(pdf_to_text_string(ctx, pdf_array_get(ctx, optarr, i)));
            LIST_APPEND_DROP(liste, val);
        }
    }
    return liste;
}

// set ListBox / ComboBox values
//-----------------------------------------------------------------------------
void JM_set_choice_options(fz_context *ctx, pdf_annot *annot, PyObject *liste)
{
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    Py_ssize_t i, n = PySequence_Size(liste);
    char *opt = NULL;
    pdf_obj *optarr = pdf_new_array(ctx, pdf, n);
    for (i = 0; i < n; i++)
    {
        opt = JM_Python_str_AsChar(PySequence_ITEM(liste, i));
        pdf_array_push_text_string(ctx, optarr, (const char *) opt);
        JM_Python_str_DelForPy3(opt);
    }

    pdf_dict_put(ctx, annot->obj, PDF_NAME(Opt), optarr);

    return;
}

//-----------------------------------------------------------------------------
// Populate a Python Widget object with the values from a PDF form field.
// Called by "Page.firstWidget" and "Widget.next".
//-----------------------------------------------------------------------------
void JM_get_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
{
    pdf_document *pdf = annot->page->doc;
    pdf_widget *tw = (pdf_widget *) annot;
    pdf_obj *obj = NULL, *js = NULL, *o = NULL;
    fz_buffer *res = NULL;
    Py_ssize_t i = 0, n = 0;
    PyObject *val;
    fz_try(ctx)
    {
//start-trace
        int field_type = pdf_widget_type(gctx, tw);
        SETATTR_DROP("field_type", Py_BuildValue("i", field_type), val);
        if (field_type == PDF_WIDGET_TYPE_SIGNATURE)
        {
            if (pdf_signature_is_signed(ctx, pdf, annot->obj))
            {
                SETATTR("is_signed", Py_True);
            }
            else
            {
                SETATTR("is_signed", Py_False);
            }
        }
        else
        {
            SETATTR("is_signed", Py_None);
        }
        SETATTR_DROP("border_style",
                JM_UnicodeFromStr(pdf_field_border_style(ctx, annot->obj)), val);
        SETATTR_DROP("field_type_string",
                JM_UnicodeFromStr(JM_field_type_text(field_type)), val);

        char *field_name = pdf_field_name(ctx, annot->obj);
        SETATTR_DROP("field_name", JM_UnicodeFromStr(field_name), val);
        JM_Free(field_name);

        const char *label = NULL;
        obj = pdf_dict_get(ctx, annot->obj, PDF_NAME(TU));
        if (obj) label = pdf_to_text_string(ctx, obj);
        SETATTR_DROP("field_label", JM_UnicodeFromStr(label), val);

        SETATTR_DROP("field_value",
                JM_UnicodeFromStr(pdf_field_value(ctx, annot->obj)), val);

        SETATTR_DROP("field_display",
                Py_BuildValue("i", pdf_field_display(ctx, annot->obj)), val);

        float border_width = pdf_to_real(ctx, pdf_dict_getl(ctx, annot->obj,
                                PDF_NAME(BS), PDF_NAME(W), NULL));
        if (border_width == 0.0f) border_width = 1.0f;
        SETATTR_DROP("border_width",
                Py_BuildValue("f", border_width), val);

        obj = pdf_dict_getl(ctx, annot->obj,
                                PDF_NAME(BS), PDF_NAME(D), NULL);
        if (pdf_is_array(ctx, obj))
        {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *d = PyList_New(n);
            for (i = 0; i < n; i++)
            {
                PyList_SET_ITEM(d, i, Py_BuildValue("i", pdf_to_int(ctx,
                                pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR("border_dashes", d);
            Py_DECREF(d);
        }

        SETATTR_DROP("text_maxlen",
                Py_BuildValue("i", pdf_text_widget_max_len(ctx, pdf, tw)), val);

        SETATTR_DROP("text_format",
                Py_BuildValue("i", pdf_text_widget_format(ctx, pdf, tw)), val);

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BG), NULL);
        if (pdf_is_array(ctx, obj))
        {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *col = PyList_New(n);
            for (i = 0; i < n; i++)
            {
                PyList_SET_ITEM(col, i, Py_BuildValue("f",
                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR("fill_color", col);
            Py_DECREF(col);
        }

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BC), NULL);
        if (pdf_is_array(ctx, obj))
        {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *col = PyList_New(n);
            for (i = 0; i < n; i++)
            {
                PyList_SET_ITEM(col, i, Py_BuildValue("f",
                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR("border_color", col);
            Py_DECREF(col);
        }

        SETATTR_DROP("choice_values", JM_choice_options(ctx, annot), val);

        const char *da = pdf_to_text_string(ctx, pdf_dict_get_inheritable(ctx,
                                        annot->obj, PDF_NAME(DA)));
        SETATTR_DROP("_text_da", JM_UnicodeFromStr(da), val);

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(CA), NULL);
        if (obj)
        {
            SETATTR_DROP("button_caption",
                    JM_UnicodeFromStr((char *)pdf_to_text_string(ctx, obj)), val);
        }

        SETATTR_DROP("field_flags",
                Py_BuildValue("i", pdf_field_flags(ctx, annot->obj)), val);

        // call Py method to reconstruct text color, font name, size
        PyObject *call = CALLATTR("_parse_da", NULL);
        Py_XDECREF(call);

        // extract JavaScript action texts
        SETATTR_DROP(
            "script",
            JM_get_script(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME(A))),
            val);

        SETATTR_DROP(
            "script_stroke",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), NULL)),
            val);

        SETATTR_DROP(
            "script_format",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), NULL)),
            val);

        SETATTR_DROP(
            "script_change",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), NULL)),
            val);

        SETATTR_DROP(
            "script_calc",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), NULL)),
            val);
//end-trace
    }
    fz_always(ctx) PyErr_Clear();
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}


//-----------------------------------------------------------------------------
// Update a PDF form field with the properties from a Python Widget object.
// Called by "Page.addWidget" and "Annot.updateWidget".
//-----------------------------------------------------------------------------
void JM_set_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
{
    pdf_document *pdf = annot->page->doc;
    pdf_page *page = annot->page;
    fz_rect rect;
    pdf_obj *fill_col = NULL, *border_col = NULL;
    pdf_obj *dashes = NULL;
    Py_ssize_t i, n = 0;
    int d;
    int field_type = (int) PyInt_AsLong(GETATTR("field_type"));
    PyObject *value = NULL;

    // rectangle --------------------------------------------------------------
    value = GETATTR("rect");
    rect = JM_rect_from_py(value);
    Py_CLEAR(value);
    pdf_set_annot_rect(ctx, annot, rect);    // set the rect

    // fill color -------------------------------------------------------------
    value = GETATTR("fill_color");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        fill_col = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
        {
            pdf_array_push_real(ctx, fill_col,
                                PyFloat_AsDouble(PySequence_ITEM(value, i)));
        }
        pdf_field_set_fill_color(ctx, annot->obj, fill_col);
        pdf_drop_obj(ctx, fill_col);
    }
    Py_CLEAR(value);

    // dashes -----------------------------------------------------------------
    value = GETATTR("border_dashes");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        dashes = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
        {
            pdf_array_push_int(ctx, dashes,
                                    PyInt_AsLong(PySequence_ITEM(value, i)));
        }
        pdf_dict_putl_drop(ctx, annot->obj, dashes,
                                PDF_NAME(BS),
                                PDF_NAME(D),
                                NULL);
    }
    Py_CLEAR(value);

    // border color -----------------------------------------------------------
    value = GETATTR("border_color");
    if (value && PySequence_Check(value))
    {
        n = PySequence_Size(value);
        border_col = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++)
        {
            pdf_array_push_real(ctx, border_col,
                                PyFloat_AsDouble(PySequence_ITEM(value, i)));
        }
        pdf_dict_putl_drop(ctx, annot->obj, border_col,
                                PDF_NAME(MK),
                                PDF_NAME(BC),
                                NULL);
    }
    Py_CLEAR(value);

    // entry ignored - may be used later
    /*
    int text_format = (int) PyInt_AsLong(GETATTR("text_format"));
    */

    // field label -----------------------------------------------------------
    value = GETATTR("field_label");
    if (value != Py_None)
    {
        char *label = JM_Python_str_AsChar(value);
        pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(TU), label);
        JM_Python_str_DelForPy3(label);
    }
    Py_CLEAR(value);

    // max text len -----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_TEXT)
    {
        int text_maxlen = (int) PyInt_AsLong(GETATTR("text_maxlen"));
        if (text_maxlen)
            pdf_dict_put_int(ctx, annot->obj, PDF_NAME(MaxLen), text_maxlen);
    }
    d = (int) PyInt_AsLong(GETATTR("field_display"));
    pdf_field_set_display(ctx, annot->obj, d);

    // choice values ----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_LISTBOX ||
        field_type == PDF_WIDGET_TYPE_COMBOBOX)
    {
        value = GETATTR("choice_values");
        JM_set_choice_options(ctx, annot, value);
        Py_CLEAR(value);
    }

    // border style -----------------------------------------------------------
    pdf_obj *val = JM_get_border_style(ctx,
                                GETATTR("border_style"));
    pdf_dict_putl_drop(ctx, annot->obj, val,
                            PDF_NAME(BS),
                            PDF_NAME(S),
                            NULL);

    // border width -----------------------------------------------------------
    float border_width = (float) PyFloat_AsDouble(GETATTR("border_width"));
    pdf_dict_putl_drop(ctx, annot->obj, pdf_new_real(ctx, border_width),
                            PDF_NAME(BS),
                            PDF_NAME(W),
                            NULL);

    // /DA string -------------------------------------------------------------
    char *da = JM_Python_str_AsChar(GETATTR("_text_da"));
    pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(DA), da);
    JM_Python_str_DelForPy3(da);
    pdf_dict_del(ctx, annot->obj, PDF_NAME(DS)); /* not supported */
    pdf_dict_del(ctx, annot->obj, PDF_NAME(RC)); /* not supported */

    // field flags ------------------------------------------------------------
    int field_flags = 0, Ff = 0;
    if (field_type != PDF_WIDGET_TYPE_CHECKBOX)
    {
        field_flags = (int) PyInt_AsLong(GETATTR("field_flags"));
        if (!PyErr_Occurred())
        {
            Ff = pdf_field_flags(ctx, annot->obj);
            Ff |= field_flags;
        }
    }
    pdf_dict_put_int(ctx, annot->obj, PDF_NAME(Ff), Ff);

    // button caption ---------------------------------------------------------
    char *ca = JM_Python_str_AsChar(GETATTR("button_caption"));
    if (ca)
    {
        pdf_field_set_button_caption(ctx, annot->obj, ca);
        JM_Python_str_DelForPy3(ca);
    }

    // script (/A) -------------------------------------------------------
    value = GETATTR("script");
    JM_put_script(ctx, annot->obj, PDF_NAME(A), NULL, value);
    Py_DECREF(value);

    // script (/AA/K) -------------------------------------------------------
    value = GETATTR("script_stroke");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), value);
    Py_DECREF(value);

    // script (/AA/F) -------------------------------------------------------
    value = GETATTR("script_format");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), value);
    Py_DECREF(value);

    // script (/AA/V) -------------------------------------------------------
    value = GETATTR("script_change");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), value);
    Py_DECREF(value);

    // script (/AA/C) -------------------------------------------------------
    value = GETATTR("script_calc");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), value);
    Py_DECREF(value);

    // field value ------------------------------------------------------------
    // MuPDF function "pdf_set_field_value" always sets strings. For button
    // fields this may lead to an unrecognized state for some PDF viewers.
    //-------------------------------------------------------------------------
    value = GETATTR("field_value");
    int result = 0;
    char *text = NULL;
    switch(field_type)
    {
    case PDF_WIDGET_TYPE_CHECKBOX:
    case PDF_WIDGET_TYPE_RADIOBUTTON:
        if (PyObject_RichCompareBool(value, Py_True, Py_EQ))
        {
            result = pdf_set_field_value(ctx, pdf, annot->obj, "Yes", 1);
            pdf_dict_put_name(ctx, annot->obj, PDF_NAME(V), "Yes");
        }
        else
        {
            result = pdf_set_field_value(ctx, pdf, annot->obj, "Off", 1);
            pdf_dict_put(ctx, annot->obj, PDF_NAME(V), PDF_NAME(Off));
        }
        break;
    default:
        text = JM_Python_str_AsChar(value);
        if (text)
        {
            result = pdf_set_field_value(ctx, pdf, annot->obj, (const char *)text, 1);
            JM_Python_str_DelForPy3(text);
        }
    }
    Py_CLEAR(value);
    PyErr_Clear();
    pdf_dirty_annot(ctx, annot);
    annot->is_hot = 1;
    annot->is_active = 1;
    pdf_update_appearance(ctx, annot);
    pdf_update_page(ctx, page);
}
#undef SETATTR
#undef GETATTR
#undef CALLATTR


//-----------------------------------------------------------------------------
// perform some cleaning if we have /EmbeddedFiles:
// (1) remove any /Limits if /Names exists
// (2) remove any empty /Collection
// (3) set /PageMode/UseAttachments
//-----------------------------------------------------------------------------
void JM_embedded_clean(fz_context *ctx, pdf_document *pdf)
{
    pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));

    // remove any empty /Collection entry
    pdf_obj *coll = pdf_dict_get(ctx, root, PDF_NAME(Collection));
    if (coll && pdf_dict_len(ctx, coll) == 0)
        pdf_dict_del(ctx, root, PDF_NAME(Collection));

    pdf_obj *efiles = pdf_dict_getl(ctx, root,
                                    PDF_NAME(Names),
                                    PDF_NAME(EmbeddedFiles),
                                    PDF_NAME(Names),
                                    NULL);
    if (efiles)  // make sure embedded files get displayed by viewers
    {
        pdf_dict_put_name(ctx, root, PDF_NAME(PageMode), "UseAttachments");
    }
    return;
}

//-----------------------------------------------------------------------------
// embed a new file in a PDF (not only /EmbeddedFiles entries)
//-----------------------------------------------------------------------------
pdf_obj *JM_embed_file(fz_context *ctx,
                       pdf_document *pdf,
                       fz_buffer *buf,
                       char *filename,
                       char *ufilename,
                       char *desc,
                       int compress)
{
    size_t len = 0;
    pdf_obj *ef, *f, *params, *val = NULL;
    fz_var(val);
    fz_try(ctx)
    {
        val = pdf_new_dict(ctx, pdf, 6);
        pdf_dict_put_dict(ctx, val, PDF_NAME(CI), 4);
        ef = pdf_dict_put_dict(ctx, val, PDF_NAME(EF), 4);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(F), filename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(UF), ufilename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(Desc), desc);
        pdf_dict_put(ctx, val, PDF_NAME(Type), PDF_NAME(Filespec));
        f = pdf_add_stream(ctx, pdf,
                           fz_new_buffer_from_copied_data(ctx, "  ", 1),
                           NULL, 0);
        pdf_dict_put_drop(ctx, ef, PDF_NAME(F), f);
        JM_update_stream(ctx, pdf, f, buf, compress);
        len = fz_buffer_storage(ctx, buf, NULL);
        pdf_dict_put_int(ctx, f, PDF_NAME(DL), len);
        pdf_dict_put_int(ctx, f, PDF_NAME(Length), len);
        params = pdf_dict_put_dict(ctx, f, PDF_NAME(Params), 4);
        pdf_dict_put_int(ctx, params, PDF_NAME(Size), len);
    }
    fz_always(ctx)
    {
        ;
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return val;
}


//----------------------------------------------------------------------------
// Helpers for document page selection - main logic was imported
// from pdf_clean_file.c. But instead of analyzing a string-based spec of
// selected pages, we accept a Python sequence.
//----------------------------------------------------------------------------
typedef struct globals_s
{
    pdf_document *doc;
    fz_context *ctx;
} globals;

int string_in_names_list(fz_context *ctx, pdf_obj *p, pdf_obj *names_list)
{
    int n = pdf_array_len(ctx, names_list);
    int i;
    const char *str = pdf_to_text_string(ctx, p);

    for (i = 0; i < n ; i += 2)
    {
        if (!strcmp(pdf_to_text_string(ctx, pdf_array_get(ctx, names_list, i)), str))
            return 1;
    }
    return 0;
}

//----------------------------------------------------------------------------
// Recreate page tree to only retain specified pages.
//----------------------------------------------------------------------------
void retainpage(fz_context *ctx, pdf_document *doc, pdf_obj *parent, pdf_obj *kids, int page)
{
    pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, page);

    pdf_flatten_inheritable_page_items(ctx, pageref);

    pdf_dict_put(ctx, pageref, PDF_NAME(Parent), parent);

    /* Store page object in new kids array */
    pdf_array_push(ctx, kids, pageref);
}

int dest_is_valid_page(fz_context *ctx, pdf_obj *obj, int *page_object_nums, int pagecount)
{
    int i;
    int num = pdf_to_num(ctx, obj);

    if (num == 0)
        return 0;
    for (i = 0; i < pagecount; i++)
    {
        if (page_object_nums[i] == num)
            return 1;
    }
    return 0;
}

int dest_is_valid(fz_context *ctx, pdf_obj *o, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    pdf_obj *p;

    p = pdf_dict_get(ctx, o, PDF_NAME(A));
    if (pdf_name_eq(ctx, pdf_dict_get(ctx, p, PDF_NAME(S)), PDF_NAME(GoTo)) &&
        !string_in_names_list(ctx, pdf_dict_get(ctx, p, PDF_NAME(D)), names_list))
        return 0;

    p = pdf_dict_get(ctx, o, PDF_NAME(Dest));
    if (p == NULL)
    {}
    else if (pdf_is_string(ctx, p))
    {
        return string_in_names_list(ctx, p, names_list);
    }
    else if (!dest_is_valid_page(ctx, pdf_array_get(ctx, p, 0), page_object_nums, page_count))
        return 0;

    return 1;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list);

int strip_outline(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list, pdf_obj **pfirst, pdf_obj **plast)
{
    pdf_obj *prev = NULL;
    pdf_obj *first = NULL;
    pdf_obj *current;
    int count = 0;

    for (current = outlines; current != NULL; )
    {
        int nc;

        /*********************************************************************/
        // Strip any children to start with. This takes care of
        // First / Last / Count for us.
        /*********************************************************************/
        nc = strip_outlines(ctx, doc, current, page_count, page_object_nums, names_list);

        if (!dest_is_valid(ctx, current, page_count, page_object_nums, names_list))
        {
            if (nc == 0)
            {
                /*************************************************************/
                // Outline with invalid dest and no children. Drop it by
                // pulling the next one in here.
                /*************************************************************/
                pdf_obj *next = pdf_dict_get(ctx, current, PDF_NAME(Next));
                if (next == NULL)
                {
                    // There is no next one to pull in
                    if (prev != NULL)
                        pdf_dict_del(ctx, prev, PDF_NAME(Next));
                }
                else if (prev != NULL)
                {
                    pdf_dict_put(ctx, prev, PDF_NAME(Next), next);
                    pdf_dict_put(ctx, next, PDF_NAME(Prev), prev);
                }
                else
                {
                    pdf_dict_del(ctx, next, PDF_NAME(Prev));
                }
                current = next;
            }
            else
            {
                // Outline with invalid dest, but children. Just drop the dest.
                pdf_dict_del(ctx, current, PDF_NAME(Dest));
                pdf_dict_del(ctx, current, PDF_NAME(A));
                current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            }
        }
        else
        {
            // Keep this one
            if (first == NULL)
                first = current;
            prev = current;
            current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            count++;
        }
    }

    *pfirst = first;
    *plast = prev;

    return count;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    int nc;
    pdf_obj *first;
    pdf_obj *last;

    if (outlines == NULL)
        return 0;

    first = pdf_dict_get(ctx, outlines, PDF_NAME(First));
    if (first == NULL)
        nc = 0;
    else
        nc = strip_outline(ctx, doc, first, page_count, page_object_nums,
                           names_list, &first, &last);

    if (nc == 0)
    {
        pdf_dict_del(ctx, outlines, PDF_NAME(First));
        pdf_dict_del(ctx, outlines, PDF_NAME(Last));
        pdf_dict_del(ctx, outlines, PDF_NAME(Count));
    }
    else
    {
        int old_count = pdf_to_int(ctx, pdf_dict_get(ctx, outlines, PDF_NAME(Count)));
        pdf_dict_put(ctx, outlines, PDF_NAME(First), first);
        pdf_dict_put(ctx, outlines, PDF_NAME(Last), last);
        pdf_dict_put_drop(ctx, outlines, PDF_NAME(Count), pdf_new_int(ctx, old_count > 0 ? nc : -nc));
    }
    return nc;
}

//----------------------------------------------------------------------------
//   This is called by PyMuPDF:
//   liste = page numbers to retain
//----------------------------------------------------------------------------
void retainpages(fz_context *ctx, globals *glo, PyObject *liste)
{
    pdf_obj *oldroot, *root, *pages, *kids, *countobj, *olddests;
    Py_ssize_t argc = PySequence_Size(liste);
    pdf_document *doc = glo->doc;
    pdf_obj *names_list = NULL;
    pdf_obj *outlines;
    pdf_obj *ocproperties;
    int pagecount = pdf_count_pages(ctx, doc);

    int i;
    int *page_object_nums;

/******************************************************************************/
//    Keep only pages/type and (reduced) dest entries to avoid
//    references to dropped pages
/******************************************************************************/
    oldroot = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
    pages = pdf_dict_get(ctx, oldroot, PDF_NAME(Pages));
    olddests = pdf_load_name_tree(ctx, doc, PDF_NAME(Dests));
    outlines = pdf_dict_get(ctx, oldroot, PDF_NAME(Outlines));
    ocproperties = pdf_dict_get(ctx, oldroot, PDF_NAME(OCProperties));

    root = pdf_new_dict(ctx, doc, 3);
    pdf_dict_put(ctx, root, PDF_NAME(Type), pdf_dict_get(ctx, oldroot, PDF_NAME(Type)));
    pdf_dict_put(ctx, root, PDF_NAME(Pages), pdf_dict_get(ctx, oldroot, PDF_NAME(Pages)));
    if (outlines)
        pdf_dict_put(ctx, root, PDF_NAME(Outlines), outlines);
    if (ocproperties)
        pdf_dict_put(ctx, root, PDF_NAME(OCProperties), ocproperties);

    pdf_update_object(ctx, doc, pdf_to_num(ctx, oldroot), root);

    // Create a new kids array with only the pages we want to keep
    kids = pdf_new_array(ctx, doc, 1);

    // Retain pages specified
    Py_ssize_t page;
    fz_try(ctx)
    {
        for (page = 0; page < argc; page++)
            {
                i = (int) PyInt_AsLong(PySequence_ITEM(liste, page));
                if (i < 0 || i >= pagecount)
                    THROWMSG("invalid page number(s)");
                retainpage(ctx, doc, pages, kids, i);
            }
    }
    fz_catch(ctx) fz_rethrow(ctx);

    // Update page count and kids array
    countobj = pdf_new_int(ctx, pdf_array_len(ctx, kids));
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Count), countobj);
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Kids), kids);

    pagecount = pdf_count_pages(ctx, doc);
    page_object_nums = fz_calloc(ctx, pagecount, sizeof(*page_object_nums));
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);
        page_object_nums[i] = pdf_to_num(ctx, pageref);
    }

/******************************************************************************/
// If we had an old Dests tree (now reformed as an olddests dictionary),
// keep any entries in there that point to valid pages.
// This may mean we keep more than we need, but it is safe at least.
/******************************************************************************/
    if (olddests)
    {
        pdf_obj *names = pdf_new_dict(ctx, doc, 1);
        pdf_obj *dests = pdf_new_dict(ctx, doc, 1);
        int len = pdf_dict_len(ctx, olddests);

        names_list = pdf_new_array(ctx, doc, 32);

        for (i = 0; i < len; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, olddests, i);
            pdf_obj *val = pdf_dict_get_val(ctx, olddests, i);
            pdf_obj *dest = pdf_dict_get(ctx, val, PDF_NAME(D));

            dest = pdf_array_get(ctx, dest ? dest : val, 0);
            if (dest_is_valid_page(ctx, dest, page_object_nums, pagecount))
            {
                pdf_obj *key_str = pdf_new_string(ctx, pdf_to_name(ctx, key), strlen(pdf_to_name(ctx, key)));
                pdf_array_push_drop(ctx, names_list, key_str);
                pdf_array_push(ctx, names_list, val);
            }
        }

        pdf_dict_put(ctx, dests, PDF_NAME(Names), names_list);
        pdf_dict_put(ctx, names, PDF_NAME(Dests), dests);
        pdf_dict_put(ctx, root, PDF_NAME(Names), names);

        pdf_drop_obj(ctx, names);
        pdf_drop_obj(ctx, dests);
        pdf_drop_obj(ctx, olddests);
    }

/*****************************************************************************/
// Edit each pages /Annot list to remove any links pointing to nowhere.
/*****************************************************************************/
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);

        pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));

        int len = pdf_array_len(ctx, annots);
        int j;

        for (j = 0; j < len; j++)
        {
            pdf_obj *o = pdf_array_get(ctx, annots, j);

            if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                continue;

            if (!dest_is_valid(ctx, o, pagecount, page_object_nums, names_list))
            {
                // Remove this annotation
                pdf_array_delete(ctx, annots, j);
                len--;
                j--;
            }
        }
    }

    if (strip_outlines(ctx, doc, outlines, pagecount, page_object_nums, names_list) == 0)
    {
        pdf_dict_del(ctx, root, PDF_NAME(Outlines));
    }

    fz_free(ctx, page_object_nums);
    pdf_drop_obj(ctx, names_list);
    pdf_drop_obj(ctx, root);
}

PyObject *remove_dest_range(fz_context *ctx, pdf_document *pdf, int first, int last)
{
    int i, pno, pagecount = pdf_count_pages(ctx, pdf);
    if (!INRANGE(first, 0, pagecount-1) ||
        !INRANGE(last, 0, pagecount-1) ||
        (first > last))
        Py_RETURN_NONE;
    fz_try(ctx)
    {
        for (i = 0; i < pagecount; i++)
        {
            if (INRANGE(i, first, last)) continue;

            pdf_obj *pageref = pdf_lookup_page_obj(ctx, pdf, i);
            pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));
            pdf_obj *target;
            if (!annots) continue;
            int len = pdf_array_len(ctx, annots);
            int j;
            for (j = len - 1; j >= 0; j -= 1)
            {
                pdf_obj *o = pdf_array_get(ctx, annots, j);
                if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                    continue;
                pdf_obj *action = pdf_dict_get(ctx, o, PDF_NAME(A));
                pdf_obj *dest =  pdf_dict_get(ctx, o, PDF_NAME(Dest));
                if (action)
                {
                    if (!pdf_name_eq(ctx, pdf_dict_get(ctx, action,
                        PDF_NAME(S)), PDF_NAME(GoTo)))
                        continue;
                    dest = pdf_dict_get(ctx, action, PDF_NAME(D));
                }
                pno = -1;
                if (pdf_is_array(ctx, dest))
                {
                    target = pdf_array_get(ctx, dest, 0);
                    pno = pdf_lookup_page_number(ctx, pdf, target);
                }
                else if (pdf_is_string(ctx, dest))
                {
                    pno = pdf_lookup_anchor(ctx, pdf,
                                            pdf_to_text_string(ctx, dest),
                                            NULL, NULL);
                }
                if (INRANGE(pno, first, last))
                {
                    pdf_array_delete(ctx, annots, j);
                }
            }
        }
    }
    fz_catch(ctx) return NULL;
    Py_RETURN_NONE;
}


//-----------------------------------------------------------------------------
// Read and concatenate a PDF page's /Conents object(s) in a buffer
//-----------------------------------------------------------------------------
fz_buffer *JM_read_contents(fz_context *ctx, pdf_obj *pageref)
{
    fz_buffer *res = NULL, *nres = NULL;
    int i;
    fz_try(ctx)
    {
        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
        if (pdf_is_array(ctx, contents))     // maybe more than one!
        {
            res = fz_new_buffer(ctx, 1024);
            for (i=0; i < pdf_array_len(ctx, contents); i++)
            {
                nres = pdf_load_stream(ctx, pdf_array_get(ctx, contents, i));
                fz_append_buffer(ctx, res, nres);
                fz_drop_buffer(ctx, nres);
            }
        }
        else if (contents)
        {
            res = pdf_load_stream(ctx, contents);
        }
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return res;
}


//-----------------------------------------------------------------------------
// Make an XObject from a PDF page
// For a positive xref assume that that object can be used instead
//-----------------------------------------------------------------------------
pdf_obj *JM_xobject_from_page(fz_context *ctx, pdf_document *pdfout, fz_page *fsrcpage, int xref, pdf_graft_map *gmap)
{
    fz_buffer *res = NULL;
    pdf_obj *xobj1, *contents = NULL, *resources = NULL, *o, *spageref;
    fz_rect mediabox;

    fz_try(ctx)
    {
        pdf_page *srcpage = pdf_page_from_fz_page(ctx, fsrcpage);
        spageref = srcpage->obj;
        mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(MediaBox)));

        if (xref > 0)        // we can reuse an XObject!
        {
            xobj1 = pdf_new_indirect(ctx, pdfout, xref, 0);
        }
        else                 // need to create new XObject
        {
            // Deep-copy resources object of source page
            o = pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(Resources));
            if (gmap)        // use graftmap when possible
                resources = pdf_graft_mapped_object(ctx, gmap, o);
            else
                resources = pdf_graft_object(ctx, pdfout, o);

            // get spgage contents source
            res = JM_read_contents(ctx, spageref);

            //-------------------------------------------------------------
            // create XObject representing the source page
            //-------------------------------------------------------------
            xobj1 = pdf_new_xobject(ctx, pdfout, mediabox, fz_identity, NULL, res);
            // store spage contents
            JM_update_stream(ctx, pdfout, xobj1, res, 1);
            fz_drop_buffer(ctx, res);

            // store spage resources
            pdf_dict_put_drop(ctx, xobj1, PDF_NAME(Resources), resources);
        }
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return xobj1;
}

//-----------------------------------------------------------------------------
// Insert a buffer as a new separate /Contents object of a page.
// 1. Create a new stream object from buffer 'newcont'
// 2. If /Contents already is an array, then just prepend or append this object
// 3. Else, create new array and put old content obj and this object into it.
//    If the page had no /Contents before, just create a 1-item array.
//-----------------------------------------------------------------------------
int JM_insert_contents(fz_context *ctx, pdf_document *pdf,
                        pdf_obj *pageref, fz_buffer *newcont, int overlay)
{
    int xref = 0;
    fz_try(ctx)
    {
        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
        pdf_obj *newconts = pdf_add_stream(ctx, pdf, newcont, NULL, 0);
        xref = pdf_to_num(ctx, newconts);
        if (pdf_is_array(ctx, contents))
        {
            if (overlay)               // append new object
                pdf_array_push_drop(ctx, contents, newconts);
            else                       // prepend new object
                pdf_array_insert_drop(ctx, contents, newconts, 0);
        }
        else                           // make new array
        {
            pdf_obj *carr = pdf_new_array(ctx, pdf, 5);
            if (overlay)
            {
                if (contents) pdf_array_push(ctx, carr, contents);
                pdf_array_push_drop(ctx, carr, newconts);
            }
            else
            {
                pdf_array_push_drop(ctx, carr, newconts);
                if (contents) pdf_array_push(ctx, carr, contents);
            }
            pdf_dict_put_drop(ctx, pageref, PDF_NAME(Contents), carr);
        }
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return xref;
}
/*------------------ currently not used ---------------------------------------
//-----------------------------------------------------------------------------
// Append / prepend a buffer to the /Contents of a page.
//-----------------------------------------------------------------------------
void JM_extend_contents(fz_context *ctx, pdf_document *pdfout,
                        pdf_obj *pageref, fz_buffer *newcont, int overlay)
{
    int i;
    fz_buffer *oldcont = NULL, *endcont = NULL;
    pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
    fz_try(ctx)
    {
        if (pdf_is_array(ctx, contents))     // multiple contents objects!
        {   // choose the correct one (first / last)
            if (overlay == 1) i = pdf_array_len(ctx, contents) - 1;
            else  i = 0;
            contents = pdf_array_get(ctx, contents, i);
        }
        oldcont = pdf_load_stream(ctx, contents);     // old contents buffer

        // allocate result buffer
        endcont = fz_new_buffer(ctx, fz_buffer_storage(ctx, oldcont, NULL) +
                                     fz_buffer_storage(ctx, newcont, NULL));

        if (overlay == 1)                             // append new buffer
        {
            fz_append_buffer(ctx, endcont, oldcont);
            fz_append_buffer(ctx, endcont, newcont);
        }
        else                                          // prepend new buffer
        {
            fz_append_buffer(ctx, endcont, newcont);
            fz_append_buffer(ctx, endcont, oldcont);
        }
        fz_terminate_buffer(ctx, endcont);            // finalize result buffer

        // now update the content stream
        JM_update_stream(ctx, pdfout, contents, endcont, 1);
    }
    fz_always(ctx)
    {
        fz_drop_buffer(ctx, endcont);
        fz_drop_buffer(ctx, oldcont);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}
-----------------------------------------------------------------------------*/




//-----------------------------------------------------------------------------
// Store info of a font in Python list
//-----------------------------------------------------------------------------
void JM_gather_fonts(fz_context *ctx, pdf_document *pdf, pdf_obj *dict,
                    PyObject *fontlist, int stream_xref)
{
    int i, n;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++)
    {
        pdf_obj *fontdict = NULL;
        pdf_obj *subtype = NULL;
        pdf_obj *basefont = NULL;
        pdf_obj *name = NULL;
        pdf_obj *refname = NULL;
        pdf_obj *encoding = NULL;

        refname = pdf_dict_get_key(ctx, dict, i);
        fontdict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, fontdict))
        {
            fz_warn(ctx, "'%s' is no font dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, fontdict));
            continue;
        }
        subtype = pdf_dict_get(ctx, fontdict, PDF_NAME(Subtype));
        basefont = pdf_dict_get(ctx, fontdict, PDF_NAME(BaseFont));
        if (!basefont || pdf_is_null(ctx, basefont))
            name = pdf_dict_get(ctx, fontdict, PDF_NAME(Name));
        else
            name = basefont;
        encoding = pdf_dict_get(ctx, fontdict, PDF_NAME(Encoding));
        if (pdf_is_dict(ctx, encoding))
            encoding = pdf_dict_get(ctx, encoding, PDF_NAME(BaseEncoding));
        int xref = pdf_to_num(ctx, fontdict);
        char *ext = "n/a";
        if (xref) ext = JM_get_fontextension(ctx, pdf, xref);
        PyObject *entry = PyTuple_New(7);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", ext));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("s", pdf_to_name(ctx, subtype)));
        PyTuple_SET_ITEM(entry, 3, JM_EscapeStrFromStr(pdf_to_name(ctx, name)));
        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("s", pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 5, Py_BuildValue("s", pdf_to_name(ctx, encoding)));
        PyTuple_SET_ITEM(entry, 6, Py_BuildValue("i", stream_xref));
        LIST_APPEND_DROP(fontlist, entry);
    }
}

//-----------------------------------------------------------------------------
// Store info of an image in Python list
//-----------------------------------------------------------------------------
void JM_gather_images(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist, int stream_xref)
{
    int i, n;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++)
    {
        pdf_obj *imagedict, *smask;
        pdf_obj *refname = NULL;
        pdf_obj *type;
        pdf_obj *width;
        pdf_obj *height;
        pdf_obj *bpc = NULL;
        pdf_obj *filter = NULL;
        pdf_obj *cs = NULL;
        pdf_obj *altcs;

        refname = pdf_dict_get_key(ctx, dict, i);
        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict))
        {
            fz_warn(ctx, "'%s' is no image dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
            continue;
        }

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Image)))
            continue;
        
        int xref = pdf_to_num(ctx, imagedict);
        int gen = 0;
        smask = pdf_dict_get(ctx, imagedict, PDF_NAME(SMask));
        if (smask)
            gen = pdf_to_num(ctx, smask);
        filter = pdf_dict_get(ctx, imagedict, PDF_NAME(Filter));
        if (pdf_is_array(ctx, filter))
        {
            filter = pdf_array_get(ctx, filter, 0);
        }

        altcs = NULL;
        cs = pdf_dict_get(ctx, imagedict, PDF_NAME(ColorSpace));
        if (pdf_is_array(ctx, cs))
        {
            pdf_obj *cses = cs;
            cs = pdf_array_get(ctx, cses, 0);
            if (pdf_name_eq(ctx, cs, PDF_NAME(DeviceN)) ||
                pdf_name_eq(ctx, cs, PDF_NAME(Separation)))
            {
                altcs = pdf_array_get(ctx, cses, 2);
                if (pdf_is_array(ctx, altcs))
                    altcs = pdf_array_get(ctx, altcs, 0);
            }
        }

        width = pdf_dict_get(ctx, imagedict, PDF_NAME(Width));
        height = pdf_dict_get(ctx, imagedict, PDF_NAME(Height));
        bpc = pdf_dict_get(ctx, imagedict, PDF_NAME(BitsPerComponent));

        PyObject *entry = PyTuple_New(10);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("i", gen));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", pdf_to_int(ctx, width)));
        PyTuple_SET_ITEM(entry, 3, Py_BuildValue("i", pdf_to_int(ctx, height)));
        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("i", pdf_to_int(ctx, bpc)));
        PyTuple_SET_ITEM(entry, 5, JM_EscapeStrFromStr(pdf_to_name(ctx, cs)));
        PyTuple_SET_ITEM(entry, 6, JM_EscapeStrFromStr(pdf_to_name(ctx, altcs)));
        PyTuple_SET_ITEM(entry, 7, JM_EscapeStrFromStr(pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 8, JM_EscapeStrFromStr(pdf_to_name(ctx, filter)));
        PyTuple_SET_ITEM(entry, 9, Py_BuildValue("i", stream_xref));
        LIST_APPEND_DROP(imagelist, entry);
    }
}

//-----------------------------------------------------------------------------
// Store info of a /Form xobject in Python list
//-----------------------------------------------------------------------------
void JM_gather_forms(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist, int stream_xref)
{
    int i, n = pdf_dict_len(ctx, dict);
    fz_rect bbox;
    pdf_obj *o = NULL, *m = NULL;
    for (i = 0; i < n; i++)
    {
        pdf_obj *imagedict;
        pdf_obj *refname = NULL;
        pdf_obj *type;

        refname = pdf_dict_get_key(ctx, dict, i);
        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict))
        {
            fz_warn(ctx, "'%s' is no form dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
            continue;
        }

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Form)))
            continue;

        o = pdf_dict_get(ctx, imagedict, PDF_NAME(BBox));
        m = pdf_dict_get(ctx, imagedict, PDF_NAME(Matrix));
        if (o)
        {
            if (m)
            {
                bbox = fz_transform_rect(pdf_to_rect(ctx, o), pdf_to_matrix(ctx, m));
            }
            else
            {
                bbox = pdf_to_rect(ctx, o);
            }
        }
        else
        {
            bbox = fz_infinite_rect;
        }
        int xref = pdf_to_num(ctx, imagedict);

        PyObject *entry = PyTuple_New(4);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", stream_xref));
        PyTuple_SET_ITEM(entry, 3, Py_BuildValue("ffff",
                                   bbox.x0, bbox.y0, bbox.x1, bbox.y1));
        LIST_APPEND_DROP(imagelist, entry);
    }
}

//-----------------------------------------------------------------------------
// Step through /Resources, looking up image, xobject or font information
//-----------------------------------------------------------------------------
void JM_scan_resources(fz_context *ctx, pdf_document *pdf, pdf_obj *rsrc,
                 PyObject *liste, int what, int stream_xref)
{
    pdf_obj *font, *xobj, *subrsrc;
    int i, n, sxref;
    if (pdf_mark_obj(ctx, rsrc)) return;    // stop on cylic dependencies
    fz_try(ctx)
    {
        if (what == 1)  // look up fonts
        {
            font = pdf_dict_get(ctx, rsrc, PDF_NAME(Font));
            JM_gather_fonts(ctx, pdf, font, liste, stream_xref);
            n = pdf_dict_len(ctx, font);
            for (i = 0; i < n; i++)
            {
                pdf_obj *obj = pdf_dict_get_val(ctx, font, i);
                if (pdf_is_stream(ctx, obj))
                {
                    sxref = pdf_to_num(ctx, obj);
                }
                else
                {
                    sxref = 0;
                }
                subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
                if (subrsrc)
                    JM_scan_resources(ctx, pdf, subrsrc, liste, what, sxref);
            }
        }

        xobj = pdf_dict_get(ctx, rsrc, PDF_NAME(XObject));

        if (what == 2)  // look up images
        {
            JM_gather_images(ctx, pdf, xobj, liste, stream_xref);
        }

        if (what == 3)  // look up form xobjects
        {
            JM_gather_forms(ctx, pdf, xobj, liste, stream_xref);
        }

        n = pdf_dict_len(ctx, xobj);
        for (i = 0; i < n; i++)
        {
            pdf_obj *obj = pdf_dict_get_val(ctx, xobj, i);
            if (pdf_is_stream(ctx, obj))
            {
                sxref = pdf_to_num(ctx, obj);
            }
            else
            {
                sxref = 0;
            }
            subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
            if (subrsrc)
                JM_scan_resources(ctx, pdf, subrsrc, liste, what, sxref);
        }
    }
    fz_always(ctx) pdf_unmark_obj(ctx, rsrc);
    fz_catch(ctx)  fz_rethrow(ctx);
}



//-----------------------------------------------------------------------------
// Convert any MuPDF document to a PDF
// Returns bytes object containing the PDF, created via 'write' function.
//-----------------------------------------------------------------------------
PyObject *JM_convert_to_pdf(fz_context *ctx, fz_document *doc, int fp, int tp, int rotate)
{
    pdf_document *pdfout = pdf_create_document(ctx);  // new PDF document
    int i, incr = 1, s = fp, e = tp;
    if (fp > tp)             // revert page sequence
    {
        incr = -1;           // count backwards
        s = tp;              // adjust ...
        e = fp;              // ... range
    }
    fz_rect mediabox;
    fz_device *dev = NULL;
    fz_buffer *contents = NULL;
    pdf_obj *resources = NULL;
    fz_page *page;
    fz_var(dev);
    fz_var(contents);
    fz_var(resources);
    fz_var(page);
    for (i = fp; INRANGE(i, s, e); i += incr)
    {   // interpret & write document pages as PDF pages
        fz_try(ctx)
        {
            page = fz_load_page(ctx, doc, i);
            mediabox = fz_bound_page(ctx, page);
            dev = pdf_page_write(ctx, pdfout, mediabox, &resources, &contents);
            fz_run_page(ctx, page, dev, fz_identity, NULL);
            fz_close_device(ctx, dev);
            fz_drop_device(ctx, dev);
            dev = NULL;
            pdf_obj *page_obj = pdf_add_page(ctx, pdfout, mediabox, rotate, resources, contents);
            pdf_insert_page(ctx, pdfout, -1, page_obj);
            pdf_drop_obj(ctx, page_obj);
        }
        fz_always(ctx)
        {
            pdf_drop_obj(ctx, resources);
            fz_drop_buffer(ctx, contents);
            fz_drop_device(ctx, dev);
        }
        fz_catch(ctx)
        {
            fz_drop_page(ctx, page);
            fz_rethrow(ctx);
        }
    }
    // PDF created - now write it to Python bytearray
    PyObject *r = NULL;
    fz_output *out = NULL;
    fz_buffer *res = NULL;
    // prepare write options structure
    pdf_write_options opts = { 0 };
    opts.do_garbage         = 4;
    opts.do_compress        = 1;
    opts.do_compress_images = 1;
    opts.do_compress_fonts  = 1;
    opts.do_sanitize        = 1;
    opts.do_incremental     = 0;
    opts.do_ascii           = 0;
    opts.do_decompress      = 0;
    opts.do_linear          = 0;
    opts.do_clean           = 1;
    opts.do_pretty          = 0;

    fz_try(ctx)
    {
        res = fz_new_buffer(ctx, 8192);
        out = fz_new_output_with_buffer(ctx, res);
        pdf_write_document(ctx, pdfout, out, &opts);
        char *c = NULL;
        size_t len = fz_buffer_storage(gctx, res, &c);
        r = PyBytes_FromStringAndSize(c, (Py_ssize_t) len);
    }
    fz_always(ctx)
    {
        fz_drop_output(ctx, out);
        fz_drop_buffer(ctx, res);
    }
    fz_catch(ctx)
    {
        fz_rethrow(ctx);
    }
    return r;
}

SWIGINTERN void delete_fz_document_s(struct fz_document_s *self){
            DEBUGMSG1("document w/o close");
            fz_drop_document(gctx, self);
            DEBUGMSG2;
        }

SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}





#include <float.h>


#include <math.h>


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(__clang__) && defined(__has_builtin)
#  if __has_builtin(__builtin_isfinite)
#   define SWIG_isfinite(X) (__builtin_isfinite(X))
#  endif
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}

SWIGINTERN struct fz_document_s *new_fz_document_s(char const *filename,PyObject *stream,char const *filetype,PyObject *rect,float width,float height,float fontsize){
            gctx->error.errcode = 0;       // reset any error code
            gctx->error.message[0] = 0;    // reset any error message
            struct fz_document_s *doc = NULL;
            char *c = NULL;
            size_t len = 0;
            fz_stream *data = NULL;
            float w = width, h = height;
            fz_rect r = JM_rect_from_py(rect);
            if (!fz_is_infinite_rect(r))
            {
                w = r.x1 - r.x0;
                h = r.y1 - r.y0;
            }

            fz_try(gctx)
            {
                if (stream != Py_None)  // stream given, **MUST** be bytes!
                {
                    c = PyBytes_AS_STRING(stream); // just a pointer, no new obj
                    len = (size_t) PyBytes_Size(stream);
                    data = fz_open_memory(gctx, c, len);
                    char *magic = (char *)filename;
                    if (!magic) magic = (char *)filetype;
                    doc = fz_open_document_with_stream(gctx, magic, data);
                }
                else
                {
                    if (filename)
                    {
                        if (!filetype || strlen(filetype) == 0)
                        {
                            doc = fz_open_document(gctx, filename);
                        }
                        else
                        {
                            const fz_document_handler *handler;
                            handler = fz_recognize_document(gctx, filetype);
                            if (handler && handler->open)
                                doc = handler->open(gctx, filename);
                            else THROWMSG("unrecognized file type");
                        }
                    }
                    else
                    {
                        pdf_document *pdf = pdf_create_document(gctx);
                        pdf->dirty = 1;
                        doc = (fz_document *) pdf;
                    }
                }
            }
            fz_catch(gctx) return NULL;
            if (w > 0 && h > 0)
                fz_layout_document(gctx, doc, w, h, fontsize);
            return doc;
        }
SWIGINTERN void fz_document_s_close(struct fz_document_s *self){
            DEBUGMSG1("doc.close()");
            while(self->refs > 1) {
                fz_drop_document(gctx, self);
            }
            fz_drop_document(gctx, self);
            DEBUGMSG2;
        }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN struct fz_page_s *fz_document_s_loadPage(struct fz_document_s *self,int number){
            struct fz_page_s *page = NULL;
            fz_try(gctx)
            {
                int pageCount = fz_count_pages(gctx, self);
                if (pageCount < 1) THROWMSG("document has no pages");
                int n = number;
                while (n < 0) n += pageCount;
                page = fz_load_page(gctx, self, n);
            }
            fz_catch(gctx) return NULL;
            return page;
        }
SWIGINTERN PyObject *fz_document_s__remove_links_to(struct fz_document_s *self,int first,int last){
            fz_try(gctx)
            {
                pdf_document *pdf = pdf_specifics(gctx, self);
                pdf_drop_page_tree(gctx, pdf);
                pdf_load_page_tree(gctx, pdf);
                remove_dest_range(gctx, pdf, first, last);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN struct fz_outline_s *fz_document_s__loadOutline(struct fz_document_s *self){
            fz_outline *ol = NULL;
            fz_try(gctx) ol = fz_load_outline(gctx, self);
            fz_catch(gctx) return NULL;
            return ol;
        }
SWIGINTERN void fz_document_s__dropOutline(struct fz_document_s *self,struct fz_outline_s *ol){
            DEBUGMSG1("outline");
            fz_drop_outline(gctx, ol);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileNames(struct fz_document_s *self,PyObject *namelist){
            pdf_document *pdf = pdf_specifics(gctx, self); // get pdf document
            fz_try(gctx)
            {
                assert_PDF(pdf);
                PyObject *val;
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                if (pdf_is_array(gctx, names))
                {
                    int i, n = pdf_array_len(gctx, names);
                    for (i=0; i < n; i+=2)
                    {
                        val = JM_EscapeStrFromStr(pdf_to_text_string(gctx,
                                         pdf_array_get(gctx, names, i)));
                        LIST_APPEND_DROP(namelist, val);
                    }
                }
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileDel(struct fz_document_s *self,int idx){
            fz_try(gctx)
            {
                pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                pdf_array_delete(gctx, names, idx + 1);
                pdf_array_delete(gctx, names, idx);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileInfo(struct fz_document_s *self,int idx,PyObject *infodict){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            char *name;
            fz_try(gctx)
            {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *o = pdf_array_get(gctx, names, 2*idx+1);

                name = (char *) pdf_to_text_string(gctx,
                                          pdf_dict_get(gctx, o, PDF_NAME(F)));
                DICT_SETITEM_DROP(infodict, dictkey_filename, JM_EscapeStrFromStr(name));

                name = (char *) pdf_to_text_string(gctx,
                                    pdf_dict_get(gctx, o, PDF_NAME(UF)));
                DICT_SETITEM_DROP(infodict, dictkey_ufilename, JM_EscapeStrFromStr(name));

                name = (char *) pdf_to_text_string(gctx,
                                    pdf_dict_get(gctx, o, PDF_NAME(Desc)));
                DICT_SETITEM_DROP(infodict, dictkey_desc, JM_UnicodeFromStr(name));

                int len = -1, DL = -1;
                pdf_obj *ef = pdf_dict_get(gctx, o, PDF_NAME(EF));
                o = pdf_dict_getl(gctx, ef, PDF_NAME(F),
                                            PDF_NAME(Length), NULL);
                if (o) len = pdf_to_int(gctx, o);

                o = pdf_dict_getl(gctx, ef, PDF_NAME(F), PDF_NAME(DL), NULL);
                if (o) DL = pdf_to_int(gctx, o);
                else
                {
                    o = pdf_dict_getl(gctx, ef, PDF_NAME(F), PDF_NAME(Params),
                                   PDF_NAME(Size), NULL);
                    if (o) DL = pdf_to_int(gctx, o);
                }
                DICT_SETITEM_DROP(infodict, dictkey_size, Py_BuildValue("i", DL));
                DICT_SETITEM_DROP(infodict, dictkey_length, Py_BuildValue("i", len));
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileUpd(struct fz_document_s *self,int idx,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *entry = pdf_array_get(gctx, names, 2*idx+1);

                pdf_obj *filespec = pdf_dict_getl(gctx, entry, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);
                if (!filespec) THROWMSG("bad PDF: /EF object not found");

                res = JM_BufferFromBytes(gctx, buffer);
                if (EXISTS(buffer) && !res) THROWMSG("bad type: 'buffer'");
                if (res)
                {
                    JM_update_stream(gctx, pdf, filespec, res, 1);
                    // adjust /DL and /Size parameters
                    int64_t len = (int64_t) fz_buffer_storage(gctx, res, NULL);
                    pdf_obj *l = pdf_new_int(gctx, len);
                    pdf_dict_put(gctx, filespec, PDF_NAME(DL), l);
                    pdf_dict_putl(gctx, filespec, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
                }

                if (filename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(F), filename);

                if (ufilename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(UF), ufilename);

                if (desc)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(Desc), desc);
            }
            fz_always(gctx)
                fz_drop_buffer(gctx, res);
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileGet(struct fz_document_s *self,int idx){
            PyObject *cont = NULL;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *buf = NULL;
            fz_var(buf);
            fz_try(gctx)
            {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *entry = pdf_array_get(gctx, names, 2*idx+1);
                pdf_obj *filespec = pdf_dict_getl(gctx, entry, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);
                buf = pdf_load_stream(gctx, filespec);
                cont = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) fz_drop_buffer(gctx, buf);
            fz_catch(gctx) return NULL;
            return cont;
        }
SWIGINTERN PyObject *fz_document_s__embeddedFileAdd(struct fz_document_s *self,char const *name,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            fz_buffer *data = NULL;
            char *buffdata;
            fz_var(data);
            int entry = 0;
            size_t size = 0;
            pdf_obj *names = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                data = JM_BufferFromBytes(gctx, buffer);
                if (!data) THROWMSG("bad type: 'buffer'");
                size = fz_buffer_storage(gctx, data, &buffdata);

                names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                if (!pdf_is_array(gctx, names))  // no embedded files yet
                {
                    pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                                 PDF_NAME(Root));
                    names = pdf_new_array(gctx, pdf, 6);  // an even number!
                    pdf_dict_putl_drop(gctx, root, names,
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                }

                pdf_obj *fileentry = JM_embed_file(gctx, pdf, data,
                                                   filename,
                                                   ufilename,
                                                   desc, 1);
                pdf_array_push(gctx, names, pdf_new_text_string(gctx, name));
                pdf_array_push_drop(gctx, names, fileentry);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, data);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s_convertToPDF(struct fz_document_s *self,int from_page,int to_page,int rotate){
            PyObject *doc = NULL;
            fz_try(gctx)
            {
                int fp = from_page, tp = to_page, srcCount = fz_count_pages(gctx, self);
                if (pdf_specifics(gctx, self))
                    THROWMSG("use select+write or insertPDF for PDF docs instead");
                if (fp < 0) fp = 0;
                if (fp > srcCount - 1) fp = srcCount - 1;
                if (tp < 0) tp = srcCount - 1;
                if (tp > srcCount - 1) tp = srcCount - 1;
                doc = JM_convert_to_pdf(gctx, self, fp, tp, rotate);
            }
            fz_catch(gctx) return NULL;
            return doc;
        }
SWIGINTERN PyObject *fz_document_s_pageCount(struct fz_document_s *self){
            return Py_BuildValue("i", fz_count_pages(gctx, self));
        }
SWIGINTERN char *fz_document_s__getMetadata(struct fz_document_s *self,char const *key){
            int vsize;
            char *value;
            vsize = fz_lookup_metadata(gctx, self, key, NULL, 0)+1;
            if(vsize > 1)
            {
                value = JM_Alloc(char, vsize);
                fz_lookup_metadata(gctx, self, key, value, vsize);
                return value;
            }
            else
                return NULL;
        }
SWIGINTERN PyObject *fz_document_s_needsPass(struct fz_document_s *self){
            return JM_BOOL(fz_needs_password(gctx, self));
        }
SWIGINTERN PyObject *fz_document_s_resolveLink(struct fz_document_s *self,char *uri){
            if (!uri) return_none;
            float xp = 0.0f, yp = 0.0f;
            int pno = -1;
            fz_try(gctx)
                pno = fz_resolve_link(gctx, self, uri, &xp, &yp);
            fz_catch(gctx)
                return_none;
            if (pno < 0) return_none;
            return Py_BuildValue("iff", pno, xp, yp);
        }
SWIGINTERN PyObject *fz_document_s_layout(struct fz_document_s *self,PyObject *rect,float width,float height,float fontsize){
            if (!fz_is_document_reflowable(gctx, self)) return_none;
            fz_try(gctx)
            {
                float w = width, h = height;
                fz_rect r = JM_rect_from_py(rect);
                if (!fz_is_infinite_rect(r))
                {
                    w = r.x1 - r.x0;
                    h = r.y1 - r.y0;
                }
                if (w <= 0.0f || h <= 0.0f)
                        THROWMSG("invalid page size");
                fz_layout_document(gctx, self, w, h, fontsize);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s_makeBookmark(struct fz_document_s *self,int pno){
            if (!fz_is_document_reflowable(gctx, self)) return_none;
            int n = pno, cp = fz_count_pages(gctx, self);
            while(n < 0) n += cp;
            long long mark = (long long) fz_make_bookmark(gctx, self, n);
            return PyLong_FromLongLong(mark);
        }

#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif

SWIGINTERN PyObject *fz_document_s_findBookmark(struct fz_document_s *self,long long bookmark){
            int i = -1;
            if (fz_is_document_reflowable(gctx, self))
            {
                fz_bookmark m = (fz_bookmark) bookmark;
                i = fz_lookup_bookmark(gctx, self, m);
            }
            return Py_BuildValue("i", i);
        }
SWIGINTERN PyObject *fz_document_s_isReflowable(struct fz_document_s *self){
            return JM_BOOL(fz_is_document_reflowable(gctx, self));
        }
SWIGINTERN PyObject *fz_document_s__deleteObject(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG("xref out of range");
                pdf_delete_object(gctx, pdf, xref);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__getPDFroot(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int xref = 0;
            if (!pdf) return Py_BuildValue("i", xref);
            fz_try(gctx)
            {
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(Root));
                xref = pdf_to_num(gctx, root);
            }
            fz_catch(gctx) {;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *fz_document_s__getPDFfileid(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return_none;
            PyObject *idlist = PyList_New(0);
            fz_buffer *buffer = NULL;
            char *hex;
            pdf_obj *o;
            int n, i, len;
            PyObject *bytes;
            fz_try(gctx)
            {
                pdf_obj *identity = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(ID));
                if (identity)
                {
                    n = pdf_array_len(gctx, identity);
                    for (i = 0; i < n; i++)
                    {
                        o = pdf_array_get(gctx, identity, i);
                        len = pdf_to_str_len(gctx, o);
                        buffer = fz_new_buffer(gctx, 2 * len);
                        fz_buffer_storage(gctx, buffer, &hex);
                        hexlify(len, (unsigned char *) pdf_to_text_string(gctx, o), (unsigned char *) hex);
                        LIST_APPEND_DROP(idlist, JM_UnicodeFromStr(hex));
                        Py_CLEAR(bytes);
                        fz_drop_buffer(gctx, buffer);
                        buffer = NULL;
                    }
                }
            }
            fz_catch(gctx) fz_drop_buffer(gctx, buffer);
            return idlist;
        }
SWIGINTERN PyObject *fz_document_s_isPDF(struct fz_document_s *self){
            if (pdf_specifics(gctx, self)) Py_RETURN_TRUE;
            else Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s__hasXrefStream(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_xref_streams) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s__hasXrefOldStyle(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_old_style_xrefs) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *fz_document_s_isDirty(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;
            return JM_BOOL(pdf_has_unsaved_changes(gctx, pdf));
        }
SWIGINTERN PyObject *fz_document_s_can_save_incrementally(struct fz_document_s *self){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);
            if (!pdf) Py_RETURN_FALSE; // gracefully handle non-PDF
            return JM_BOOL(pdf_can_be_saved_incrementally(gctx, pdf));
        }
SWIGINTERN PyObject *fz_document_s_authenticate(struct fz_document_s *self,char *password){
            return Py_BuildValue("i", fz_authenticate_password(gctx, self, (const char *) password));
        }
SWIGINTERN PyObject *fz_document_s_save(struct fz_document_s *self,char *filename,int garbage,int clean,int deflate,int incremental,int ascii,int expand,int linear,int pretty,int encryption,int permissions,char *owner_pw,char *user_pw){
            pdf_write_options opts = pdf_default_write_options;
            opts.do_incremental     = incremental;
            opts.do_ascii           = ascii;
            opts.do_compress        = deflate;
            opts.do_compress_images = deflate;
            opts.do_compress_fonts  = deflate;
            opts.do_decompress      = expand;
            opts.do_garbage         = garbage;
            opts.do_pretty          = pretty;
            opts.do_linear          = linear;
            opts.do_clean           = clean;
            opts.do_sanitize        = clean;
            opts.do_encrypt         = encryption;
            opts.permissions        = permissions;
            if (owner_pw)
            {
                memcpy(&opts.opwd_utf8, owner_pw, strlen(owner_pw)+1);
            }

            if (user_pw)
            {
                memcpy(&opts.upwd_utf8, user_pw, strlen(user_pw)+1);
            }

            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                JM_embedded_clean(gctx, pdf);
                pdf_save_document(gctx, pdf, filename, &opts);
                pdf->dirty = 0;
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s_write(struct fz_document_s *self,int garbage,int clean,int deflate,int ascii,int expand,int linear,int pretty,int encryption,int permissions,char *owner_pw,char *user_pw){
            PyObject *r = NULL;
            fz_output *out = NULL;
            fz_buffer *res = NULL;
            pdf_write_options opts = pdf_default_write_options;
            opts.do_incremental     = 0;
            opts.do_ascii           = ascii;
            opts.do_compress        = deflate;
            opts.do_compress_images = deflate;
            opts.do_compress_fonts  = deflate;
            opts.do_decompress      = expand;
            opts.do_garbage         = garbage;
            opts.do_linear          = linear;
            opts.do_clean           = clean;
            opts.do_sanitize        = clean;
            opts.do_pretty          = pretty;
            opts.do_encrypt         = encryption;
            opts.permissions        = permissions;
            if (owner_pw)
            {
                memcpy(&opts.opwd_utf8, owner_pw, strlen(owner_pw)+1);
            }

            if (user_pw)
            {
                memcpy(&opts.upwd_utf8, user_pw, strlen(user_pw)+1);
            }

            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_var(out);
            fz_var(r);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (fz_count_pages(gctx, self) < 1)
                    THROWMSG("cannot save with zero pages");
                JM_embedded_clean(gctx, pdf);
                res = fz_new_buffer(gctx, 8192);
                out = fz_new_output_with_buffer(gctx, res);
                pdf_write_document(gctx, pdf, out, &opts);
                r = JM_BinFromBuffer(gctx, res);
                pdf->dirty = 0;
            }
            fz_always(gctx)
                {
                    fz_drop_buffer(gctx, res);
                    fz_drop_output(gctx, out);
                }
            fz_catch(gctx)
            {
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *fz_document_s_insertPDF(struct fz_document_s *self,struct fz_document_s *docsrc,int from_page,int to_page,int start_at,int rotate,int links,int annots){
            pdf_document *pdfout = pdf_specifics(gctx, self);
            pdf_document *pdfsrc = pdf_specifics(gctx, docsrc);
            int outCount = fz_count_pages(gctx, self);
            int srcCount = fz_count_pages(gctx, docsrc);

            // local copies of page numbers
            int fp = from_page, tp = to_page, sa = start_at;

            // normalize page numbers
            fp = MAX(fp, 0);                // -1 = first page
            fp = MIN(fp, srcCount - 1);     // but do not exceed last page

            if (tp < 0) tp = srcCount - 1;  // -1 = last page
            tp = MIN(tp, srcCount - 1);     // but do not exceed last page

            if (sa < 0) sa = outCount;      // -1 = behind last page
            sa = MIN(sa, outCount);         // but that is also the limit

            fz_try(gctx)
            {
                if (!pdfout || !pdfsrc) THROWMSG("source or target not a PDF");
                merge_range(gctx, pdfout, pdfsrc, fp, tp, sa, rotate, links, annots);
            }
            fz_catch(gctx) return NULL;
            pdfout->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__newPage(struct fz_document_s *self,int pno,float width,float height){
            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_rect mediabox = fz_unit_rect;
            mediabox.x1 = width;
            mediabox.y1 = height;
            pdf_obj *resources = NULL, *page_obj = NULL;
            fz_buffer *contents = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (pno < -1) THROWMSG("bad page number(s)");
                // create /Resources and /Contents objects
                resources = pdf_add_object_drop(gctx, pdf, pdf_new_dict(gctx, pdf, 1));
                page_obj = pdf_add_page(gctx, pdf, mediabox, 0, resources, contents);
                pdf_insert_page(gctx, pdf, pno, page_obj);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, contents);
                pdf_drop_obj(gctx, page_obj);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s_select(struct fz_document_s *self,PyObject *pyliste){
            // preparatory stuff:
            // (1) get underlying pdf document,
            // (2) transform Python list into integer array

            pdf_document *pdf = pdf_specifics(gctx, self);
            fz_try(gctx)
            {
                // call retainpages (code copy of fz_clean_file.c)
                globals glo = {0};
                glo.ctx = gctx;
                glo.doc = pdf;
                retainpages(gctx, &glo, pyliste);
                if (pdf->rev_page_map)
                {
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__deletePage(struct fz_document_s *self,int pno){
            fz_try(gctx)
            {
                pdf_document *pdf = pdf_specifics(gctx, self);
                int count = fz_count_pages(gctx, self);
                pdf_delete_page(gctx, pdf, pno);
                if (pdf->rev_page_map)
                {
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s_permissions(struct fz_document_s *self){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, self);

            // for PDF return result of standard function
            if (pdf)
                return Py_BuildValue("i", pdf_document_permissions(gctx, pdf));

            // otherwise simulate the PDF return value
            int perm = (int) 0xFFFFFFFC;  // all permissions granted
            // now switch off where needed
            if (!fz_has_permission(gctx, self, FZ_PERMISSION_PRINT))
                perm = perm ^ PDF_PERM_PRINT;
            if (!fz_has_permission(gctx, self, FZ_PERMISSION_EDIT))
                perm = perm ^ PDF_PERM_MODIFY;
            if (!fz_has_permission(gctx, self, FZ_PERMISSION_COPY))
                perm = perm ^ PDF_PERM_COPY;
            if (!fz_has_permission(gctx, self, FZ_PERMISSION_ANNOTATE))
                perm = perm ^ PDF_PERM_ANNOTATE;
            return Py_BuildValue("i", perm);
        }
SWIGINTERN PyObject *fz_document_s__getCharWidths(struct fz_document_s *self,int xref,char *bfname,char *ext,int ordering,int limit,int idx){
            pdf_document *pdf = pdf_specifics(gctx, self);
            PyObject *wlist = NULL;
            int i, glyph, mylimit;
            mylimit = limit;
            if (mylimit < 256) mylimit = 256;
            int cwlen = 0;
            int lang = 0;
            const char *data;
            int size, index;
            fz_font *font = NULL, *fb_font= NULL;
            fz_buffer *buf = NULL;

            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (ordering >= 0)
                {
                    data = fz_lookup_cjk_font(gctx, ordering, &size, &index);
                    font = fz_new_font_from_memory(gctx, NULL, data, size, index, 0);
                    goto weiter;
                }
                data = fz_lookup_base14_font(gctx, bfname, &size);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, bfname, data, size, 0, 0);
                    goto weiter;
                }
                buf = JM_get_fontbuffer(gctx, pdf, xref);
                if (!buf)
                {
                    fz_throw(gctx, FZ_ERROR_GENERIC, "font at xref %d is not supported", xref);
                }
                font = fz_new_font_from_buffer(gctx, NULL, buf, idx, 0);

                weiter:;
                wlist = PyList_New(0);
                float adv;
                for (i = 0; i < mylimit; i++)
                {
                    glyph = fz_encode_character(gctx, font, i);
                    adv = fz_advance_glyph(gctx, font, glyph, 0);
                    if (ordering >= 0)
                        glyph = i;


                    if (glyph > 0)
                    {
                        LIST_APPEND_DROP(wlist, Py_BuildValue("if", glyph, adv));
                    }
                    else
                    {
                        LIST_APPEND_DROP(wlist, Py_BuildValue("if", glyph, 0.0));
                    }
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, buf);
                fz_drop_font(gctx, font);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return wlist;
        }
SWIGINTERN PyObject *fz_document_s__getPageObjNumber(struct fz_document_s *self,int pno){
            int pageCount = fz_count_pages(gctx, self);
            pdf_document *pdf = pdf_specifics(gctx, self);
            int n = pno;
            while (n < 0) n += pageCount;
            pdf_obj *pageref = NULL;
            fz_var(pageref);
            fz_try(gctx)
            {
                if (n >= pageCount) THROWMSG("bad page number(s)");
                assert_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
            }
            fz_catch(gctx) return NULL;

            return Py_BuildValue("ii", pdf_to_num(gctx, pageref),
                                       pdf_to_gen(gctx, pageref));
        }
SWIGINTERN PyObject *fz_document_s__getPageInfo(struct fz_document_s *self,int pno,int what){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int pageCount = fz_count_pages(gctx, self);
            pdf_obj *pageref, *rsrc;
            PyObject *liste = NULL;  // returned object
            int n = pno;  // pno < 0 is allowed
            while (n < 0) n += pageCount;  // make it non-negative
            fz_var(liste);
            fz_try(gctx)
            {
                if (n >= pageCount) THROWMSG("bad page number(s)");
                assert_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
                rsrc = pdf_dict_get_inheritable(gctx, pageref, PDF_NAME(Resources));
                if (!pageref || !rsrc) THROWMSG("cannot retrieve page info");
                liste = PyList_New(0);
                JM_scan_resources(gctx, pdf, rsrc, liste, what, 0);
            }
            fz_catch(gctx)
            {
                Py_XDECREF(liste);
                return NULL;
            }
            return liste;
        }
SWIGINTERN PyObject *fz_document_s_extractFont(struct fz_document_s *self,int xref,int info_only){
            pdf_document *pdf = pdf_specifics(gctx, self);

            fz_try(gctx) assert_PDF(pdf);
            fz_catch(gctx) return NULL;

            fz_buffer *buffer = NULL;
            pdf_obj *obj, *basefont, *bname;
            PyObject *bytes = PyBytes_FromString("");
            char *ext = NULL;
            char *fontname = NULL;
            PyObject *nulltuple = Py_BuildValue("sssO", "", "", "", bytes);
            PyObject *tuple;
            Py_ssize_t len = 0;
            fz_try(gctx)
            {
                obj = pdf_load_object(gctx, pdf, xref);
                pdf_obj *type = pdf_dict_get(gctx, obj, PDF_NAME(Type));
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));
                if(pdf_name_eq(gctx, type, PDF_NAME(Font)) &&
                   strncmp(pdf_to_name(gctx, subtype), "CIDFontType", 11) != 0)
                {
                    basefont = pdf_dict_get(gctx, obj, PDF_NAME(BaseFont));
                    if (!basefont || pdf_is_null(gctx, basefont))
                        bname = pdf_dict_get(gctx, obj, PDF_NAME(Name));
                    else
                        bname = basefont;
                    ext = JM_get_fontextension(gctx, pdf, xref);
                    if (strcmp(ext, "n/a") != 0 && !info_only)
                    {
                        buffer = JM_get_fontbuffer(gctx, pdf, xref);
                        bytes = JM_BinFromBuffer(gctx, buffer);
                        fz_drop_buffer(gctx, buffer);
                    }
                    tuple = PyTuple_New(4);
                    PyTuple_SET_ITEM(tuple, 0, JM_EscapeStrFromStr(pdf_to_name(gctx, bname)));
                    PyTuple_SET_ITEM(tuple, 1, JM_UnicodeFromStr(ext));
                    PyTuple_SET_ITEM(tuple, 2, JM_UnicodeFromStr(pdf_to_name(gctx, subtype)));
                    PyTuple_SET_ITEM(tuple, 3, bytes);
                }
                else
                {
                    tuple = nulltuple;
                }
            }
            fz_always(gctx)
            {
                JM_PyErr_Clear;
                JM_Free(fontname);
            }

            fz_catch(gctx)
            {
                tuple = Py_BuildValue("sssO", "invalid-name", "", "", bytes);
            }
            return tuple;
        }
SWIGINTERN PyObject *fz_document_s_extractImage(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            pdf_obj *obj = NULL;
            fz_buffer *res = NULL;
            fz_image *img = NULL;
            PyObject *rc = NULL;
            const char *ext = NULL;
            const char *cs_name = NULL;
            int img_type, xres, yres, colorspace;
            int smask = 0, width, height, bpc;
            fz_var(img);
            fz_var(res);
            fz_var(obj);

            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG("xref out of range");

                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));

                if (!pdf_name_eq(gctx, subtype, PDF_NAME(Image)))
                    THROWMSG("xref not an image");

                pdf_obj *o = pdf_dict_get(gctx, obj, PDF_NAME(SMask));
                if (o) smask = pdf_to_num(gctx, o);

                res = pdf_load_raw_stream(gctx, obj);
                unsigned char *c = NULL;
                fz_buffer_storage(gctx, res, &c);
                img_type = fz_recognize_image_format(gctx, c);

                if (img_type != FZ_IMAGE_UNKNOWN)
                {
                    img = fz_new_image_from_buffer(gctx, res);
                    ext = JM_image_extension(img_type);
                }
                else
                {
                    fz_drop_buffer(gctx, res);
                    res = NULL;
                    img = pdf_load_image(gctx, pdf, obj);
                    res = fz_new_buffer_from_image_as_png(gctx, img,
                                fz_default_color_params);
                    ext = "png";
                }
                fz_image_resolution(img, &xres, &yres);
                width = img->w;
                height = img->h;
                colorspace = img->n;
                bpc = img->bpc;
                cs_name = fz_colorspace_name(gctx, img->colorspace);

                rc = PyDict_New();
                DICT_SETITEM_DROP(rc, dictkey_ext,
                                    JM_UnicodeFromStr(ext));
                DICT_SETITEM_DROP(rc, dictkey_smask,
                                    Py_BuildValue("i", smask));
                DICT_SETITEM_DROP(rc, dictkey_width,
                                    Py_BuildValue("i", width));
                DICT_SETITEM_DROP(rc, dictkey_height,
                                    Py_BuildValue("i", height));
                DICT_SETITEM_DROP(rc, dictkey_colorspace,
                                    Py_BuildValue("i", colorspace));
                DICT_SETITEM_DROP(rc, dictkey_bpc,
                                    Py_BuildValue("i", bpc));
                DICT_SETITEM_DROP(rc, dictkey_xres,
                                    Py_BuildValue("i", xres));
                DICT_SETITEM_DROP(rc, dictkey_yres,
                                    Py_BuildValue("i", yres));
                DICT_SETITEM_DROP(rc, dictkey_cs_name,
                                    JM_UnicodeFromStr(cs_name));
                DICT_SETITEM_DROP(rc, dictkey_image,
                                    JM_BinFromBuffer(gctx, res));
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }

            fz_catch(gctx)
            {
                Py_CLEAR(rc);
                return_none;
            }
            if (!rc)
                return_none;
            return rc;
        }
SWIGINTERN PyObject *fz_document_s__delToC(struct fz_document_s *self){
            PyObject *xrefs = PyList_New(0);          // create Python list
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return xrefs;                   // not a pdf

            pdf_obj *root, *olroot, *first;
            int xref_count, olroot_xref, i, xref;

            // get the main root
            root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
            // get the outline root
            olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
            if (!olroot) return xrefs;                // no outlines or some problem

            first = pdf_dict_get(gctx, olroot, PDF_NAME(First)); // first outline

            xrefs = JM_outline_xrefs(gctx, first, xrefs);
            xref_count = (int) PyList_Size(xrefs);

            olroot_xref = pdf_to_num(gctx, olroot);        // delete OL root
            pdf_delete_object(gctx, pdf, olroot_xref);     // delete OL root
            pdf_dict_del(gctx, root, PDF_NAME(Outlines));  // delete OL root

            for (i = 0; i < xref_count; i++)
            {
                xref = (int) PyInt_AsLong(PyList_GetItem(xrefs, i));
                pdf_delete_object(gctx, pdf, xref);      // delete outline item
            }
            LIST_APPEND_DROP(xrefs, Py_BuildValue("i", olroot_xref));
            pdf->dirty = 1;
            return xrefs;
        }
SWIGINTERN PyObject *fz_document_s_isStream(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;  // not a PDF
            return JM_BOOL(pdf_obj_num_is_stream(gctx, pdf, xref));
        }
SWIGINTERN PyObject *fz_document_s_getSigFlags(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return Py_BuildValue("i", -1);  // not a PDF
            size_t sigflag = 0;
            fz_try(gctx)
            {
                pdf_obj *sigflags = pdf_dict_getl(gctx,
                                                  pdf_trailer(gctx, pdf),
                                                  PDF_NAME(Root),
                                                  PDF_NAME(AcroForm),
                                                  PDF_NAME(SigFlags),
                                                  NULL);
                if (sigflags)
                {
                    sigflag = (size_t) pdf_to_int(gctx, sigflags);
                }
            }
            fz_catch(gctx) return Py_BuildValue("i", -1);  // any problem
            return Py_BuildValue("I", sigflag);
        }
SWIGINTERN PyObject *fz_document_s_isFormPDF(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) Py_RETURN_FALSE;  // not a PDF
            int count = 0;  // init count
            fz_try(gctx)
            {
                pdf_obj *fields = pdf_dict_getl(gctx,
                                                pdf_trailer(gctx, pdf),
                                                PDF_NAME(Root),
                                                PDF_NAME(AcroForm),
                                                PDF_NAME(Fields),
                                                NULL);
                if (pdf_is_array(gctx, fields))
                {
                    count = pdf_array_len(gctx, fields);
                };
            }
            fz_catch(gctx) Py_RETURN_FALSE;      // any problem yields false
            if (count)
            {
                return Py_BuildValue("i", count);
            }
            else
            {
                Py_RETURN_FALSE;
            }
        }
SWIGINTERN PyObject *fz_document_s_FormFonts(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return_none;           // not a PDF
            pdf_obj *fonts = NULL;
            PyObject *liste = PyList_New(0);
            fz_try(gctx)
            {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (fonts && pdf_is_dict(gctx, fonts))       // fonts exist
                {
                    int i, n = pdf_dict_len(gctx, fonts);
                    for (i = 0; i < n; i++)
                    {
                        pdf_obj *f = pdf_dict_get_key(gctx, fonts, i);
                        LIST_APPEND_DROP(liste, JM_UnicodeFromStr(pdf_to_name(gctx, f)));
                    }
                }
            }
            fz_catch(gctx) return_none;  // any problem yields None
            return liste;
        }
SWIGINTERN PyObject *fz_document_s__addFormFont(struct fz_document_s *self,char *name,char *font){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return_none;  // not a PDF
            pdf_obj *fonts = NULL;
            fz_try(gctx)
            {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root),
                             PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (!fonts || !pdf_is_dict(gctx, fonts))
                    THROWMSG("PDF has no form fonts yet");
                pdf_obj *k = pdf_new_name(gctx, (const char *) name);
                pdf_obj *v = JM_pdf_obj_from_str(gctx, pdf, font);
                pdf_dict_put(gctx, fonts, k, v);
            }
            fz_catch(gctx) NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__getOLRootNumber(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            pdf_obj *root, *olroot, *ind_obj;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                // get main root
                root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                // get outline root
                olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                if (!olroot)
                {
                    olroot = pdf_new_dict(gctx, pdf, 4);
                    pdf_dict_put(gctx, olroot, PDF_NAME(Type), PDF_NAME(Outlines));
                    ind_obj = pdf_add_object(gctx, pdf, olroot);
                    pdf_dict_put(gctx, root, PDF_NAME(Outlines), ind_obj);
                    olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                    pdf_drop_obj(gctx, ind_obj);
                    pdf->dirty = 1;
                }
            }
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", pdf_to_num(gctx, olroot));
        }
SWIGINTERN PyObject *fz_document_s__getNewXref(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); /* conv doc to pdf*/
            fz_try(gctx) assert_PDF(pdf);
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return Py_BuildValue("i", pdf_create_object(gctx, pdf));
        }
SWIGINTERN PyObject *fz_document_s__getXrefLength(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int xreflen = 0;
            if (pdf) xreflen = pdf_xref_len(gctx, pdf);
            return Py_BuildValue("i", xreflen);
        }
SWIGINTERN PyObject *fz_document_s__getXmlMetadataXref(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); // get pdf document
            pdf_obj *xml;
            int xref = 0;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) THROWMSG("could not load root object");
                xml = pdf_dict_gets(gctx, root, "Metadata");
                if (xml) xref = pdf_to_num(gctx, xml);
            }
            fz_catch(gctx) {;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *fz_document_s__delXmlMetadata(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self); // get pdf document
            fz_try(gctx)
            {
                assert_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (root) pdf_dict_dels(gctx, root, "Metadata");
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__getXrefString(struct fz_document_s *self,int xref,int compressed,int ascii){
            pdf_document *pdf = pdf_specifics(gctx, self); // conv doc to pdf
            pdf_obj *obj = NULL;
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                obj = pdf_load_object(gctx, pdf, xref);
                pdf_print_obj(gctx, out, pdf_resolve_indirect(gctx, obj),
                              compressed, ascii);
                text = JM_EscapeStrFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                pdf_drop_obj(gctx, obj);
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
                PyErr_Clear();
            }
            fz_catch(gctx) return NULL;
            return text;
        }
SWIGINTERN PyObject *fz_document_s__getTrailerString(struct fz_document_s *self,int compressed,int ascii){
            pdf_document *pdf = pdf_specifics(gctx, self); // conv doc to pdf
            if (!pdf) return_none;
            pdf_obj *obj = NULL;
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_try(gctx)
            {
                obj = pdf_trailer(gctx, pdf);
                if (obj)
                {
                    res = fz_new_buffer(gctx, 1024);
                    out = fz_new_output_with_buffer(gctx, res);
                    pdf_print_obj(gctx, out, obj, compressed, ascii);
                    text = JM_EscapeStrFromBuffer(gctx, res);
                }
                else text = Py_None;
            }
            fz_always(gctx)
            {
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            return text;
        }
SWIGINTERN PyObject *fz_document_s__getXrefStreamRaw(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            PyObject *r = Py_None;
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (pdf_is_stream(gctx, obj))
                {
                    res = pdf_load_raw_stream_number(gctx, pdf, xref);
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
            {
                Py_CLEAR(r);
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *fz_document_s__getXrefStream(struct fz_document_s *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, self);
            PyObject *r = Py_None;
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (pdf_is_stream(gctx, obj))
                {
                    res = pdf_load_stream_number(gctx, pdf, xref);
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
            {
                Py_CLEAR(r);
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *fz_document_s__updateObject(struct fz_document_s *self,int xref,char *text,struct fz_page_s *page){
            pdf_obj *new_obj;
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                // create new object with passed-in string
                new_obj = JM_pdf_obj_from_str(gctx, pdf, text);
                pdf_update_object(gctx, pdf, xref, new_obj);
                pdf_drop_obj(gctx, new_obj);
                if (page)
                    JM_refresh_link_table(gctx, pdf_page_from_fz_page(gctx, page));
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__updateStream(struct fz_document_s *self,int xref,PyObject *stream,int new){
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                // get the object
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (!new && !pdf_is_stream(gctx, obj))
                    THROWMSG("xref not a stream object");
                res = JM_BufferFromBytes(gctx, stream);
                if (!res) THROWMSG("bad type: 'stream'");
                JM_update_stream(gctx, pdf, obj, res, 1);

            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__setMetadata(struct fz_document_s *self,char *text){
            pdf_obj *info, *new_info, *new_info_ind;
            int info_num = 0;               // will contain xref no of info object
            pdf_document *pdf = pdf_specifics(gctx, self);     // get pdf doc
            fz_try(gctx) {
                assert_PDF(pdf);
                // create new /Info object based on passed-in string
                new_info = JM_pdf_obj_from_str(gctx, pdf, text);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            // replace existing /Info object
            info = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Info));
            if (info)
            {
                info_num = pdf_to_num(gctx, info);    // get xref no of old info
                pdf_update_object(gctx, pdf, info_num, new_info);  // insert new
                pdf_drop_obj(gctx, new_info);
                return_none;
            }
            // create new indirect object from /Info object
            new_info_ind = pdf_add_object(gctx, pdf, new_info);
            // put this in the trailer dictionary
            pdf_dict_put_drop(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Info), new_info_ind);
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__make_page_map(struct fz_document_s *self){
            pdf_document *pdf = pdf_specifics(gctx, self);
            if (!pdf) return_none;
            fz_try(gctx)
            {
                pdf_drop_page_tree(gctx, pdf);
                pdf_load_page_tree(gctx, pdf);
            }
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", pdf->rev_page_count);
        }
SWIGINTERN PyObject *fz_document_s_fullcopyPage(struct fz_document_s *self,int pno,int to){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int pageCount = pdf_count_pages(gctx, pdf);
            fz_buffer *res = NULL, *nres=NULL;
            pdf_obj *page2 = NULL;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                if (!INRANGE(pno, 0, pageCount - 1) ||
                    !INRANGE(to, -1, pageCount - 1))
                    THROWMSG("bad page number(s)");

                pdf_obj *page1 = pdf_resolve_indirect(gctx,
                                 pdf_lookup_page_obj(gctx, pdf, pno));

                pdf_obj *page2 = pdf_deep_copy_obj(gctx, page1);

                // read the old contents stream(s)
                res = JM_read_contents(gctx, page1);

                // create new /Contents object for page2
                if (res)
                {
                    pdf_obj *contents = pdf_add_stream(gctx, pdf,
                               fz_new_buffer_from_copied_data(gctx, "  ", 1), NULL, 0);
                    JM_update_stream(gctx, pdf, contents, res, 1);
                    pdf_dict_put_drop(gctx, page2, PDF_NAME(Contents), contents);
                }

                // now insert target page, making sure it is an indirect object
                int xref = pdf_create_object(gctx, pdf);  // get new xref
                pdf_update_object(gctx, pdf, xref, page2);  // store new page
                pdf_drop_obj(gctx, page2);  // give up this object for now

                page2 = pdf_new_indirect(gctx, pdf, xref, 0);  // reread object
                pdf_insert_page(gctx, pdf, to, page2);  // and store the page
                pdf_drop_obj(gctx, page2);
            }
            fz_always(gctx)
            {
                pdf_drop_page_tree(gctx, pdf);
                fz_drop_buffer(gctx, res);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_document_s__move_copy_page(struct fz_document_s *self,int pno,int nb,int before,int copy){
            pdf_document *pdf = pdf_specifics(gctx, self);
            int i1, i2, pos, count, same = 0;
            pdf_obj *parent1 = NULL, *parent2 = NULL, *parent = NULL;
            pdf_obj *kids1, *kids2;
            fz_try(gctx)
            {
                assert_PDF(pdf);
                // get the two page objects -----------------------------------
                // locate the /Kids arrays and indices in each
                pdf_obj *page1 = pdf_lookup_page_loc(gctx, pdf, pno, &parent1, &i1);
                kids1 = pdf_dict_get(gctx, parent1, PDF_NAME(Kids));

                pdf_obj *page2 = pdf_lookup_page_loc(gctx, pdf, nb, &parent2, &i2);
                kids2 = pdf_dict_get(gctx, parent2, PDF_NAME(Kids));

                if (before)  // calc index of source page in target /Kids
                    pos = i2;
                else
                    pos = i2 + 1;

                // same /Kids array? ------------------------------------------
                same = pdf_objcmp(gctx, kids1, kids2);

                // put source page in target /Kids array ----------------------
                if (!copy && same != 0)  // update parent in page object
                {
                    pdf_dict_put(gctx, page1, PDF_NAME(Parent), parent2);
                }
                pdf_array_insert(gctx, kids2, page1, pos);

                if (same != 0) // different /Kids arrays ----------------------
                {
                    parent = parent2;
                    while (parent)  // increase /Count objects in parents
                    {
                        count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                        pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count + 1);
                        parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                    }
                    if (!copy)  // delete original item
                    {
                        pdf_array_delete(gctx, kids1, i1);
                        parent = parent1;
                        while (parent) // decrease /Count objects in parents
                        {
                            count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                            pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count - 1);
                            parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                        }
                    }
                }
                else // same /Kids array --------------------------------------
                {
                    if (copy) // source page is copied
                    {
                        parent = parent2;
                        while (parent) // increase /Count object in parents
                        {
                            count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                            pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count + 1);
                            parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                        }
                    }
                    else
                    {
                        if (i1 < pos)
                            pdf_array_delete(gctx, kids1, i1);
                        else
                            pdf_array_delete(gctx, kids1, i1 + 1);
                    }
                }
                if (pdf->rev_page_map)  // page map no longer valid: drop it
                {
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN void delete_fz_page_s(struct fz_page_s *self){
            DEBUGMSG1("page");
            fz_drop_page(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_page_s_bound(struct fz_page_s *self){
            fz_rect rect = fz_bound_page(gctx, self);
            return JM_py_from_rect(rect);
        }
SWIGINTERN PyObject *fz_page_s_run(struct fz_page_s *self,struct DeviceWrapper *dw,PyObject *m){
            fz_try(gctx) fz_run_page(gctx, self, dw->device, JM_matrix_from_py(m), NULL);
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN struct fz_stext_page_s *fz_page_s_getTextPage(struct fz_page_s *self,int flags){
            fz_stext_page *textpage=NULL;
            fz_try(gctx)
            {
                textpage = JM_new_stext_page_from_page(gctx, self, flags);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return textpage;
        }
SWIGINTERN PyObject *fz_page_s_getSVGimage(struct fz_page_s *self,PyObject *matrix){
            fz_rect mediabox = fz_bound_page(gctx, self);
            fz_device *dev = NULL;
            fz_buffer *res = NULL;
            PyObject *text = NULL;
            fz_matrix ctm = JM_matrix_from_py(matrix);
            fz_output *out = NULL;
            fz_separations *seps = NULL;
            fz_var(out);
            fz_var(dev);
            fz_var(res);
            fz_rect tbounds = mediabox;
            tbounds = fz_transform_rect(tbounds, ctm);

            fz_try(gctx)
            {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                dev = fz_new_svg_device(gctx, out,
                                        tbounds.x1-tbounds.x0,  // width
                                        tbounds.y1-tbounds.y0,  // height
                                        FZ_SVG_TEXT_AS_PATH, 1);
                fz_run_page(gctx, self, dev, ctm, NULL);
                fz_close_device(gctx, dev);
                text = JM_EscapeStrFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                fz_drop_device(gctx, dev);
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return text;
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addCaretAnnot(struct fz_page_s *self,PyObject *point){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_CARET);

                // TODO calculate de-rotated coordinates
                fz_point p = JM_point_from_py(point);
                fz_rect r = {p.x, p.y, p.x + 20, p.y + 20};
                pdf_set_annot_rect(gctx, annot, r);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addRedactAnnot(struct fz_page_s *self,PyObject *quad,PyObject *text,char const *fontname,float fontsize,int align,PyObject *fill,PyObject *text_color){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            float fcol[4] = { 1, 1, 1, 0};
            int nfcol = 0, i;
            char *otext = NULL;
            fz_try(gctx)
            {
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_REDACT);
                fz_quad q = JM_quad_from_py(quad);
                fz_rect r = fz_rect_from_quad(q);

                // TODO calculate de-rotated rect
                pdf_set_annot_rect(gctx, annot, r);
                if (EXISTS(fill))
                {
                    JM_color_FromSequence(fill, &nfcol, fcol);
                    pdf_obj *arr = pdf_new_array(gctx, page->doc, nfcol);
                    for (i = 0; i < nfcol; i++)
                    {
                        pdf_array_push_real(gctx, arr, fcol[i]);
                    }
                    pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(IC), arr);
                }
                if (EXISTS(text))
                {
                    otext = JM_Python_str_AsChar(text);
                }
                if (otext)
                {
                    pdf_dict_puts_drop(gctx, annot->obj, "OverlayText",
                                       pdf_new_text_string(gctx, otext));
                    pdf_dict_put_text_string(gctx,annot->obj, PDF_NAME(DA), fontname);
                    pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Q), (int64_t) align);
                }
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_always(gctx)
            {
                JM_Python_str_DelForPy3(otext);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addLineAnnot(struct fz_page_s *self,PyObject *p1,PyObject *p2){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_LINE);
                fz_point a = JM_point_from_py(p1);
                fz_point b = JM_point_from_py(p2);

                // TODO calculate de-rotated coordinates
                pdf_set_annot_line(gctx, annot, a, b);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addTextAnnot(struct fz_page_s *self,PyObject *point,char *text,char *icon){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_point pos = JM_point_from_py(point);
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_TEXT);
                fz_rect r = fz_make_rect(pos.x, pos.y, pos.x + 20, pos.y + 20);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_set_annot_contents(gctx, annot, text);
                if (!icon)
                {
                    pdf_set_annot_icon_name(gctx, annot, "Note");
                }
                else
                {
                    pdf_dict_put_name(gctx, annot->obj, PDF_NAME(Name), icon);
                }
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addInkAnnot(struct fz_page_s *self,PyObject *list){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            PyObject *p = NULL, *sublist = NULL;
            pdf_obj *inklist = NULL, *stroke = NULL;
            fz_matrix ctm, inv_ctm;
            double x, y;
            fz_point point;
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                if (!PySequence_Check(list)) THROWMSG("arg must be a sequence");
                pdf_page_transform(gctx, page, NULL, &ctm);
                inv_ctm = fz_invert_matrix(ctm);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_INK);
                Py_ssize_t i, j, n0 = PySequence_Size(list), n1;
                inklist = pdf_new_array(gctx, annot->page->doc, n0);
                for (j = 0; j < n0; j++)
                {
                    sublist = PySequence_ITEM(list, j);
                    n1 = PySequence_Size(sublist);
                    stroke = pdf_new_array(gctx, annot->page->doc, 2 * n1);
                    for (i = 0; i < n1; i++)
                    {
                        p = PySequence_ITEM(sublist, i);
                        if (!PySequence_Check(p) || PySequence_Size(p) != 2)
                            THROWMSG("3rd level entries must be pairs of floats");
                        x = PyFloat_AsDouble(PySequence_ITEM(p, 0));
                        if (PyErr_Occurred())
                            THROWMSG("invalid point coordinate");
                        y = PyFloat_AsDouble(PySequence_ITEM(p, 1));
                        if (PyErr_Occurred())
                            THROWMSG("invalid point coordinate");
                        Py_CLEAR(p);
                        point = fz_transform_point(fz_make_point(x, y), inv_ctm);
                        pdf_array_push_real(gctx, stroke, point.x);
                        pdf_array_push_real(gctx, stroke, point.y);
                    }
                    pdf_array_push_drop(gctx, inklist, stroke);
                    stroke = NULL;
                    Py_CLEAR(sublist);
                }
                pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(InkList), inklist);
                inklist = NULL;
                pdf_dirty_annot(gctx, annot);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx)
            {
                Py_CLEAR(p);
                Py_CLEAR(sublist);
                return NULL;
            }

            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addStampAnnot(struct fz_page_s *self,PyObject *rect,int stamp){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            pdf_obj *stamp_id[] = {PDF_NAME(Approved), PDF_NAME(AsIs),
                                   PDF_NAME(Confidential), PDF_NAME(Departmental),
                                   PDF_NAME(Experimental), PDF_NAME(Expired),
                                   PDF_NAME(Final), PDF_NAME(ForComment),
                                   PDF_NAME(ForPublicRelease), PDF_NAME(NotApproved),
                                   PDF_NAME(NotForPublicRelease), PDF_NAME(Sold),
                                   PDF_NAME(TopSecret), PDF_NAME(Draft)};
            int n = nelem(stamp_id);
            pdf_obj *name = stamp_id[0];
            fz_try(gctx)
            {
                assert_PDF(page);
                fz_rect r = JM_rect_from_py(rect);
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG("rect must be finite and not empty");
                if (INRANGE(stamp, 0, n-1))
                    name = stamp_id[stamp];
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_STAMP);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_dict_put(gctx, annot->obj, PDF_NAME(Name), name);
                pdf_set_annot_contents(gctx, annot,
                        pdf_dict_get_name(gctx, annot->obj, PDF_NAME(Name)));
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addFileAnnot(struct fz_page_s *self,PyObject *point,PyObject *buffer,char *filename,char *ufilename,char *desc,char *icon){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            char *data = NULL, *uf = ufilename, *d = desc;
            if (!ufilename) uf = filename;
            if (!desc) d = filename;
            size_t len = 0;
            fz_buffer *filebuf = NULL;
            fz_point p = JM_point_from_py(point);
            fz_rect r = {p.x, p.y, p.x + 20, p.y + 20};
            fz_var(annot);
            fz_try(gctx)
            {
                assert_PDF(page);
                filebuf = JM_BufferFromBytes(gctx, buffer);
                if (!filebuf) THROWMSG("bad type: 'buffer'");
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_FILEATTACHMENT);
                pdf_set_annot_rect(gctx, annot, r);

                if (!icon)
                {
                    pdf_set_annot_icon_name(gctx, annot, "PushPin");
                }
                else
                {
                    pdf_dict_put_name(gctx, annot->obj, PDF_NAME(Name), icon);
                }

                pdf_obj *val = JM_embed_file(gctx, page->doc, filebuf,
                                             filename, uf, d, 1);
                pdf_dict_put(gctx, annot->obj, PDF_NAME(FS), val);
                pdf_dict_put_text_string(gctx, annot->obj, PDF_NAME(Contents), filename);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s__add_text_marker(struct fz_page_s *self,PyObject *quads,int annot_type){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                annot = pdf_create_annot(gctx, page, annot_type);
                Py_ssize_t i, len = PySequence_Size(quads);
                for (i = 0; i < len; i++)
                {
                    PyObject *val = PySequence_ITEM(quads, i);
                    fz_quad q = JM_quad_from_py(val);
                    Py_DECREF(val);
                    pdf_add_annot_quad_point(gctx, annot, q);
                }
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s__add_square_or_circle(struct fz_page_s *self,PyObject *rect,int annot_type){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                fz_rect r = JM_rect_from_py(rect);
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG("rect must be finite and not empty");
                annot = pdf_create_annot(gctx, page, annot_type);
                pdf_set_annot_rect(gctx, annot, r);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s__add_multiline(struct fz_page_s *self,PyObject *points,int annot_type){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                Py_ssize_t i, n = PySequence_Size(points);
                if (n < 2) THROWMSG("bad list of points");
                annot = pdf_create_annot(gctx, page, annot_type);
                for (i = 0; i < n; i++)
                {
                    PyObject *p = PySequence_ITEM(points, i);
                    if (PySequence_Size(p) != 2)
                    {
                        Py_DECREF(p);
                        THROWMSG("bad list of points");
                    }
                    fz_point point = JM_point_from_py(p);
                    Py_DECREF(p);
                    pdf_add_annot_vertex(gctx, annot, point);
                }

                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_addFreetextAnnot(struct fz_page_s *self,PyObject *rect,char *text,float fontsize,char *fontname,PyObject *text_color,PyObject *fill_color,int rotate){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            float fcol[4] = {1, 1, 1, 1};    // fill color: white
            int nfcol = 0;
            JM_color_FromSequence(fill_color, &nfcol, fcol);
            float tcol[4] = {0, 0, 0, 0}; // std. text color: black
            int ntcol = 0;
            JM_color_FromSequence(text_color, &ntcol, tcol);
            fz_rect r = JM_rect_from_py(rect);
            pdf_annot *annot = NULL;
            fz_try(gctx)
            {
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG("rect must be finite and not empty");
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_FREE_TEXT);
                pdf_set_annot_contents(gctx, annot, text);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rotate);

                if (fill_color)
                {
                    pdf_set_annot_color(gctx, annot, nfcol, fcol);
                }

                // insert the default appearance string
                JM_make_annot_DA(gctx, annot, ntcol, tcol, fontname, fontsize);
                JM_add_annot_id(gctx, annot, "fitzannot");
                pdf_update_annot(gctx, annot);
            }
            fz_always(gctx) {;}
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_load_annot(struct fz_page_s *self,char *name){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            annot = JM_get_annot_by_name(gctx, page, name);
            return annot;
        }
SWIGINTERN PyObject *fz_page_s_annot_names(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page)
            {
                return_none;
            }
            return JM_get_annot_id_list(gctx, page);
        }
SWIGINTERN struct pdf_annot_s *fz_page_s__addWidget(struct fz_page_s *self,PyObject *Widget){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf = page->doc;
            pdf_annot *annot = NULL;
            pdf_widget *widget = NULL;
            fz_var(annot);
            fz_try(gctx)
            {
                //-------------------------------------------------------------
                // create the widget - only need type and field name for this
                //-------------------------------------------------------------
                int field_type = (int) PyInt_AsLong(PyObject_GetAttrString(Widget,
                                                    "field_type"));
                char *field_name = JM_Python_str_AsChar(PyObject_GetAttrString(Widget,
                                                        "field_name"));
                widget = JM_create_widget(gctx, pdf, page, field_type, field_name);
                JM_Python_str_DelForPy3(field_name);
                JM_PyErr_Clear;
                annot = (pdf_annot *) widget;
                JM_add_annot_id(gctx, annot, "fitzwidget");
            }
            fz_always(gctx) JM_PyErr_Clear;
            fz_catch(gctx) return NULL;
            return pdf_keep_annot(gctx, annot);
        }
SWIGINTERN struct fz_display_list_s *fz_page_s_getDisplayList(struct fz_page_s *self,int annots){
            fz_display_list *dl = NULL;
            fz_try(gctx)
            {
                if (annots)
                {
                    dl = fz_new_display_list_from_page(gctx, self);
                }
                else
                {
                    dl = fz_new_display_list_from_page_contents(gctx, self);
                }
            }
            fz_catch(gctx) return NULL;
            return dl;
        }
SWIGINTERN PyObject *fz_page_s__apply_redactions(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            int success = 0;
            pdf_redact_options opts = { 1 };  // never use black-boxing
            fz_try(gctx)
            {
                assert_PDF(page);
                success = pdf_redact_page(gctx, page->doc, page, &opts);
            }
            fz_catch(gctx) return NULL;
            return JM_BOOL(success);
        }
SWIGINTERN struct fz_pixmap_s *fz_page_s__makePixmap(struct fz_page_s *self,struct fz_document_s *doc,PyObject *ctm,struct fz_colorspace_s *cs,int alpha,int annots,PyObject *clip){
            fz_pixmap *pix = NULL;
            fz_try(gctx)
            {
                pix = JM_pixmap_from_page(gctx, doc, self, ctm,
                                          cs, alpha, annots, clip);
            }
            fz_catch(gctx) return NULL;
            return pix;
        }
SWIGINTERN PyObject *fz_page_s_insertString(struct fz_page_s *self,PyObject *point,PyObject *text,float fontsize,char *fontname,char *fontfile,PyObject *fontbuffer,PyObject *color,char *language,int script,float opacity,int ordering,int overlay,int is_bold,int is_italic){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_text_language lang = fz_text_language_from_string(language);
            fz_text *text_obj = NULL;
            fz_device *dev = NULL;
            pdf_obj *resources = NULL;
            fz_buffer *contents = NULL;
            PyObject *result=NULL, *cont_string=NULL, *max_nums=NULL;
            int xref;
            fz_rect text_rect;
            fz_point last_point;
            fz_font *user_font = NULL;
            fz_try(gctx)
            {
                assert_PDF(page);
                user_font = JM_get_font(gctx, fontname, fontfile,
                                                 fontbuffer, script,
                                                 lang, ordering,
                                                 is_bold, is_italic);
                if (!user_font)
                    THROWMSG("Could not insert desired font.");
                fz_matrix ctm = fz_identity;
                pdf_page_transform(gctx, page, NULL, &ctm);
                fz_matrix ictm = fz_invert_matrix(ctm);
                fz_point p = fz_transform_point(JM_point_from_py(point), ictm);
                fz_matrix trm0 = {fontsize, 0, 0, fontsize, p.x, p.y};
                fz_matrix trm = trm0;
                text_rect.x0 = p.x;
                text_rect.y0 = p.y;
                text_rect.x1 = p.x;
                text_rect.y1 = p.y + fontsize;
                int wmode = 0;
                float alpha = 1;
                if (opacity >= 0 && opacity < 1)
                    alpha = opacity;
                int bidi_level = 0;
                fz_colorspace *colorspace;
                int ncol = 3;
                float dev_color[4] = {0,0,0,0};
                if (color) JM_color_FromSequence(color, &ncol, dev_color);
                if (ncol == 3) colorspace = fz_device_rgb(gctx);
                if (ncol == 4) colorspace = fz_device_cmyk(gctx);
                if (ncol == 1) colorspace = fz_device_gray(gctx);
                fz_rect mediabox = fz_bound_page(gctx, self);
                text_obj = fz_new_text(gctx);
                fz_bidi_direction markup_dir = FZ_BIDI_LTR;

                Py_ssize_t i, n = PySequence_Size(text);
                for (i = 0; i < n; i++)
                {
                    PyObject *line = PySequence_GetItem(text, i);
                    if (!line) continue;
                    char *c = JM_Python_str_AsChar(line);
                    Py_DECREF(line);
                    if (!c) continue;
                    trm = JM_show_string(gctx, text_obj,
                            user_font, trm, c, wmode, bidi_level,
                            markup_dir, lang, script);
                    JM_Python_str_DelForPy3(c);
                    last_point = fz_make_point(trm.e, trm.f);
                    text_rect = fz_include_point_in_rect(text_rect, last_point);
                    trm.e = p.x;
                    trm.f -= fontsize*1.2;
                }

                // let the pdf device write into dummy resources and content
                resources = pdf_new_dict(gctx, page->doc, 5);
                contents = fz_new_buffer(gctx, 1024);
                dev = pdf_new_pdf_device(gctx, page->doc, fz_identity, mediabox, resources, contents);
                fz_fill_text(gctx, dev, text_obj, trm0,
                    colorspace, dev_color, alpha, fz_default_color_params);
                fz_close_device(gctx, dev);

                // merge the created resources with the existing one
                max_nums = JM_merge_resources(gctx, page, resources);
                cont_string = JM_EscapeStrFromBuffer(gctx, contents);
                text_rect = fz_transform_rect(text_rect, ctm);
                last_point = fz_transform_point(last_point, ctm);
                result = Py_BuildValue("(ffff)(ff)OO", text_rect.x0,
                    text_rect.y0, text_rect.x1, text_rect.y1,
                    last_point.x, last_point.y, max_nums, cont_string);
                Py_DECREF(cont_string);
                Py_DECREF(max_nums);
            }
            fz_always(gctx)
            {
                fz_drop_device(gctx, dev);
                fz_drop_text(gctx, text_obj);
                pdf_drop_obj(gctx, resources);
                fz_drop_buffer(gctx, contents);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return result;
        }
SWIGINTERN PyObject *fz_page_s_setMediaBox(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(page);
                fz_rect mediabox = JM_rect_from_py(rect);
                if (fz_is_empty_rect(mediabox) || fz_is_infinite_rect(mediabox))
                {
                    THROWMSG("rect must be finite and not empty");
                }
                pdf_dict_put_rect(gctx, page->obj, PDF_NAME(MediaBox), mediabox);
                pdf_dict_put_rect(gctx, page->obj, PDF_NAME(CropBox), mediabox);
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_page_s_setCropBox(struct fz_page_s *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            fz_try(gctx)
            {
                assert_PDF(page);
                fz_rect mediabox = pdf_bound_page(gctx, page);
                pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(MediaBox));
                if (o) mediabox = pdf_to_rect(gctx, o);
                fz_rect cropbox = fz_empty_rect;
                fz_rect r = JM_rect_from_py(rect);
                cropbox.x0 = r.x0;
                cropbox.y0 = mediabox.y1 - r.y1;
                cropbox.x1 = r.x1;
                cropbox.y1 = mediabox.y1 - r.y0;
                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(CropBox),
                                  pdf_new_rect(gctx, page->doc, cropbox));
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return_none;
        }
SWIGINTERN struct fz_link_s *fz_page_s_loadLinks(struct fz_page_s *self){
            fz_link *l = NULL;
            fz_try(gctx) l = fz_load_links(gctx, self);
            fz_catch(gctx) return NULL;
            return l;
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_firstAnnot(struct fz_page_s *self){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (page)
            {
                annot = pdf_first_annot(gctx, page);
                if (annot) pdf_keep_annot(gctx, annot);
            }
            return annot;
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_firstWidget(struct fz_page_s *self){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (page)
            {
                annot = pdf_first_widget(gctx, page);
                if (annot) pdf_keep_annot(gctx, annot);
            }
            return annot;
        }
SWIGINTERN void fz_page_s_deleteLink(struct fz_page_s *self,PyObject *linkdict){
            if (!PyDict_Check(linkdict)) return; // have no dictionary
            fz_try(gctx)
            {
                pdf_page *page = pdf_page_from_fz_page(gctx, self);
                if (!page) goto finished;  // have no PDF
                int xref = (int) PyInt_AsLong(PyDict_GetItem(linkdict, dictkey_xref));
                if (xref < 1) goto finished;  // invalid xref
                pdf_obj *annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                if (!annots) goto finished;  // have no annotations
                int len = pdf_array_len(gctx, annots);
                int i, oxref = 0;
                for (i = 0; i < len; i++)
                {
                    oxref = pdf_to_num(gctx, pdf_array_get(gctx, annots, i));
                    if (xref == oxref) break;        // found xref in annotations
                }
                if (xref != oxref) goto finished;  // xref not in annotations
                pdf_array_delete(gctx, annots, i);   // delete entry in annotations
                pdf_delete_object(gctx, page->doc, xref);      // delete link object
                pdf_dict_put(gctx, page->obj, PDF_NAME(Annots), annots);
                JM_refresh_link_table(gctx, page);            // reload link / annot tables
                page->doc->dirty = 1;
                finished:;
            }
            fz_catch(gctx) {;}
        }
SWIGINTERN struct pdf_annot_s *fz_page_s_deleteAnnot(struct fz_page_s *self,struct pdf_annot_s *annot){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_annot *irt_annot = NULL;
            while (1)  // first loop through all /IRT annots and remove them
            {
                irt_annot = JM_find_annot_irt(gctx, annot);
                if (!irt_annot)  // no more there
                    break;
                JM_delete_annot(gctx, page, irt_annot);
            }
            pdf_annot *nextannot = pdf_next_annot(gctx, annot);  // store next
            JM_delete_annot(gctx, page, annot);
            if (nextannot)
            {
                nextannot = pdf_keep_annot(gctx, nextannot);
            }
            page->doc->dirty = 1;
            return nextannot;
        }
SWIGINTERN PyObject *fz_page_s_MediaBox(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page)
                return JM_py_from_rect(fz_bound_page(gctx, self));
            return JM_py_from_rect(JM_mediabox(gctx, page));
        }
SWIGINTERN PyObject *fz_page_s_CropBox(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page)
                return JM_py_from_rect(fz_bound_page(gctx, self));
            return JM_py_from_rect(JM_cropbox(gctx, page));
        }
SWIGINTERN int fz_page_s_rotation(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return -1;
            return JM_page_rotation(gctx, page);
        }
SWIGINTERN PyObject *fz_page_s_setRotation(struct fz_page_s *self,int rot){
            fz_try(gctx)
            {
                pdf_page *page = pdf_page_from_fz_page(gctx, self);
                assert_PDF(page);
                if (rot % 90) THROWMSG("rotation not multiple of 90");
                pdf_dict_put_int(gctx, page->obj, PDF_NAME(Rotate), (int64_t) rot);
                page->doc->dirty = 1;
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_page_s__addAnnot_FromString(struct fz_page_s *self,PyObject *linklist){
            pdf_obj *annots, *annot, *ind_obj, *new_array;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *txtpy;
            char *text;
            int lcount = (int) PySequence_Size(linklist); // new object count
            if (lcount < 1) return_none;
            int i;
            fz_try(gctx)
            {
                assert_PDF(page);                // make sure we have a PDF
                // get existing annots array
                annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                if (annots)
                {
                    new_array = annots;
                }
                else
                {
                    new_array = pdf_new_array(gctx, page->doc, lcount);
                    pdf_dict_put_drop(gctx, page->obj, PDF_NAME(Annots), new_array);
                    new_array = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                }
            }
            fz_catch(gctx) return NULL;

            // extract object sources from Python list and store as annotations
            for (i = 0; i < lcount; i++)
            {
                fz_try(gctx)
                {
                    text = NULL;
                    txtpy = PySequence_ITEM(linklist, (Py_ssize_t) i);
                    text = JM_Python_str_AsChar(txtpy);
                    if (!text) THROWMSG("non-string linklist item");
                    annot = JM_pdf_obj_from_str(gctx, page->doc, text);
                    JM_Python_str_DelForPy3(text);
                    ind_obj = pdf_add_object(gctx, page->doc, annot);
                    pdf_array_push_drop(gctx, new_array, ind_obj);
                    pdf_drop_obj(gctx, annot);
                }
                fz_catch(gctx)
                {
                    if (text)
                        PySys_WriteStderr("%s (%i): '%s'\n", fz_caught_message(gctx), i, text);
                    else
                        PySys_WriteStderr("%s (%i)\n", fz_caught_message(gctx), i);
                    JM_Python_str_DelForPy3(text);
                    PyErr_Clear();
                }
            }
            fz_try(gctx)
            {
                JM_refresh_link_table(gctx, page);
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_page_s__getLinkXrefs(struct fz_page_s *self){
            pdf_obj *annots, *annots_arr, *link, *obj;
            int i, lcount;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *linkxrefs = PyList_New(0);
            if (!page) return linkxrefs;  // empty list for non-PDF
            annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
            if (!annots) return linkxrefs;  // no links on this page
            if (pdf_is_indirect(gctx, annots))
                annots_arr = pdf_resolve_indirect(gctx, annots);
            else
                annots_arr = annots;
            lcount = pdf_array_len(gctx, annots_arr);
            for (i = 0; i < lcount; i++)
            {
                link = pdf_array_get(gctx, annots_arr, i);
                obj = pdf_dict_get(gctx, link, PDF_NAME(Subtype));
                if (pdf_name_eq(gctx, obj, PDF_NAME(Link)))
                {
                    LIST_APPEND_DROP(linkxrefs, Py_BuildValue("i", pdf_to_num(gctx, link)));
                }
            }
            return linkxrefs;
        }
SWIGINTERN PyObject *fz_page_s__cleanContents(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page)
            {
                return_none;
            }
            fz_try(gctx)
            {
                pdf_clean_page_contents(gctx, page->doc, page, NULL, NULL, NULL, 1, 0);
            }
            fz_catch(gctx) return_none;
            page->doc->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_page_s__showPDFpage(struct fz_page_s *self,struct fz_page_s *fz_srcpage,int overlay,PyObject *matrix,int xref,PyObject *clip,struct pdf_graft_map_s *graftmap,char *_imgname){
            pdf_obj *xobj1, *xobj2, *resources;
            fz_buffer *res=NULL, *nres=NULL;
            fz_rect cropbox = JM_rect_from_py(clip);
            fz_matrix mat = JM_matrix_from_py(matrix);
            int rc_xref = xref;
            fz_try(gctx)
            {
                pdf_page *tpage = pdf_page_from_fz_page(gctx, self);
                pdf_obj *tpageref = tpage->obj;
                pdf_document *pdfout = tpage->doc;    // target PDF

                //-------------------------------------------------------------
                // convert the source page to a Form XObject
                //-------------------------------------------------------------
                xobj1 = JM_xobject_from_page(gctx, pdfout, fz_srcpage,
                                             xref, graftmap);
                if (!rc_xref) rc_xref = pdf_to_num(gctx, xobj1);

                //-------------------------------------------------------------
                // create referencing XObject (controls display on target page)
                //-------------------------------------------------------------
                // fill reference to xobj1 into the /Resources
                //-------------------------------------------------------------
                pdf_obj *subres1 = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_puts(gctx, subres1, "fullpage", xobj1);
                pdf_obj *subres  = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_put_drop(gctx, subres, PDF_NAME(XObject), subres1);

                res = fz_new_buffer(gctx, 20);
                fz_append_string(gctx, res, "/fullpage Do");

                xobj2 = pdf_new_xobject(gctx, pdfout, cropbox, mat, subres, res);

                pdf_drop_obj(gctx, subres);
                fz_drop_buffer(gctx, res);

                //-------------------------------------------------------------
                // update target page with xobj2:
                //-------------------------------------------------------------
                // 1. insert Xobject in Resources
                //-------------------------------------------------------------
                resources = pdf_dict_get_inheritable(gctx, tpageref, PDF_NAME(Resources));
                subres = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!subres)           // has no XObject yet: create one
                {
                    subres = pdf_new_dict(gctx, pdfout, 10);
                    pdf_dict_putl(gctx, tpageref, subres, PDF_NAME(Resources), PDF_NAME(XObject), NULL);
                }

                pdf_dict_puts(gctx, subres, _imgname, xobj2);

                //-------------------------------------------------------------
                // 2. make and insert new Contents object
                //-------------------------------------------------------------
                nres = fz_new_buffer(gctx, 50);       // buffer for Do-command
                fz_append_string(gctx, nres, " q /");    // Do-command
                fz_append_string(gctx, nres, _imgname);
                fz_append_string(gctx, nres, " Do Q ");

                JM_insert_contents(gctx, pdfout, tpageref, nres, overlay);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) return NULL;
            return Py_BuildValue("i", rc_xref);
        }
SWIGINTERN PyObject *fz_page_s__insertImage(struct fz_page_s *self,char const *filename,struct fz_pixmap_s *pixmap,PyObject *stream,int overlay,PyObject *matrix,char const *_imgname,PyObject *_imgpointer){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf;
            fz_pixmap *pm = NULL;
            fz_pixmap *pix = NULL;
            fz_image *mask = NULL;
            fz_separations *seps = NULL;
            pdf_obj *resources, *xobject, *ref;
            fz_buffer *res = NULL, *nres = NULL,  *imgbuf = NULL;
            fz_matrix mat = JM_matrix_from_py(matrix); // pre-calculated

            const char *template = " q %g %g %g %g %g %g cm /%s Do Q ";
            char *cont = NULL;
            fz_color_params color_params = {0};
            fz_image *zimg = NULL, *image = NULL;
            fz_try(gctx)
            {
                //-------------------------------------------------------------
                // create the image
                //-------------------------------------------------------------
                if (filename || EXISTS(stream) || EXISTS(_imgpointer))
                {
                    if (filename)
                    {
                        image = fz_new_image_from_file(gctx, filename);
                    }

                    else if (EXISTS(stream))
                    {
                        imgbuf = JM_BufferFromBytes(gctx, stream);
                        image = fz_new_image_from_buffer(gctx, imgbuf);
                    }

                    else  // fz_image pointer has been handed in
                    {
                        image = (fz_image *)PyLong_AsVoidPtr(_imgpointer);
                    }

                    // test for alpha (which would require making an SMask)
                    pix = fz_get_pixmap_from_image(gctx, image, NULL, NULL, 0, 0);
                    int xres, yres;
                    fz_image_resolution(image, &xres, &yres);
                    pix->xres = xres;
                    pix->yres = yres;
                    if (pix->alpha == 1)
                    {   // have alpha: create an SMask

                        pm = fz_convert_pixmap(gctx, pix, NULL, NULL, NULL, color_params, 1);
                        pm->alpha = 0;
                        pm->colorspace = fz_keep_colorspace(gctx, fz_device_gray(gctx));
                        mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                        zimg = fz_new_image_from_pixmap(gctx, pix, mask);
                        fz_drop_image(gctx, image);
                        image = zimg;
                        zimg = NULL;
                    }
                }
                else // pixmap specified
                {
                    if (pixmap->alpha == 0)
                        image = fz_new_image_from_pixmap(gctx, pixmap, NULL);
                    else
                    {   // pixmap has alpha: create an SMask
                        pm = fz_convert_pixmap(gctx, pixmap, NULL, NULL, NULL, color_params, 1);
                        pm->alpha = 0;
                        pm->colorspace = fz_keep_colorspace(gctx, fz_device_gray(gctx));
                        mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                        image = fz_new_image_from_pixmap(gctx, pixmap, mask);
                    }
                }

                //-------------------------------------------------------------
                // image created - now put it in the PDF
                //-------------------------------------------------------------
                pdf = page->doc;  // owning PDF

                // get /Resources, /XObject
                resources = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(Resources));
                xobject = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!xobject)  // has no XObject yet, create one
                {
                    xobject = pdf_new_dict(gctx, pdf, 10);
                    pdf_dict_putl_drop(gctx, page->obj, xobject, PDF_NAME(Resources), PDF_NAME(XObject), NULL);
                }

                ref = pdf_add_image(gctx, pdf, image);
                pdf_dict_puts(gctx, xobject, _imgname, ref);  // update XObject

                // make contents stream that invokes the image
                nres = fz_new_buffer(gctx, 50);
                fz_append_printf(gctx, nres, template,
                                 mat.a, mat.b, mat.c, mat.d, mat.e, mat.f,
                                 _imgname);
                JM_insert_contents(gctx, pdf, page->obj, nres, overlay);
                fz_drop_buffer(gctx, nres);
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, image);
                fz_drop_image(gctx, mask);
                fz_drop_pixmap(gctx, pix);
                fz_drop_pixmap(gctx, pm);
                fz_drop_buffer(gctx, imgbuf);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *fz_page_s_refresh(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return_none;
            fz_try(gctx)
            {
                JM_refresh_link_table(gctx, page);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *fz_page_s__insertFont(struct fz_page_s *self,char *fontname,char *bfname,char *fontfile,PyObject *fontbuffer,int set_simple,int idx,int wmode,int serif,int encoding,int ordering){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_document *pdf;
            pdf_obj *resources, *fonts, *font_obj;
            fz_font *font;
            fz_buffer *res = NULL;
            const unsigned char *data = NULL;
            int size, ixref = 0, index = 0, simple = 0;
            PyObject *value;
            PyObject *exto = NULL;
            fz_try(gctx)
            {
                assert_PDF(page);
                pdf = page->doc;
                // get the objects /Resources, /Resources/Font
                resources = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(Resources));
                fonts = pdf_dict_get(gctx, resources, PDF_NAME(Font));
                if (!fonts)       // page has no fonts yet
                {
                    fonts = pdf_new_dict(gctx, pdf, 10);
                    pdf_dict_putl_drop(gctx, page->obj, fonts, PDF_NAME(Resources), PDF_NAME(Font), NULL);
                }

                //-------------------------------------------------------------
                // check for CJK font
                //-------------------------------------------------------------
                if (ordering > -1) data = fz_lookup_cjk_font(gctx, ordering, &size, &index);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, NULL, data, size, index, 0);
                    font_obj = pdf_add_cjk_font(gctx, pdf, font, ordering, wmode, serif);
                    exto = JM_UnicodeFromStr("n/a");
                    simple = 0;
                    goto weiter;
                }

                //-------------------------------------------------------------
                // check for PDF Base-14 font
                //-------------------------------------------------------------
                if (bfname) data = fz_lookup_base14_font(gctx, bfname, &size);
                if (data)
                {
                    font = fz_new_font_from_memory(gctx, bfname, data, size, 0, 0);
                    font_obj = pdf_add_simple_font(gctx, pdf, font, encoding);
                    exto = JM_UnicodeFromStr("n/a");
                    simple = 1;
                    goto weiter;
                }

                if (fontfile)
                    font = fz_new_font_from_file(gctx, NULL, fontfile, idx, 0);
                else
                {
                    res = JM_BufferFromBytes(gctx, fontbuffer);
                    if (!res) THROWMSG("need one of fontfile, fontbuffer");
                    font = fz_new_font_from_buffer(gctx, NULL, res, idx, 0);
                }

                if (!set_simple)
                {
                    font_obj = pdf_add_cid_font(gctx, pdf, font);
                    simple = 0;
                }
                else
                {
                    font_obj = pdf_add_simple_font(gctx, pdf, font, encoding);
                    simple = 2;
                }

                weiter: ;
                ixref = pdf_to_num(gctx, font_obj);

                PyObject *name = JM_EscapeStrFromStr(pdf_to_name(gctx,
                            pdf_dict_get(gctx, font_obj, PDF_NAME(BaseFont))));

                PyObject *subt = JM_UnicodeFromStr(pdf_to_name(gctx,
                            pdf_dict_get(gctx, font_obj, PDF_NAME(Subtype))));

                if (!exto)
                    exto = JM_UnicodeFromStr(JM_get_fontextension(gctx, pdf, ixref));

                value = Py_BuildValue("[i, {s:O, s:O, s:O, s:O, s:i}]",
                                      ixref,
                                      "name", name,        // base font name
                                      "type", subt,        // subtype
                                      "ext", exto,         // file extension
                                      "simple", JM_BOOL(simple), // simple font?
                                      "ordering", ordering); // CJK font?
                Py_CLEAR(exto);
                Py_CLEAR(name);
                Py_CLEAR(subt);

                // resources and fonts objects will contain named reference to font
                pdf_dict_puts(gctx, fonts, fontname, font_obj);
                pdf_drop_obj(gctx, font_obj);
                fz_drop_font(gctx, font);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return value;
        }
SWIGINTERN PyObject *fz_page_s__getTransformation(struct fz_page_s *self){
            fz_matrix ctm = fz_identity;
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            if (!page) return JM_py_from_matrix(ctm);
            fz_try(gctx) pdf_page_transform(gctx, page, NULL, &ctm);
            fz_catch(gctx) {;}
            return JM_py_from_matrix(ctm);
        }
SWIGINTERN PyObject *fz_page_s__getContents(struct fz_page_s *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            PyObject *list = NULL;
            pdf_obj *contents = NULL, *icont = NULL;
            int i, xref;
            size_t n = 0;
            fz_try(gctx)
            {
                assert_PDF(page);           // only works for PDF
                contents = pdf_dict_get(gctx, page->obj, PDF_NAME(Contents));
                if (pdf_is_array(gctx, contents))     // may be several
                {
                    n = pdf_array_len(gctx, contents);
                    list = PyList_New(n);
                    for (i=0; i < pdf_array_len(gctx, contents); i++)
                    {
                        icont = pdf_array_get(gctx, contents, i);
                        xref = pdf_to_num(gctx, icont);
                        PyList_SET_ITEM(list, i, Py_BuildValue("i", xref));
                    }
                }
                else if (contents)          // at most 1 object there
                {
                    list = PyList_New(1);
                    xref = pdf_to_num(gctx, contents);
                    PyList_SET_ITEM(list, 0, Py_BuildValue("i", xref));
                }
            }
            fz_catch(gctx) return NULL;
            if (list)
            {
                return list;
            }
            return PyList_New(0);
        }
SWIGINTERN PyObject *fz_page_s__setContents(struct fz_page_s *self,int xref){
            pdf_page *page = pdf_page_from_fz_page(gctx, self);
            pdf_obj *contents = NULL;

            fz_try(gctx)
            {
                assert_PDF(page);           // only works for PDF

                if (!INRANGE(xref, 1, pdf_xref_len(gctx, page->doc) - 1))
                    THROWMSG("xref out of range");

                contents = pdf_new_indirect(gctx, page->doc, xref, 0);
                if (!pdf_is_stream(gctx, contents))
                    THROWMSG("xref is not a stream");

                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(Contents), contents);
            }
            fz_catch(gctx) return NULL;
            page->doc->dirty = 1;
            return_none;
        }
SWIGINTERN void delete_fz_pixmap_s(struct fz_pixmap_s *self){
            DEBUGMSG1("pixmap");
            fz_drop_pixmap(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_0(struct fz_colorspace_s *cs,PyObject *bbox,int alpha){
            fz_pixmap *pm = NULL;
            fz_separations *seps = NULL;
            fz_try(gctx)
                pm = fz_new_pixmap_with_bbox(gctx, cs, JM_irect_from_py(bbox), seps, alpha);
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_1(struct fz_colorspace_s *cs,struct fz_pixmap_s *spix){
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                if (!fz_pixmap_colorspace(gctx, spix))
                    THROWMSG("cannot copy pixmap with NULL colorspace");
                fz_color_params color_params = {0};
                pm = fz_convert_pixmap(gctx, spix, cs, NULL, NULL, color_params, 1);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_2(struct fz_pixmap_s *spix,float w,float h,PyObject *clip){
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                fz_irect bbox = JM_irect_from_py(clip);
                if (!fz_is_infinite_irect(bbox))
                {
                    pm = fz_scale_pixmap(gctx, spix, spix->x, spix->y, w, h, &bbox);
                }
                else
                    pm = fz_scale_pixmap(gctx, spix, spix->x, spix->y, w, h, NULL);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_3(struct fz_pixmap_s *spix,int alpha){
            fz_pixmap *pm = NULL;
            int n, w, h, i;
            fz_separations *seps = NULL;
            fz_try(gctx)
            {
                if (!INRANGE(alpha, 0, 1))
                    THROWMSG("illegal alpha value");
                fz_colorspace *cs = fz_pixmap_colorspace(gctx, spix);
                if (!cs && !alpha)
                    THROWMSG("cannot drop alpha for 'NULL' colorspace");
                n = fz_pixmap_colorants(gctx, spix);
                w = fz_pixmap_width(gctx, spix);
                h = fz_pixmap_height(gctx, spix);
                pm = fz_new_pixmap(gctx, cs, w, h, seps, alpha);
                pm->x = spix->x;
                pm->y = spix->y;
                pm->xres = spix->xres;
                pm->yres = spix->yres;

                // copy samples data ------------------------------------------
                unsigned char *sptr = spix->samples;
                unsigned char *tptr = pm->samples;
                if (spix->alpha == pm->alpha)    // identical samples ---------
                    memcpy(tptr, sptr, w * h * (n + alpha));
                else
                {
                    for (i = 0; i < w * h; i++)
                    {
                        memcpy(tptr, sptr, n);
                        tptr += n;
                        if (pm->alpha)
                        {
                            tptr[0] = 255;
                            tptr++;
                        }
                        sptr += n + spix->alpha;
                    }
                }
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_4(struct fz_colorspace_s *cs,int w,int h,PyObject *samples,int alpha){
            int n = fz_colorspace_n(gctx, cs);
            int stride = (n + alpha)*w;
            fz_separations *seps = NULL;
            fz_buffer *res = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                size_t size = 0;
                unsigned char *c = NULL;
                res = JM_BufferFromBytes(gctx, samples);
                if (!res) THROWMSG("bad samples data");
                size = fz_buffer_storage(gctx, res, &c);
                if (stride * h != size) THROWMSG("bad samples length");
                pm = fz_new_pixmap(gctx, cs, w, h, seps, alpha);
                memcpy(pm->samples, c, size);
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_5(char *filename){
            fz_image *img = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx) {
                img = fz_new_image_from_file(gctx, filename);
                pm = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
                int xres, yres;
                fz_image_resolution(img, &xres, &yres);
                pm->xres = xres;
                pm->yres = yres;
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_6(PyObject *imagedata){
            fz_buffer *res = NULL;
            fz_image *img = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx)
            {
                res = JM_BufferFromBytes(gctx, imagedata);
                if (!res) THROWMSG("bad image data");
                img = fz_new_image_from_buffer(gctx, res);
                pm = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
                int xres, yres;
                fz_image_resolution(img, &xres, &yres);
                pm->xres = xres;
                pm->yres = yres;
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            return pm;
        }
SWIGINTERN struct fz_pixmap_s *new_fz_pixmap_s__SWIG_7(struct fz_document_s *doc,int xref){
            fz_image *img = NULL;
            fz_pixmap *pix = NULL;
            fz_buffer *res = NULL;
            pdf_obj *ref = NULL;
            pdf_obj *type;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            fz_try(gctx)
            {
                assert_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG("xref out of range");
                ref = pdf_new_indirect(gctx, pdf, xref, 0);
                type = pdf_dict_get(gctx, ref, PDF_NAME(Subtype));
                if (!pdf_name_eq(gctx, type, PDF_NAME(Image)))
                    THROWMSG("xref is not an image");
                res = pdf_load_raw_stream(gctx, ref);
                unsigned char *c = NULL;
                fz_buffer_storage(gctx, res, &c);
                int img_type = fz_recognize_image_format(gctx, c);
                if (img_type != FZ_IMAGE_UNKNOWN)
                {
                    img = fz_new_image_from_buffer(gctx, res);
                }
                else
                {
                    img = pdf_load_image(gctx, pdf, ref);
                }
                pix = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
                int xres, yres;
                fz_image_resolution(img, &xres, &yres);
                pix->xres = xres;
                pix->yres= yres;
            }
            fz_always(gctx)
            {
                fz_drop_image(gctx, img);
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, ref);
            }
            fz_catch(gctx)
            {
                fz_drop_pixmap(gctx, pix);
                return NULL;
            }
            return pix;
        }
SWIGINTERN void fz_pixmap_s_shrink(struct fz_pixmap_s *self,int factor){
            if (factor < 1)
            {
                JM_Warning("ignoring shrink factor < 1");
                return;
            }
            fz_subsample_pixmap(gctx, self, factor);
        }
SWIGINTERN void fz_pixmap_s_gammaWith(struct fz_pixmap_s *self,float gamma){
            if (!fz_pixmap_colorspace(gctx, self))
            {
                JM_Warning("colorspace invalid for function");
                return;
            }
            fz_gamma_pixmap(gctx, self, gamma);
        }
SWIGINTERN void fz_pixmap_s_tintWith(struct fz_pixmap_s *self,int black,int white){
            fz_tint_pixmap(gctx, self, black, white);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_0(struct fz_pixmap_s *self){
            fz_clear_pixmap(gctx, self);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_1(struct fz_pixmap_s *self,int value){
            fz_clear_pixmap_with_value(gctx, self, value);
        }
SWIGINTERN void fz_pixmap_s_clearWith__SWIG_2(struct fz_pixmap_s *self,int value,PyObject *bbox){
            JM_clear_pixmap_rect_with_value(gctx, self, value, JM_irect_from_py(bbox));
        }
SWIGINTERN PyObject *fz_pixmap_s_copyPixmap(struct fz_pixmap_s *self,struct fz_pixmap_s *src,PyObject *bbox){
            fz_try(gctx)
            {
                if (!fz_pixmap_colorspace(gctx, src))
                    THROWMSG("cannot copy pixmap with NULL colorspace");
                if (self->alpha != src->alpha)
                    THROWMSG("source and target alpha must be equal");
                fz_copy_pixmap_rect(gctx, self, src, JM_irect_from_py(bbox), NULL);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_pixmap_s_setAlpha(struct fz_pixmap_s *self,PyObject *alphavalues){
            fz_buffer *res = NULL;
            fz_try(gctx)
            {
                if (self->alpha == 0) THROWMSG("pixmap has no alpha");
                int n = fz_pixmap_colorants(gctx, self);
                int w = fz_pixmap_width(gctx, self);
                int h = fz_pixmap_height(gctx, self);
                int balen = w * h * (n+1);
                unsigned char *data = NULL;
                int data_len = 0;
                if (alphavalues)
                {
                    res = JM_BufferFromBytes(gctx, alphavalues);
                    if (res)
                    {
                        data_len = (int) fz_buffer_storage(gctx, res, &data);
                        if (data && data_len < w * h)
                            THROWMSG("not enough alpha values");
                    }
                    else THROWMSG("bad type: 'alphavalues'");
                }
                int i = 0, k = 0;
                while (i < balen)
                {
                    if (data_len) self->samples[i+n] = data[k];
                    else          self->samples[i+n] = 255;
                    i += n+1;
                    k += 1;
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *fz_pixmap_s__getImageData(struct fz_pixmap_s *self,int format){
            fz_output *out = NULL;
            fz_buffer *res = NULL;
            PyObject *barray = NULL;
            fz_try(gctx)
            {
                size_t size = fz_pixmap_stride(gctx, self) * self->h;
                res = fz_new_buffer(gctx, size);
                out = fz_new_output_with_buffer(gctx, res);

                switch(format)
                {
                    case(1):
                        fz_write_pixmap_as_png(gctx, out, self);
                        break;
                    case(2):
                        fz_write_pixmap_as_pnm(gctx, out, self);
                        break;
                    case(3):
                        fz_write_pixmap_as_pam(gctx, out, self);
                        break;
                    case(5):           // Adobe Photoshop Document
                        fz_write_pixmap_as_psd(gctx, out, self);
                        break;
                    case(6):           // Postscript format
                        fz_write_pixmap_as_ps(gctx, out, self);
                        break;
                    default:
                        fz_write_pixmap_as_png(gctx, out, self);
                        break;
                }
                barray = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx)
            {
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }

            fz_catch(gctx)
            {
                return NULL;
            }
            return barray;
        }
SWIGINTERN PyObject *fz_pixmap_s__writeIMG(struct fz_pixmap_s *self,char *filename,int format){
            fz_try(gctx) {
                switch(format)
                {
                    case(1):
                        fz_save_pixmap_as_png(gctx, self, filename);
                        break;
                    case(2):
                        fz_save_pixmap_as_pnm(gctx, self, filename);
                        break;
                    case(3):
                        fz_save_pixmap_as_pam(gctx, self, filename);
                        break;
                    case(5): // Adobe Photoshop Document
                        fz_save_pixmap_as_psd(gctx, self, filename);
                        break;
                    case(6): // Postscript
                        fz_save_pixmap_as_ps(gctx, self, filename, 0);
                        break;
                    default:
                        fz_save_pixmap_as_png(gctx, self, filename);
                        break;
                }
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_pixmap_s_invertIRect(struct fz_pixmap_s *self,PyObject *irect){
            if (!fz_pixmap_colorspace(gctx, self))
                {
                    JM_Warning("ignored for stencil pixmap");
                    return JM_BOOL(0);
                }

            fz_irect r = JM_irect_from_py(irect);
            if (fz_is_infinite_irect(r))
                r = fz_pixmap_bbox(gctx, self);

            return JM_BOOL(JM_invert_pixmap_rect(gctx, self, r));
        }
SWIGINTERN PyObject *fz_pixmap_s_pixel(struct fz_pixmap_s *self,int x,int y){
            PyObject *p = NULL;
            fz_try(gctx)
            {
                if (!INRANGE(x, 0, self->w - 1) || !INRANGE(y, 0, self->h - 1))
                    THROWMSG("coordinates outside image");
                int n = self->n;
                int stride = fz_pixmap_stride(gctx, self);
                int j, i = stride * y + n * x;
                p = PyList_New(n);
                for (j = 0; j < n; j++)
                {
                    PyList_SET_ITEM(p, j, Py_BuildValue("i", self->samples[i + j]));
                }
            }
            fz_catch(gctx) return NULL;
            return p;
        }
SWIGINTERN PyObject *fz_pixmap_s_setPixel(struct fz_pixmap_s *self,int x,int y,PyObject *color){
            fz_try(gctx)
            {
                if (!INRANGE(x, 0, self->w - 1) || !INRANGE(y, 0, self->h - 1))
                    THROWMSG("outside image");
                int n = self->n;
                if (!PySequence_Check(color) || PySequence_Size(color) != n)
                    THROWMSG("bad color arg");
                int i, j;
                unsigned char c[5];
                for (j = 0; j < n; j++)
                {
                    i = (int) PyInt_AsLong(PySequence_ITEM(color, j));
                    if (!INRANGE(i, 0, 255)) THROWMSG("bad pixel component");
                    c[j] = (unsigned char) i;
                }
                int stride = fz_pixmap_stride(gctx, self);
                i = stride * y + n * x;
                for (j = 0; j < n; j++)
                {
                    self->samples[i + j] = c[j];
                }
            }
            fz_catch(gctx)
            {
                PyErr_Clear();
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *fz_pixmap_s_setResolution(struct fz_pixmap_s *self,int xres,int yres){
            self->xres = xres;
            self->yres = yres;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *fz_pixmap_s_setRect(struct fz_pixmap_s *self,PyObject *irect,PyObject *color){
            PyObject *rc = JM_BOOL(0);
            fz_try(gctx)
            {
                int n = self->n;
                if (!PySequence_Check(color) || PySequence_Size(color) != n)
                    THROWMSG("bad color arg");
                int i, j;
                unsigned char c[5];
                for (j = 0; j < n; j++)
                {
                    i = (int) PyInt_AsLong(PySequence_ITEM(color, j));
                    if (!INRANGE(i, 0, 255)) THROWMSG("bad color component");
                    c[j] = (unsigned char) i;
                }
                i = JM_fill_pixmap_rect_with_color(gctx, self, c, JM_irect_from_py(irect));
                rc = JM_BOOL(i);
            }
            fz_catch(gctx)
            {
                PyErr_Clear();
                return NULL;
            }
            return rc;
        }
SWIGINTERN int fz_pixmap_s_stride(struct fz_pixmap_s *self){
            return fz_pixmap_stride(gctx, self);
        }
SWIGINTERN int fz_pixmap_s_alpha(struct fz_pixmap_s *self){
            return self->alpha;
        }
SWIGINTERN struct fz_colorspace_s *fz_pixmap_s_colorspace(struct fz_pixmap_s *self){
            return fz_pixmap_colorspace(gctx, self);
        }
SWIGINTERN PyObject *fz_pixmap_s_irect(struct fz_pixmap_s *self){
            return JM_py_from_irect(fz_pixmap_bbox(gctx, self));
        }
SWIGINTERN int fz_pixmap_s_size(struct fz_pixmap_s *self){
            return (int) fz_pixmap_size(gctx, self);
        }
SWIGINTERN PyObject *fz_pixmap_s_samples(struct fz_pixmap_s *self){
            return PyBytes_FromStringAndSize((const char *)self->samples, (Py_ssize_t) (self->w)*(self->h)*(self->n));
        }
SWIGINTERN void delete_fz_colorspace_s(struct fz_colorspace_s *self){
            DEBUGMSG1("colorspace");
            fz_drop_colorspace(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_colorspace_s *new_fz_colorspace_s(int type){
            switch(type) {
                case CS_GRAY:
                    return fz_device_gray(gctx);
                    break;
                case CS_CMYK:
                    return fz_device_cmyk(gctx);
                    break;
                case CS_RGB:
                default:
                    return fz_device_rgb(gctx);
                    break;
            }
        }
SWIGINTERN PyObject *fz_colorspace_s_n(struct fz_colorspace_s *self){
            return Py_BuildValue("i", fz_colorspace_n(gctx, self));
        }
SWIGINTERN PyObject *fz_colorspace_s__name(struct fz_colorspace_s *self){
            return JM_UnicodeFromStr(fz_colorspace_name(gctx, self));
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_0(struct fz_pixmap_s *pm,PyObject *clip){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_irect bbox = JM_irect_from_py(clip);
                if (fz_is_infinite_irect(bbox))
                    dw->device = fz_new_draw_device(gctx, fz_identity, pm);
                else
                    dw->device = fz_new_draw_device_with_bbox(gctx, fz_identity, pm, &bbox);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_1(struct fz_display_list_s *dl){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                dw->device = fz_new_list_device(gctx, dl);
                dw->list = dl;
                fz_keep_display_list(gctx, dl);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_2(struct fz_stext_page_s *tp,int flags){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_stext_options opts = { 0 };
                opts.flags = flags;
                dw->device = fz_new_stext_device(gctx, tp, &opts);
            }
            fz_catch(gctx) return NULL;
            return dw;
        }
SWIGINTERN void delete_DeviceWrapper(struct DeviceWrapper *self){
            fz_display_list *list = self->list;
            DEBUGMSG1("device");
            fz_close_device(gctx, self->device);
            fz_drop_device(gctx, self->device);
            DEBUGMSG2;
            if(list)
            {
                DEBUGMSG1("display list after device");
                fz_drop_display_list(gctx, list);
                DEBUGMSG2;
            }
        }
SWIGINTERN PyObject *fz_outline_s_uri(struct fz_outline_s *self){
            return JM_UnicodeFromStr(self->uri);
        }
SWIGINTERN PyObject *fz_outline_s_isExternal(struct fz_outline_s *self){
            if (!self->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, self->uri));
        }
SWIGINTERN void delete_pdf_annot_s(struct pdf_annot_s *self){
            DEBUGMSG1("annot");
            pdf_drop_annot(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *pdf_annot_s_rect(struct pdf_annot_s *self){
            fz_rect r = pdf_bound_annot(gctx, self);
            return JM_py_from_rect(r);
        }
SWIGINTERN PyObject *pdf_annot_s_xref(struct pdf_annot_s *self){
            int i = pdf_to_num(gctx, self->obj);
            return Py_BuildValue("i", i);
        }
SWIGINTERN PyObject *pdf_annot_s_blendMode(struct pdf_annot_s *self){
            PyObject *blend_mode = NULL;
            fz_try(gctx)
            {
                pdf_obj *obj, *obj1, *obj2;
                obj = pdf_dict_get(gctx, self->obj, PDF_NAME(BM));
                if (obj)  // check the annot object for /BM
                {
                    blend_mode = JM_UnicodeFromStr(pdf_to_name(gctx, obj));
                    goto fertig;
                }
                // loop through the /AP/N/Resources/ExtGState objects
                obj = pdf_dict_getl(gctx, self->obj, PDF_NAME(AP),
                    PDF_NAME(N),
                    PDF_NAME(Resources),
                    PDF_NAME(ExtGState),
                    NULL);

                if (pdf_is_dict(gctx, obj))
                {
                    int i, j, m, n = pdf_dict_len(gctx, obj);
                    for (i = 0; i < n; i++)
                    {
                        obj1 = pdf_dict_get_val(gctx, obj, i);
                        if (pdf_is_dict(gctx, obj1))
                        {
                            m = pdf_dict_len(gctx, obj1);
                            for (j = 0; j < m; j++)
                            {
                                obj2 = pdf_dict_get_key(gctx, obj1, j);
                                if (pdf_objcmp(gctx, obj2, PDF_NAME(BM)) == 0)
                                {
                                    blend_mode = JM_UnicodeFromStr(pdf_to_name(gctx, pdf_dict_get_val(gctx, obj1, j)));
                                    goto fertig;
                                }
                            }
                        }
                    }
                }
                fertig:;
            }
            fz_catch(gctx) return_none;
            if (blend_mode) return blend_mode;
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s_setBlendMode(struct pdf_annot_s *self,char *blend_mode){
            fz_try(gctx)
            {
                pdf_dict_put_name(gctx, self->obj, PDF_NAME(BM), blend_mode);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s__getAP(struct pdf_annot_s *self){
            PyObject *r = Py_None;
            fz_buffer *res = NULL;
            fz_try(gctx)
            {
                pdf_obj *ap = pdf_dict_getl(gctx, self->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);

                if (pdf_is_stream(gctx, ap))  res = pdf_load_stream(gctx, ap);
                if (res) r = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx) fz_drop_buffer(gctx, res);
            fz_catch(gctx) return_none;
            return r;
        }
SWIGINTERN PyObject *pdf_annot_s__setAP(struct pdf_annot_s *self,PyObject *ap,int rect){
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx)
            {
                pdf_obj *apobj = pdf_dict_getl(gctx, self->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);
                if (!apobj) THROWMSG("annot has no /AP/N object");
                if (!pdf_is_stream(gctx, apobj))
                    THROWMSG("/AP/N object is no stream");
                res = JM_BufferFromBytes(gctx, ap);
                if (!res) THROWMSG("invalid /AP stream argument");
                JM_update_stream(gctx, self->page->doc, apobj, res, 1);
                if (rect)
                {
                    fz_rect bbox = pdf_dict_get_rect(gctx, self->obj, PDF_NAME(Rect));
                    pdf_dict_put_rect(gctx, apobj, PDF_NAME(BBox), bbox);
                    self->ap = NULL;
                }
            }
            fz_always(gctx)
                fz_drop_buffer(gctx, res);
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s__get_redact_values(struct pdf_annot_s *self){
            if (pdf_annot_type(gctx, self) != PDF_ANNOT_REDACT)
            {
                return_none;
            }
            PyObject *values = PyDict_New();
            const char *text = NULL;
            fz_try(gctx)
            {
                pdf_obj *obj = pdf_dict_gets(gctx, self->obj, "RO");
                if (obj)
                {
                    THROWMSG("unsupported redaction key '/RO'.");
                }
                obj = pdf_dict_gets(gctx, self->obj, "OverlayText");
                if (obj)
                {
                    text = pdf_to_text_string(gctx, obj);
                    DICT_SETITEM_DROP(values, dictkey_text, JM_UnicodeFromStr(text));
                }
                else
                {
                    DICT_SETITEM_DROP(values, dictkey_text, Py_BuildValue("s", ""));
                }
                obj = pdf_dict_get(gctx, self->obj, PDF_NAME(Q));
                int align = 0;
                if (obj)
                {
                    align = pdf_to_int(gctx, obj);
                }
                DICT_SETITEM_DROP(values, dictkey_align, Py_BuildValue("i", align));
            }
            fz_catch(gctx)
            {
                Py_DECREF(values);
                return NULL;
            }
            return values;
        }
SWIGINTERN PyObject *pdf_annot_s_setName(struct pdf_annot_s *self,char *name){
            fz_try(gctx)
            {
                pdf_dict_put_name(gctx, self->obj, PDF_NAME(Name), name);
                pdf_dirty_annot(gctx, self);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s_setRect(struct pdf_annot_s *self,PyObject *rect){
            fz_try(gctx)
            {
                pdf_set_annot_rect(gctx, self, JM_rect_from_py(rect));
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s_vertices(struct pdf_annot_s *self){
            PyObject *res = Py_None;
            pdf_obj *o;
            //----------------------------------------------------------------
            // The following objects occur in different annotation types.
            // So we are sure that o != NULL occurs at most once.
            // Every pair of floats is one point, that needs to be separately
            // transformed with the page transformation matrix.
            //----------------------------------------------------------------
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(Vertices));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(L));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(QuadPoints));
            if (o) goto weiter;
            o = pdf_dict_gets(gctx, self->obj, "CL");
            if (o) goto weiter;
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(InkList));
            if (o) goto weiter;
            return res;

            weiter:;
            int i, n;
            fz_point point;             // point object to work with
            fz_matrix page_ctm;         // page transformation matrix
            pdf_page_transform(gctx, self->page, NULL, &page_ctm);
            res = PyList_New(0);        // create Python list
            n = pdf_array_len(gctx, o);
            for (i = 0; i < n; i += 2)
            {
                point.x = pdf_to_real(gctx, pdf_array_get(gctx, o, i));
                point.y = pdf_to_real(gctx, pdf_array_get(gctx, o, i+1));
                point = fz_transform_point(point, page_ctm);
                LIST_APPEND_DROP(res,  Py_BuildValue("ff", point.x, point.y));
            }

            return res;
        }
SWIGINTERN PyObject *pdf_annot_s_colors(struct pdf_annot_s *self){
            return JM_annot_colors(gctx, self->obj);
        }
SWIGINTERN PyObject *pdf_annot_s__update_appearance(struct pdf_annot_s *self,float opacity,char *blend_mode,PyObject *fill_color,int rotate){
            int type = pdf_annot_type(gctx, self);
            float fcol[4] = {1,1,1,1};  // std fill color: white
            int nfcol = 0;  // number of color components
            JM_color_FromSequence(fill_color, &nfcol, fcol);
            fz_try(gctx)
            {
                pdf_dirty_annot(gctx, self); // enforce MuPDF /AP formatting
                if (type == PDF_ANNOT_FREE_TEXT)
                {
                    if (rotate >= 0)
                    {
                        pdf_dict_put_int(gctx, self->obj, PDF_NAME(Rotate), rotate);
                    }
                    if (EXISTS(fill_color))
                    {
                        pdf_set_annot_color(gctx, self, nfcol, fcol); // fill color
                    }
                }
                self->needs_new_ap = 1;  // force re-creation of appearance stream
                pdf_update_annot(gctx, self);  // update the annotation

                // wrap the stream with 'q', 'Q'
                pdf_clean_annot_contents(gctx, self->page->doc, self,
                                         NULL, NULL, NULL, 1, 0);
            }
            fz_catch(gctx)
            {
                PySys_WriteStderr("cannot update annot: '%s'\n", fz_caught_message(gctx));
                Py_RETURN_FALSE;
            }

            if ((opacity < 0 || opacity >= 1) && !blend_mode)  // no opacity, no blend_mode
                Py_RETURN_TRUE;

            fz_try(gctx)  // create or update /ExtGState
            {
                pdf_obj *ap = pdf_dict_getl(gctx, self->obj, PDF_NAME(AP),
                                        PDF_NAME(N), NULL);
                if (!ap)  // should never happen
                    THROWMSG("annot has no /AP object");

                pdf_obj *resources = pdf_dict_get(gctx, ap, PDF_NAME(Resources));
                if (!resources)  // no Resources yet: make one
                {
                    resources = pdf_dict_put_dict(gctx, ap, PDF_NAME(Resources), 2);
                }
                pdf_obj *alp0 = pdf_new_dict(gctx, self->page->doc, 3);
                if (opacity >= 0 && opacity < 1)
                {
                    pdf_dict_put_real(gctx, alp0, PDF_NAME(CA), (double) opacity);
                    pdf_dict_put_real(gctx, alp0, PDF_NAME(ca), (double) opacity);
                    pdf_dict_put_real(gctx, self->obj, PDF_NAME(CA), (double) opacity);
                }
                if (blend_mode)
                {
                    pdf_dict_put_name(gctx, alp0, PDF_NAME(BM), blend_mode);
                    pdf_dict_put_name(gctx, self->obj, PDF_NAME(BM), blend_mode);
                }
                pdf_obj *extg = pdf_dict_get(gctx, resources, PDF_NAME(ExtGState));
                if (!extg)  // no ExtGState yet: make one
                {
                    extg = pdf_dict_put_dict(gctx, resources, PDF_NAME(ExtGState), 2);
                }
                pdf_dict_put_drop(gctx, extg, PDF_NAME(H), alp0);
            }

            fz_catch(gctx)
            {
                PySys_WriteStderr("could not set opacity or blend mode\n");
                Py_RETURN_FALSE;
            }
            Py_RETURN_TRUE;
        }
SWIGINTERN void pdf_annot_s_setColors(struct pdf_annot_s *self,PyObject *colors,PyObject *fill,PyObject *stroke){
            if (!PyDict_Check(colors)) return;
            PyObject *ccol, *icol;
            ccol = PyDict_GetItem(colors, dictkey_stroke);
            icol = PyDict_GetItem(colors, dictkey_fill);
            int i, n;
            float col[4];
            n = 0;
            if (ccol)
                if (PySequence_Check(ccol))
                    n = (int) PySequence_Size(ccol);
            if (n>0)
            {
                for (i=0; i<n; i++)
                    col[i] = (float) PyFloat_AsDouble(PySequence_ITEM(ccol, i));
                fz_try(gctx)
                    pdf_set_annot_color(gctx, self, n, col);
                fz_catch(gctx)
                    JM_Warning("cannot set stroke color for this annot type");
            }
            n = 0;
            if (icol)
                if (PySequence_Check(icol))
                    n = (int) PySequence_Size(icol);
            if (n>0)
            {
                if (!pdf_annot_has_interior_color(gctx, self))
                {
                    JM_Warning("annot type has no fill color");
                    return;
                }
                for (i=0; i<n; i++)
                    col[i] = (float) PyFloat_AsDouble(PySequence_ITEM(icol, i));
                fz_try(gctx)
                    pdf_set_annot_interior_color(gctx, self, n, col);
                fz_catch(gctx)
                    JM_Warning("cannot set fill color for this annot type");
            }
            return;
        }
SWIGINTERN PyObject *pdf_annot_s_lineEnds(struct pdf_annot_s *self){
            int i = pdf_annot_type(gctx, self);
            // return nothing for invalid annot types
            if (!INRANGE(i, 2, 7)) return_none;
            if (INRANGE(i, 4, 5)) return_none;
            PyObject *res = Py_BuildValue("[ii]", 0, 0); // standard
            pdf_obj *o = pdf_dict_gets(gctx, self->obj, "LE");
            if (!o) return res;                       // no LE: empty dict
            char *lstart = NULL;
            char *lend = NULL;
            if (pdf_is_name(gctx, o)) lstart = (char *) pdf_to_name(gctx, o);
            else if (pdf_is_array(gctx, o))
                {
                lstart = (char *) pdf_to_name(gctx, pdf_array_get(gctx, o, 0));
                if (pdf_array_len(gctx, o) > 1)
                    lend   = (char *) pdf_to_name(gctx, pdf_array_get(gctx, o, 1));
                }
            PyList_SetItem(res, 0, Py_BuildValue("i", JM_le_value(gctx, lstart)));
            PyList_SetItem(res, 1, Py_BuildValue("i", JM_le_value(gctx, lend)));
            return res;
        }
SWIGINTERN void pdf_annot_s_setLineEnds(struct pdf_annot_s *self,int start,int end){
            if (pdf_annot_has_line_ending_styles(gctx, self))
                pdf_set_annot_line_ending_styles(gctx, self, start, end);
            else
                JM_Warning("annot type has no line ends");
        }
SWIGINTERN PyObject *pdf_annot_s_type(struct pdf_annot_s *self){
            int type = pdf_annot_type(gctx, self);
            const char *c = pdf_string_from_annot_type(gctx, type);
            pdf_obj *o = pdf_dict_gets(gctx, self->obj, "IT");
            if (!o || !pdf_is_name(gctx, o))
                return Py_BuildValue("is", type, c);         // no IT entry
            const char *it = pdf_to_name(gctx, o);
            return Py_BuildValue("iss", type, c, it);
        }
SWIGINTERN PyObject *pdf_annot_s_opacity(struct pdf_annot_s *self){
            double opy = -1.0f;
            pdf_obj *ca = pdf_dict_get(gctx, self->obj, PDF_NAME(CA));
            if (pdf_is_number(gctx, ca))
                opy = pdf_to_real(gctx, ca);
            return Py_BuildValue("f", opy);
        }
SWIGINTERN void pdf_annot_s_setOpacity(struct pdf_annot_s *self,float opacity){
            if (!INRANGE(opacity, 0.0f, 1.0f))
            {
                pdf_set_annot_opacity(gctx, self, 1.0f);
                return;
            }
            pdf_set_annot_opacity(gctx, self, opacity);
            if (opacity < 1.0f)
            {
                self->page->transparency = 1;
            }
        }
SWIGINTERN PyObject *pdf_annot_s_fileInfo(struct pdf_annot_s *self){
            PyObject *res = PyDict_New();  // create Python dict
            char *filename = NULL;
            char *desc = NULL;
            int length = -1, size = -1;
            pdf_obj *stream = NULL, *o = NULL, *fs = NULL;

            fz_try(gctx)
            {
                int type = (int) pdf_annot_type(gctx, self);
                if (type != PDF_ANNOT_FILEATTACHMENT)
                    THROWMSG("not a file attachment annot");
                stream = pdf_dict_getl(gctx, self->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG("bad PDF: file entry not found");
            }
            fz_catch(gctx) return NULL;

            fs = pdf_dict_get(gctx, self->obj, PDF_NAME(FS));

            o = pdf_dict_get(gctx, fs, PDF_NAME(UF));
            if (o) filename = (char *) pdf_to_text_string(gctx, o);
            else
            {
                o = pdf_dict_get(gctx, fs, PDF_NAME(F));
                if (o) filename = (char *) pdf_to_text_string(gctx, o);
            }

            o = pdf_dict_get(gctx, fs, PDF_NAME(Desc));
            if (o) desc = (char *) pdf_to_text_string(gctx, o);

            o = pdf_dict_get(gctx, stream, PDF_NAME(Length));
            if (o) length = pdf_to_int(gctx, o);

            o = pdf_dict_getl(gctx, stream, PDF_NAME(Params),
                                PDF_NAME(Size), NULL);
            if (o) size = pdf_to_int(gctx, o);

            DICT_SETITEM_DROP(res, dictkey_filename, JM_EscapeStrFromStr(filename));
            DICT_SETITEM_DROP(res, dictkey_desc, JM_UnicodeFromStr(desc));
            DICT_SETITEM_DROP(res, dictkey_length, Py_BuildValue("i", length));
            DICT_SETITEM_DROP(res, dictkey_size, Py_BuildValue("i", size));
            return res;
        }
SWIGINTERN PyObject *pdf_annot_s_fileGet(struct pdf_annot_s *self){
            PyObject *res = NULL;
            pdf_obj *stream = NULL;
            fz_buffer *buf = NULL;
            fz_var(buf);
            fz_try(gctx)
            {
                int type = (int) pdf_annot_type(gctx, self);
                if (type != PDF_ANNOT_FILEATTACHMENT)
                    THROWMSG("not a file attachment annot");
                stream = pdf_dict_getl(gctx, self->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG("bad PDF: file entry not found");
                buf = pdf_load_stream(gctx, stream);
                res = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) fz_drop_buffer(gctx, buf);
            fz_catch(gctx) return NULL;
            return res;
        }
SWIGINTERN PyObject *pdf_annot_s_fileUpd(struct pdf_annot_s *self,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = NULL;       // to be filled in
            char *data = NULL;              // for new file content
            fz_buffer *res = NULL;          // for compressed content
            pdf_obj *stream = NULL, *fs = NULL;
            int64_t size = 0;
            fz_try(gctx)
            {
                pdf = self->page->doc;     // the owning PDF
                int type = (int) pdf_annot_type(gctx, self);
                if (type != PDF_ANNOT_FILEATTACHMENT)
                    THROWMSG("bad annot type");
                stream = pdf_dict_getl(gctx, self->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                // the object for file content
                if (!stream) THROWMSG("bad PDF: no /EF object");

                fs = pdf_dict_get(gctx, self->obj, PDF_NAME(FS));

                // file content given
                res = JM_BufferFromBytes(gctx, buffer);
                if (buffer && !res) THROWMSG("bad type: 'buffer'");
                if (res)
                {
                    JM_update_stream(gctx, pdf, stream, res, 1);
                    // adjust /DL and /Size parameters
                    int64_t len = (int64_t) fz_buffer_storage(gctx, res, NULL);
                    pdf_obj *l = pdf_new_int(gctx, len);
                    pdf_dict_put(gctx, stream, PDF_NAME(DL), l);
                    pdf_dict_putl(gctx, stream, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
                }

                if (filename)               // new filename given
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(F), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(F), filename);
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(UF), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(UF), filename);
                    pdf_dict_put_text_string(gctx, self->obj, PDF_NAME(Contents), filename);
                }

                if (ufilename)
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(UF), ufilename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(UF), ufilename);
                }

                if (desc)                   // new description given
                {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(Desc), desc);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(Desc), desc);
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return NULL;
            pdf->dirty = 1;
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s_info(struct pdf_annot_s *self){
            PyObject *res = PyDict_New();
            pdf_obj *o;

            DICT_SETITEM_DROP(res, dictkey_content,
                          JM_UnicodeFromStr(pdf_annot_contents(gctx, self)));

            o = pdf_dict_get(gctx, self->obj, PDF_NAME(Name));
            DICT_SETITEM_DROP(res, dictkey_name, JM_UnicodeFromStr(pdf_to_name(gctx, o)));

            // Title (= author)
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(T));
            DICT_SETITEM_DROP(res, dictkey_title, JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // CreationDate
            o = pdf_dict_gets(gctx, self->obj, "CreationDate");
            DICT_SETITEM_DROP(res, dictkey_creationDate,
                          JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // ModDate
            o = pdf_dict_get(gctx, self->obj, PDF_NAME(M));
            DICT_SETITEM_DROP(res, dictkey_modDate, JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // Subj
            o = pdf_dict_gets(gctx, self->obj, "Subj");
            DICT_SETITEM_DROP(res, dictkey_subject,
                          Py_BuildValue("s",pdf_to_text_string(gctx, o)));

            // Identification (PDF key /NM)
            o = pdf_dict_gets(gctx, self->obj, "NM");
            DICT_SETITEM_DROP(res, dictkey_id,
                          JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            return res;
        }
SWIGINTERN PyObject *pdf_annot_s_setInfo(struct pdf_annot_s *self,PyObject *info,char *content,char *title,char *creationDate,char *modDate,char *subject){
            // use this to indicate a 'markup' annot type
            int is_markup = pdf_annot_has_author(gctx, self);
            fz_try(gctx)
            {
                // contents
                if (content)
                    pdf_set_annot_contents(gctx, self, content);

                if (is_markup)
                {
                    // title (= author)
                    if (title)
                        pdf_set_annot_author(gctx, self, title);

                    // creation date
                    if (creationDate)
                        pdf_dict_put_text_string(gctx, self->obj,
                                                 PDF_NAME(CreationDate), creationDate);

                    // mod date
                    if (modDate)
                        pdf_dict_put_text_string(gctx, self->obj,
                                                 PDF_NAME(M), modDate);

                    // subject
                    if (subject)
                        pdf_dict_puts_drop(gctx, self->obj, "Subj",
                                           pdf_new_text_string(gctx, subject));
                }
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *pdf_annot_s_border(struct pdf_annot_s *self){
            return JM_annot_border(gctx, self->obj);
        }
SWIGINTERN PyObject *pdf_annot_s_setBorder(struct pdf_annot_s *self,PyObject *border,float width,char *style,PyObject *dashes){
            return JM_annot_set_border(gctx, border, self->page->doc, self->obj);
        }
SWIGINTERN int pdf_annot_s_flags(struct pdf_annot_s *self){
            return pdf_annot_flags(gctx, self);
        }
SWIGINTERN PyObject *pdf_annot_s__cleanContents(struct pdf_annot_s *self){
            fz_try(gctx)
            {
                pdf_clean_annot_contents(gctx, self->page->doc, self,
                                         NULL, NULL, NULL, 1, 0);
            }
            fz_catch(gctx) return NULL;
            pdf_dirty_annot(gctx, self);
            return_none;
        }
SWIGINTERN void pdf_annot_s_setFlags(struct pdf_annot_s *self,int flags){
            pdf_set_annot_flags(gctx, self, flags);
        }
SWIGINTERN PyObject *pdf_annot_s_delete_responses(struct pdf_annot_s *self){
            pdf_page *page = self->page;
            pdf_annot *irt_annot = NULL;
            fz_try(gctx)
            {
                while (1)  // delete any /IRT annotations
                {
                    irt_annot = JM_find_annot_irt(gctx, self);
                    if (!irt_annot)  // no more there
                        break;
                    JM_delete_annot(gctx, page, irt_annot);
                }
                pdf_dict_del(gctx, self->obj, PDF_NAME(Popup));
                pdf_obj *annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                int i, n = pdf_array_len(gctx, annots), found = 0;
                for (i = n - 1; i >= 0; i--)
                {
                    pdf_obj *o = pdf_array_get(gctx, annots, i);
                    pdf_obj *p = pdf_dict_get(gctx, o, PDF_NAME(Parent));
                    if (!p)
                        continue;
                    if (!pdf_objcmp(gctx, p, self->obj))
                    {
                        pdf_array_delete(gctx, annots, i);
                        found = 1;
                    }
                }
                if (found > 0)
                {
                    pdf_dict_put(gctx, page->obj, PDF_NAME(Annots), annots);
                }
            }
            fz_catch(gctx) return NULL;
            pdf_dirty_annot(gctx, self);
            return_none;
        }
SWIGINTERN struct pdf_annot_s *pdf_annot_s_next(struct pdf_annot_s *self){
            int type = pdf_annot_type(gctx, self);
            pdf_annot *annot = NULL;

            if (type != PDF_ANNOT_WIDGET)
                annot = pdf_next_annot(gctx, self);
            else
                annot = pdf_next_widget(gctx, self);

            if (annot)
                pdf_keep_annot(gctx, annot);
            return annot;
        }
SWIGINTERN void delete_fz_link_s(struct fz_link_s *self){
            DEBUGMSG1("link");
            fz_drop_link(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_link_s__border(struct fz_link_s *self,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return_none;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return_none;
            PyObject *b = JM_annot_border(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__setBorder(struct fz_link_s *self,PyObject *border,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return_none;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return_none;
            PyObject *b = JM_annot_set_border(gctx, border, pdf, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__colors(struct fz_link_s *self,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) return_none;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return_none;
            PyObject *b = JM_annot_colors(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *fz_link_s__setColors(struct fz_link_s *self,PyObject *colors,struct fz_document_s *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, doc);
            pdf_obj *arr = NULL;
            int i;
            if (!pdf) return_none;
            if (!PyDict_Check(colors)) return_none;
            float scol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nscol = 0;
            float fcol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nfcol = 0;
            PyObject *stroke = PyDict_GetItem(colors, dictkey_stroke);
            PyObject *fill = PyDict_GetItem(colors, dictkey_fill);
            JM_color_FromSequence(stroke, &nscol, scol);
            JM_color_FromSequence(fill, &nfcol, fcol);
            if (!nscol && !nfcol) return_none;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) return_none;
            if (nscol > 0)
            {
                arr = pdf_new_array(gctx, pdf, nscol);
                for (i = 0; i < nscol; i++)
                    pdf_array_push_real(gctx, arr, scol[i]);
                pdf_dict_put_drop(gctx, link_obj, PDF_NAME(C), arr);
            }
            if (nfcol > 0) JM_Warning("this annot type has no fill color)");
            pdf_drop_obj(gctx, link_obj);
            return_none;
        }
SWIGINTERN PyObject *fz_link_s_uri(struct fz_link_s *self){
            return JM_UnicodeFromStr(self->uri);
        }
SWIGINTERN PyObject *fz_link_s_isExternal(struct fz_link_s *self){
            if (!self->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, self->uri));
        }
SWIGINTERN PyObject *fz_link_s_rect(struct fz_link_s *self){
            return JM_py_from_rect(self->rect);
        }
SWIGINTERN struct fz_link_s *fz_link_s_next(struct fz_link_s *self){
            fz_keep_link(gctx, self->next);
            return self->next;
        }
SWIGINTERN void delete_fz_display_list_s(struct fz_display_list_s *self){
            DEBUGMSG1("display list");
            fz_drop_display_list(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct fz_display_list_s *new_fz_display_list_s(PyObject *mediabox){
            struct fz_display_list_s *dl = NULL;
            fz_try(gctx)
                dl = fz_new_display_list(gctx, JM_rect_from_py(mediabox));
            fz_catch(gctx) return NULL;
            return dl;
        }
SWIGINTERN PyObject *fz_display_list_s_run(struct fz_display_list_s *self,struct DeviceWrapper *dw,PyObject *m,PyObject *area){
            fz_try(gctx)
            {
                fz_run_display_list(gctx, self, dw->device,
                    JM_matrix_from_py(m), JM_rect_from_py(area), NULL);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_display_list_s_rect(struct fz_display_list_s *self){
            return JM_py_from_rect(fz_bound_display_list(gctx, self));
        }
SWIGINTERN struct fz_pixmap_s *fz_display_list_s_getPixmap(struct fz_display_list_s *self,PyObject *matrix,struct fz_colorspace_s *colorspace,int alpha,PyObject *clip){
            struct fz_colorspace_s *cs = NULL;
            fz_pixmap *pix = NULL;

            if (colorspace) cs = colorspace;
            else cs = fz_device_rgb(gctx);

            fz_try(gctx)
            {
                pix = JM_pixmap_from_display_list(gctx, self, matrix, cs,
                                                  alpha, clip, NULL);
            }
            fz_catch(gctx) return NULL;
            return pix;
        }
SWIGINTERN struct fz_stext_page_s *fz_display_list_s_getTextPage(struct fz_display_list_s *self,int flags){
            struct fz_stext_page_s *tp = NULL;
            fz_try(gctx)
            {
                fz_stext_options stext_options = { 0 };
                stext_options.flags = flags;
                tp = fz_new_stext_page_from_display_list(gctx, self, &stext_options);
            }
            fz_catch(gctx) return NULL;
            return tp;
        }
SWIGINTERN struct fz_stext_page_s *new_fz_stext_page_s(PyObject *mediabox){
            struct fz_stext_page_s *tp = NULL;
            fz_try(gctx)
                tp = fz_new_stext_page(gctx, JM_rect_from_py(mediabox));
            fz_catch(gctx) return NULL;
            return tp;
        }
SWIGINTERN void delete_fz_stext_page_s(struct fz_stext_page_s *self){
            DEBUGMSG1("text page");
            fz_drop_stext_page(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *fz_stext_page_s_search(struct fz_stext_page_s *self,char const *needle,int hit_max,int quads){
            fz_quad *result = NULL;
            PyObject *liste = PyList_New(0);
            int i, mymax = hit_max;
            if (mymax < 1) mymax = 16;
            result = JM_Alloc(fz_quad, (mymax+1));
            struct fz_quad_s *quad = (struct fz_quad_s *) result;
            int count = fz_search_stext_page(gctx, self, needle, result, hit_max);
            for (i = 0; i < count; i++)
            {
                LIST_APPEND_DROP(liste, JM_py_from_quad(*quad));
                quad += 1;
            }
            JM_Free(result);
            return liste;
        }
SWIGINTERN PyObject *fz_stext_page_s__getNewBlockList(struct fz_stext_page_s *self,PyObject *page_dict,int raw){
            fz_try(gctx)
            {
                JM_make_textpage_dict(gctx, self, page_dict, raw);
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *fz_stext_page_s_extractBLOCKS(struct fz_stext_page_s *self,PyObject *lines){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            int block_n = 0;
            PyObject *text = NULL, *litem;
            fz_buffer *res = NULL;
            fz_var(res);

            fz_try(gctx)
            {
                res = fz_new_buffer(gctx, 1024);
                for (block = self->first_block; block; block = block->next)
                {
                    fz_rect blockrect = block->bbox;
                    if (block->type == FZ_STEXT_BLOCK_TEXT)
                    {
                        fz_clear_buffer(gctx, res);  // set text buffer to empty
                        int line_n = 0;
                        float last_y0 = 0.0;
                        for (line = block->u.t.first_line; line; line = line->next)
                        {
                            fz_rect linerect = line->bbox;
                            // append line no. 2 with new-line
                            if (line_n > 0)
                            {
                                if (linerect.y0 != last_y0)
                                    fz_append_string(gctx, res, "\n");
                                else
                                    fz_append_string(gctx, res, " ");
                            }
                            last_y0 = linerect.y0;
                            line_n++;
                            for (ch = line->first_char; ch; ch = ch->next)
                            {
                                JM_append_rune(gctx, res, ch->c);
                                linerect = fz_union_rect(linerect, JM_char_bbox(line, ch));
                            }
                            blockrect = fz_union_rect(blockrect, linerect);
                        }
                        text = JM_EscapeStrFromBuffer(gctx, res);
                    }
                    else
                    {
                        fz_image *img = block->u.i.image;
                        fz_colorspace *cs = img->colorspace;
                        text = PyUnicode_FromFormat("<image: %s, width %d, height %d, bpc %d>", fz_colorspace_name(gctx, cs), img->w, img->h, img->bpc);
                        blockrect = fz_union_rect(blockrect, block->bbox);
                    }
                    litem = PyTuple_New(7);
                    PyTuple_SET_ITEM(litem, 0, Py_BuildValue("f", blockrect.x0));
                    PyTuple_SET_ITEM(litem, 1, Py_BuildValue("f", blockrect.y0));
                    PyTuple_SET_ITEM(litem, 2, Py_BuildValue("f", blockrect.x1));
                    PyTuple_SET_ITEM(litem, 3, Py_BuildValue("f", blockrect.y1));
                    PyTuple_SET_ITEM(litem, 4, Py_BuildValue("O", text));
                    PyTuple_SET_ITEM(litem, 5, Py_BuildValue("i", block_n));
                    PyTuple_SET_ITEM(litem, 6, Py_BuildValue("i", block->type));
                    LIST_APPEND_DROP(lines, litem);
                    Py_DECREF(text);
                    block_n++;
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                PyErr_Clear();
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *fz_stext_page_s_extractWORDS(struct fz_stext_page_s *self,PyObject *lines){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            fz_buffer *buff = NULL;
            fz_var(buff);
            size_t buflen = 0;
            int block_n = 0, line_n, word_n;
            fz_rect wbbox = {0,0,0,0};          // word bbox

            fz_try(gctx)
            {
                buff = fz_new_buffer(gctx, 64);
                for (block = self->first_block; block; block = block->next)
                {
                    if (block->type != FZ_STEXT_BLOCK_TEXT)
                    {
                        block_n++;
                        continue;
                    }
                    line_n = 0;
                    for (line = block->u.t.first_line; line; line = line->next)
                    {
                        word_n = 0;                       // word counter per line
                        fz_clear_buffer(gctx, buff);      // reset word buffer
                        buflen = 0;                       // reset char counter
                        for (ch = line->first_char; ch; ch = ch->next)
                        {
                            if (ch->c == 32 && buflen == 0)
                                continue;                 // skip spaces at line start
                            if (ch->c == 32)
                            {   // --> finish the word
                                word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                        block_n, line_n, word_n);
                                fz_clear_buffer(gctx, buff);
                                buflen = 0;               // reset char counter
                                continue;
                            }
                            // append one unicode character to the word
                            JM_append_rune(gctx, buff, ch->c);
                            buflen++;
                            // enlarge word bbox
                            wbbox = fz_union_rect(wbbox, JM_char_bbox(line, ch));
                        }
                        if (buflen)                         // store any remaining word
                        {
                            word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                    block_n, line_n, word_n);
                            fz_clear_buffer(gctx, buff);
                            buflen = 0;
                        }
                        line_n++;
                    }
                    block_n++;
                }
            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, buff);
                PyErr_Clear();
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *fz_stext_page_s_rect(struct fz_stext_page_s *self){
            fz_rect mediabox = self->mediabox;
            return JM_py_from_rect(mediabox);
        }
SWIGINTERN PyObject *fz_stext_page_s__extractText(struct fz_stext_page_s *self,int format){
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_var(res);
            fz_var(out);
            fz_try(gctx)
            {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                switch(format)
                {
                    case(1):
                        fz_print_stext_page_as_html(gctx, out, self, 0);
                        break;
                    case(3):
                        fz_print_stext_page_as_xml(gctx, out, self, 0);
                        break;
                    case(4):
                        fz_print_stext_page_as_xhtml(gctx, out, self, 0);
                        break;
                    default:
                        JM_print_stext_page_as_text(gctx, out, self);
                        text = JM_EscapeStrFromBuffer(gctx, res);
                        break;
                }
                if (!text) text = JM_EscapeStrFromBuffer(gctx, res);

            }
            fz_always(gctx)
            {
                fz_drop_buffer(gctx, res);
                fz_drop_output(gctx, out);
            }
            fz_catch(gctx) return NULL;

            return text;
        }
SWIGINTERN void delete_pdf_graft_map_s(struct pdf_graft_map_s *self){
            DEBUGMSG1("graftmap");
            pdf_drop_graft_map(gctx, self);
            DEBUGMSG2;
        }
SWIGINTERN struct pdf_graft_map_s *new_pdf_graft_map_s(struct fz_document_s *doc){
            pdf_graft_map *map = NULL;
            fz_try(gctx)
            {
                pdf_document *dst = pdf_specifics(gctx, doc);
                assert_PDF(dst);
                map = pdf_new_graft_map(gctx, dst);
            }
            fz_catch(gctx) return NULL;
            return map;
        }
SWIGINTERN PyObject *Tools_gen_id(struct Tools *self){
            JM_UNIQUE_ID += 1;
            if (JM_UNIQUE_ID < 0) JM_UNIQUE_ID = 1;
            return Py_BuildValue("i", JM_UNIQUE_ID);
        }
SWIGINTERN PyObject *Tools_set_icc(struct Tools *self,int on){
            fz_try(gctx)
            {
                if (on)
                {
                    if (FZ_ENABLE_ICC)
                        fz_enable_icc(gctx);
                    else
                        THROWMSG("PyMuPDF generated without ICC components.");
                }
                else if (FZ_ENABLE_ICC)
                {
                    fz_disable_icc(gctx);
                }
            }
            fz_catch(gctx)
            {
                return NULL;
            }
            return_none;
        }
SWIGINTERN PyObject *Tools_store_shrink(struct Tools *self,int percent){
            if (percent >= 100)
            {
                fz_empty_store(gctx);
                return Py_BuildValue("i", 0);
            }
            if (percent > 0) fz_shrink_store(gctx, 100 - percent);
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_show_aa_level(struct Tools *self){
            return Py_BuildValue("iif",
                fz_graphics_aa_level(gctx),
                fz_text_aa_level(gctx),
                fz_graphics_min_line_width(gctx));
        }
SWIGINTERN void Tools_set_aa_level(struct Tools *self,int level){
            fz_set_aa_level(gctx, level);
        }
SWIGINTERN void Tools_set_graphics_min_line_width(struct Tools *self,float min_line_width){
            fz_set_graphics_min_line_width(gctx, min_line_width);
        }
SWIGINTERN PyObject *Tools_image_profile(struct Tools *self,PyObject *stream,int keep_image){
            return JM_image_profile(gctx, stream, keep_image);
        }
SWIGINTERN PyObject *Tools__derotate_point(struct Tools *self,struct fz_page_s *page,PyObject *point){
            pdf_page *pdf_page = pdf_page_from_fz_page(gctx, page);
            if (!pdf_page)
                return point;
            return JM_py_from_point(JM_derotate_point(gctx, pdf_page, JM_point_from_py(point)));
        }
SWIGINTERN PyObject *Tools__derotate_rect(struct Tools *self,struct fz_page_s *page,PyObject *rect){
            pdf_page *pdf_page = pdf_page_from_fz_page(gctx, page);
            if (!pdf_page)
                return rect;
            return JM_py_from_rect(JM_derotate_rect(gctx, pdf_page, JM_rect_from_py(rect)));
        }
SWIGINTERN PyObject *Tools__rotate_point(struct Tools *self,struct fz_page_s *page,PyObject *point){
            pdf_page *pdf_page = pdf_page_from_fz_page(gctx, page);
            if (!pdf_page)
                return point;
            return JM_py_from_point(JM_rotate_point(gctx, pdf_page, JM_point_from_py(point)));
        }
SWIGINTERN PyObject *Tools__rotate_rect(struct Tools *self,struct fz_page_s *page,PyObject *rect){
            pdf_page *pdf_page = pdf_page_from_fz_page(gctx, page);
            if (!pdf_page)
                return rect;
            return JM_py_from_rect(JM_rotate_rect(gctx, pdf_page, JM_rect_from_py(rect)));
        }
SWIGINTERN PyObject *Tools_store_size(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_store_maxsize(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->max);
        }
SWIGINTERN PyObject *Tools_fitz_config(struct Tools *self){
            return JM_fitz_config();
        }
SWIGINTERN void Tools_glyph_cache_empty(struct Tools *self){
            fz_purge_glyph_cache(gctx);
        }
SWIGINTERN PyObject *Tools__fill_widget(struct Tools *self,struct pdf_annot_s *annot,PyObject *widget){
            fz_try(gctx)
            {
                JM_get_widget_properties(gctx, annot, widget);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *Tools__save_widget(struct Tools *self,struct pdf_annot_s *annot,PyObject *widget){
            fz_try(gctx)
            {
                JM_set_widget_properties(gctx, annot, widget);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *Tools__reset_widget(struct Tools *self,struct pdf_annot_s *annot){
            fz_try(gctx)
            {
                pdf_document *pdf = pdf_get_bound_document(gctx, annot->obj);
                pdf_field_reset(gctx, pdf, annot->obj);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *Tools__parse_da(struct Tools *self,struct pdf_annot_s *annot){
            char *da_str = NULL;
            fz_try(gctx)
            {
                pdf_obj *da = pdf_dict_get_inheritable(gctx, annot->obj,
                                                       PDF_NAME(DA));
                if (!da)
                {
                    pdf_obj *trailer = pdf_trailer(gctx, annot->page->doc);
                    da = pdf_dict_getl(gctx, trailer, PDF_NAME(Root),
                                       PDF_NAME(AcroForm),
                                       PDF_NAME(DA),
                                       NULL);
                }
                da_str = (char *) pdf_to_text_string(gctx, da);
            }
            fz_catch(gctx) return NULL;
            return JM_UnicodeFromStr(da_str);
        }
SWIGINTERN PyObject *Tools__update_da(struct Tools *self,struct pdf_annot_s *annot,char *da_str){
            fz_try(gctx)
            {
                pdf_dict_put_text_string(gctx, annot->obj, PDF_NAME(DA), da_str);
                pdf_dict_del(gctx, annot->obj, PDF_NAME(DS)); /* not supported */
                pdf_dict_del(gctx, annot->obj, PDF_NAME(RC)); /* not supported */
                pdf_dirty_annot(gctx, annot);
            }
            fz_catch(gctx) return NULL;
            return_none;
        }
SWIGINTERN PyObject *Tools__insert_contents(struct Tools *self,struct fz_page_s *page,PyObject *newcont,int overlay){
            fz_buffer *contbuf = NULL;
            int xref = 0;
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, page);
            fz_try(gctx)
            {
                assert_PDF(pdfpage);
                contbuf = JM_BufferFromBytes(gctx, newcont);
                xref = JM_insert_contents(gctx, pdfpage->doc, pdfpage->obj, contbuf, overlay);
                pdfpage->doc->dirty = 1;
            }
            fz_always(gctx) {fz_drop_buffer(gctx, contbuf);}
            fz_catch(gctx) {return NULL;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Tools_mupdf_version(struct Tools *self){
            return JM_UnicodeFromStr(FZ_VERSION);
        }
SWIGINTERN PyObject *Tools_mupdf_warnings(struct Tools *self,int reset){
            Py_INCREF(JM_mupdf_warnings_store);
            return JM_mupdf_warnings_store;
        }
SWIGINTERN void Tools_reset_mupdf_warnings(struct Tools *self){
            Py_CLEAR(JM_mupdf_warnings_store);
            JM_mupdf_warnings_store = PyList_New(0);
        }
SWIGINTERN PyObject *Tools_mupdf_display_errors(struct Tools *self,PyObject *value){
            if (value == Py_True)
                JM_mupdf_show_errors = Py_True;
            else if (value == Py_False)
                JM_mupdf_show_errors = Py_False;
            Py_INCREF(JM_mupdf_show_errors);
            return JM_mupdf_show_errors;
        }
SWIGINTERN PyObject *Tools__transform_rect(struct Tools *self,PyObject *rect,PyObject *matrix){
            return JM_py_from_rect(fz_transform_rect(JM_rect_from_py(rect), JM_matrix_from_py(matrix)));
        }
SWIGINTERN PyObject *Tools__intersect_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_intersect_rect(JM_rect_from_py(r1),
                                                     JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__include_point_in_rect(struct Tools *self,PyObject *r,PyObject *p){
            return JM_py_from_rect(fz_include_point_in_rect(JM_rect_from_py(r),
                                                     JM_point_from_py(p)));
        }
SWIGINTERN PyObject *Tools__transform_point(struct Tools *self,PyObject *point,PyObject *matrix){
            return JM_py_from_point(fz_transform_point(JM_point_from_py(point), JM_matrix_from_py(matrix)));
        }
SWIGINTERN PyObject *Tools__union_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_union_rect(JM_rect_from_py(r1),
                                                 JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__concat_matrix(struct Tools *self,PyObject *m1,PyObject *m2){
            return JM_py_from_matrix(fz_concat(JM_matrix_from_py(m1),
                                               JM_matrix_from_py(m2)));
        }
SWIGINTERN PyObject *Tools__invert_matrix(struct Tools *self,PyObject *matrix){
            fz_matrix src = JM_matrix_from_py(matrix);
            float a = src.a;
            float det = a * src.d - src.b * src.c;
            if (det < -FLT_EPSILON || det > FLT_EPSILON)
            {
                fz_matrix dst;
                float rdet = 1 / det;
                dst.a = src.d * rdet;
                dst.b = -src.b * rdet;
                dst.c = -src.c * rdet;
                dst.d = a * rdet;
                a = -src.e * dst.a - src.f * dst.c;
                dst.f = -src.e * dst.b - src.f * dst.d;
                dst.e = a;
                return Py_BuildValue("(i, O)", 0, JM_py_from_matrix(dst));
            }
            return Py_BuildValue("(i, ())", 1);
        }
SWIGINTERN float Tools_measure_string(struct Tools *self,char const *text,char const *fontname,float fontsize,int encoding){
            fz_font *font = fz_new_base14_font(gctx, fontname);
            float w = 0;
            while (*text)
            {
                int c, g;
                text += fz_chartorune(&c, text);
                switch (encoding)
                {
                    case PDF_SIMPLE_ENCODING_GREEK:
                        c = fz_iso8859_7_from_unicode(c); break;
                    case PDF_SIMPLE_ENCODING_CYRILLIC:
                        c = fz_windows_1251_from_unicode(c); break;
                    default:
                        c = fz_windows_1252_from_unicode(c); break;
                }
                if (c < 0) c = 0xB7;
                g = fz_encode_character(gctx, font, c);
                w += fz_advance_glyph(gctx, font, g, 0);
            }
            return w * fontsize;
        }

SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}

#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Document" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  delete_fz_document_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) NULL ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  float arg5 = (float) 0 ;
  float arg6 = (float) 0 ;
  float arg7 = (float) 11 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  struct fz_document_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_Document", 0, 7, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Document" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
  }
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Document" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Document" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_float(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Document" "', argument " "6"" of type '" "float""'");
    } 
    arg6 = (float)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_float(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Document" "', argument " "7"" of type '" "float""'");
    } 
    arg7 = (float)(val7);
  }
  {
    result = (struct fz_document_s *)new_fz_document_s((char const *)arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_document_s, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_close(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_close" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  fz_document_s_close(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_loadPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct fz_page_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_loadPage", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_loadPage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_loadPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_page_s *)fz_document_s_loadPage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_page_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__remove_links_to(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__remove_links_to", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__remove_links_to" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__remove_links_to" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__remove_links_to" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_document_s__remove_links_to(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__loadOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_outline_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__loadOutline" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (struct fz_outline_s *)fz_document_s__loadOutline(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__dropOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  struct fz_outline_s *arg2 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__dropOutline", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__dropOutline" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__dropOutline" "', argument " "2"" of type '" "struct fz_outline_s *""'"); 
  }
  arg2 = (struct fz_outline_s *)(argp2);
  fz_document_s__dropOutline(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileNames", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileNames" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_document_s__embeddedFileNames(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileDel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileDel", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileDel" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embeddedFileDel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__embeddedFileDel(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileInfo", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileInfo" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embeddedFileInfo" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)fz_document_s__embeddedFileInfo(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileUpd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileUpd", 2, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileUpd" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embeddedFileUpd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__embeddedFileUpd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document__embeddedFileUpd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document__embeddedFileUpd" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)fz_document_s__embeddedFileUpd(arg1,arg2,arg3,arg4,arg5,arg6);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileGet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileGet", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileGet" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embeddedFileGet" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__embeddedFileGet(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileAdd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileAdd", 3, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileAdd" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__embeddedFileAdd" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  arg3 = swig_obj[2];
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__embeddedFileAdd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document__embeddedFileAdd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document__embeddedFileAdd" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)fz_document_s__embeddedFileAdd(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_convertToPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_convertToPDF", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_convertToPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_convertToPDF" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_convertToPDF" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_convertToPDF" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)fz_document_s_convertToPDF(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_pageCount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_pageCount" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_pageCount(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getMetadata", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__getMetadata" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  result = (char *)fz_document_s__getMetadata(arg1,(char const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_needsPass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_needsPass" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_needsPass(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_resolveLink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_resolveLink", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_resolveLink" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_resolveLink" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  result = (PyObject *)fz_document_s_resolveLink(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_layout(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  float arg3 = (float) 0 ;
  float arg4 = (float) 0 ;
  float arg5 = (float) 11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_layout", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_layout" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_layout" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_layout" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_layout" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  {
    result = (PyObject *)fz_document_s_layout(arg1,arg2,arg3,arg4,arg5);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_makeBookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_makeBookmark", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_makeBookmark" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_makeBookmark" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)fz_document_s_makeBookmark(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_findBookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  long long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_findBookmark", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_findBookmark" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_findBookmark" "', argument " "2"" of type '" "long long""'");
  } 
  arg2 = (long long)(val2);
  result = (PyObject *)fz_document_s_findBookmark(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isReflowable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isReflowable" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isReflowable(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__deleteObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__deleteObject", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__deleteObject" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__deleteObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__deleteObject(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPDFroot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPDFroot" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getPDFroot(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPDFfileid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPDFfileid" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getPDFfileid(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isPDF(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__hasXrefStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__hasXrefStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__hasXrefStream(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__hasXrefOldStyle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__hasXrefOldStyle" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__hasXrefOldStyle(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isDirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isDirty" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isDirty(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_can_save_incrementally(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_can_save_incrementally" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_can_save_incrementally(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_authenticate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_authenticate", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_authenticate" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_authenticate" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (PyObject *)fz_document_s_authenticate(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  int arg10 = (int) 0 ;
  int arg11 = (int) 1 ;
  int arg12 = (int) -1 ;
  char *arg13 = (char *) NULL ;
  char *arg14 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int res13 ;
  char *buf13 = 0 ;
  int alloc13 = 0 ;
  int res14 ;
  char *buf14 = 0 ;
  int alloc14 = 0 ;
  PyObject *swig_obj[14] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_save", 2, 14, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_save" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_save" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_save" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_save" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_save" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_save" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_save" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_save" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_save" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_save" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    ecode11 = SWIG_AsVal_int(swig_obj[10], &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Document_save" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = (int)(val11);
  }
  if (swig_obj[11]) {
    ecode12 = SWIG_AsVal_int(swig_obj[11], &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "Document_save" "', argument " "12"" of type '" "int""'");
    } 
    arg12 = (int)(val12);
  }
  if (swig_obj[12]) {
    res13 = SWIG_AsCharPtrAndSize(swig_obj[12], &buf13, NULL, &alloc13);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "Document_save" "', argument " "13"" of type '" "char *""'");
    }
    arg13 = (char *)(buf13);
  }
  if (swig_obj[13]) {
    res14 = SWIG_AsCharPtrAndSize(swig_obj[13], &buf14, NULL, &alloc14);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "Document_save" "', argument " "14"" of type '" "char *""'");
    }
    arg14 = (char *)(buf14);
  }
  {
    result = (PyObject *)fz_document_s_save(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc13 == SWIG_NEWOBJ) free((char*)buf13);
  if (alloc14 == SWIG_NEWOBJ) free((char*)buf14);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc13 == SWIG_NEWOBJ) free((char*)buf13);
  if (alloc14 == SWIG_NEWOBJ) free((char*)buf14);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_write(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 1 ;
  int arg10 = (int) -1 ;
  char *arg11 = (char *) NULL ;
  char *arg12 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int res11 ;
  char *buf11 = 0 ;
  int alloc11 = 0 ;
  int res12 ;
  char *buf12 = 0 ;
  int alloc12 = 0 ;
  PyObject *swig_obj[12] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_write", 1, 12, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_write" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_write" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_write" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_write" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_write" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_write" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_write" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_write" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_write" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_write" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    res11 = SWIG_AsCharPtrAndSize(swig_obj[10], &buf11, NULL, &alloc11);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "Document_write" "', argument " "11"" of type '" "char *""'");
    }
    arg11 = (char *)(buf11);
  }
  if (swig_obj[11]) {
    res12 = SWIG_AsCharPtrAndSize(swig_obj[11], &buf12, NULL, &alloc12);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "Document_write" "', argument " "12"" of type '" "char *""'");
    }
    arg12 = (char *)(buf12);
  }
  {
    result = (PyObject *)fz_document_s_write(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
  if (alloc12 == SWIG_NEWOBJ) free((char*)buf12);
  return resultobj;
fail:
  if (alloc11 == SWIG_NEWOBJ) free((char*)buf11);
  if (alloc12 == SWIG_NEWOBJ) free((char*)buf12);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_insertPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  int arg8 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[8] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_insertPDF", 2, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_insertPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_insertPDF" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_insertPDF" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_insertPDF" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_insertPDF" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_insertPDF" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_insertPDF" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_insertPDF" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  {
    result = (PyObject *)fz_document_s_insertPDF(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__newPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) -1 ;
  float arg3 = (float) 595 ;
  float arg4 = (float) 842 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__newPage", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__newPage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__newPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__newPage" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__newPage" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  {
    result = (PyObject *)fz_document_s__newPage(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_select(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_select", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_select" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_document_s_select(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__deletePage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__deletePage", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__deletePage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__deletePage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__deletePage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_permissions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_permissions" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_permissions(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getCharWidths(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getCharWidths", 6, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getCharWidths" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getCharWidths" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__getCharWidths" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__getCharWidths" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__getCharWidths" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document__getCharWidths" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document__getCharWidths" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (PyObject *)fz_document_s__getCharWidths(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPageObjNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getPageObjNumber", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPageObjNumber" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getPageObjNumber" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getPageObjNumber(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPageInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getPageInfo", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPageInfo" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getPageInfo" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__getPageInfo" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_document_s__getPageInfo(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extractFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_extractFont", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extractFont" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extractFont" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_extractFont" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)fz_document_s_extractFont(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extractImage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_extractImage", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extractImage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extractImage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s_extractImage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delToC(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delToC" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__delToC(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_isStream", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_isStream" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)fz_document_s_isStream(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_getSigFlags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_getSigFlags" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_getSigFlags(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_isFormPDF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_isFormPDF" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_isFormPDF(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_FormFonts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_FormFonts" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s_FormFonts(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__addFormFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__addFormFont", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__addFormFont" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__addFormFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__addFormFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (PyObject *)fz_document_s__addFormFont(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getOLRootNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getOLRootNumber" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__getOLRootNumber(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getNewXref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getNewXref" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__getNewXref(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefLength" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getXrefLength(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXmlMetadataXref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXmlMetadataXref" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  result = (PyObject *)fz_document_s__getXmlMetadataXref(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delXmlMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delXmlMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__delXmlMetadata(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getXrefString", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefString" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getXrefString" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__getXrefString" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__getXrefString" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)fz_document_s__getXrefString(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getTrailerString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getTrailerString", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getTrailerString" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getTrailerString" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__getTrailerString" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)fz_document_s__getTrailerString(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefStreamRaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getXrefStreamRaw", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefStreamRaw" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getXrefStreamRaw" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getXrefStreamRaw(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getXrefStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getXrefStream", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getXrefStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getXrefStream" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_document_s__getXrefStream(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__updateObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  struct fz_page_s *arg4 = (struct fz_page_s *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__updateObject", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__updateObject" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__updateObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__updateObject" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_fz_page_s, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__updateObject" "', argument " "4"" of type '" "struct fz_page_s *""'"); 
    }
    arg4 = (struct fz_page_s *)(argp4);
  }
  {
    result = (PyObject *)fz_document_s__updateObject(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__updateStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 = (int) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__updateStream", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__updateStream" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__updateStream" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__updateStream" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)fz_document_s__updateStream(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__setMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__setMetadata", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__setMetadata" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__setMetadata" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)fz_document_s__setMetadata(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__make_page_map(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__make_page_map" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (PyObject *)fz_document_s__make_page_map(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_fullcopyPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_fullcopyPage", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_fullcopyPage" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_fullcopyPage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_fullcopyPage" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)fz_document_s_fullcopyPage(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__move_copy_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__move_copy_page", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__move_copy_page" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__move_copy_page" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__move_copy_page" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__move_copy_page" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__move_copy_page" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    result = (PyObject *)fz_document_s__move_copy_page(arg1,arg2,arg3,arg4,arg5);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Document_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_document_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Document_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Page" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  delete_fz_page_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_bound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_bound" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_bound(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_run", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_run" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)fz_page_s_run(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_getTextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct fz_stext_page_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_getTextPage", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_getTextPage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_getTextPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_stext_page_s *)fz_page_s_getTextPage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_getSVGimage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_getSVGimage", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_getSVGimage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  {
    result = (PyObject *)fz_page_s_getSVGimage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addCaretAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addCaretAnnot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addCaretAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct pdf_annot_s *)fz_page_s_addCaretAnnot(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addRedactAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  char *arg4 = (char *) NULL ;
  float arg5 = (float) 11 ;
  int arg6 = (int) 0 ;
  PyObject *arg7 = (PyObject *) NULL ;
  PyObject *arg8 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[8] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addRedactAnnot", 2, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addRedactAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page_addRedactAnnot" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page_addRedactAnnot" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page_addRedactAnnot" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    arg8 = swig_obj[7];
  }
  {
    result = (struct pdf_annot_s *)fz_page_s_addRedactAnnot(arg1,arg2,arg3,(char const *)arg4,arg5,arg6,arg7,arg8);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addLineAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addLineAnnot", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addLineAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  {
    result = (struct pdf_annot_s *)fz_page_s_addLineAnnot(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addTextAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[4] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addTextAnnot", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addTextAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page_addTextAnnot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page_addTextAnnot" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  {
    result = (struct pdf_annot_s *)fz_page_s_addTextAnnot(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addInkAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addInkAnnot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addInkAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct pdf_annot_s *)fz_page_s_addInkAnnot(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addStampAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addStampAnnot", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addStampAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page_addStampAnnot" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct pdf_annot_s *)fz_page_s_addStampAnnot(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addFileAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  char *arg7 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject *swig_obj[7] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addFileAnnot", 4, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addFileAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page_addFileAnnot" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page_addFileAnnot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Page_addFileAnnot" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    res7 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Page_addFileAnnot" "', argument " "7"" of type '" "char *""'");
    }
    arg7 = (char *)(buf7);
  }
  {
    result = (struct pdf_annot_s *)fz_page_s_addFileAnnot(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_text_marker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_text_marker", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_text_marker" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_text_marker" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct pdf_annot_s *)fz_page_s__add_text_marker(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_square_or_circle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_square_or_circle", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_square_or_circle" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_square_or_circle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct pdf_annot_s *)fz_page_s__add_square_or_circle(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_multiline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_multiline", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_multiline" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_multiline" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct pdf_annot_s *)fz_page_s__add_multiline(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_addFreetextAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 = (float) 12 ;
  char *arg5 = (char *) NULL ;
  PyObject *arg6 = (PyObject *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  int arg8 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject *swig_obj[8] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_addFreetextAnnot", 3, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_addFreetextAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page_addFreetextAnnot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page_addFreetextAnnot" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page_addFreetextAnnot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page_addFreetextAnnot" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  {
    result = (struct pdf_annot_s *)fz_page_s_addFreetextAnnot(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_load_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_load_annot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_load_annot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_load_annot" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (struct pdf_annot_s *)fz_page_s_load_annot(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_annot_names(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_annot_names" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_annot_names(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__addWidget", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addWidget" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct pdf_annot_s *)fz_page_s__addWidget(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_getDisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct fz_display_list_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_getDisplayList", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_getDisplayList" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_getDisplayList" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_display_list_s *)fz_page_s_getDisplayList(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__apply_redactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__apply_redactions" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (PyObject *)fz_page_s__apply_redactions(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__makePixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  struct fz_colorspace_s *arg4 = (struct fz_colorspace_s *) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 1 ;
  PyObject *arg7 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[7] ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__makePixmap", 4, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__makePixmap" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__makePixmap" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  arg3 = swig_obj[2];
  res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__makePixmap" "', argument " "4"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg4 = (struct fz_colorspace_s *)(argp4);
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__makePixmap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__makePixmap" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  {
    result = (struct fz_pixmap_s *)fz_page_s__makePixmap(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_insertString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  float arg4 = (float) 11 ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  PyObject *arg8 = (PyObject *) NULL ;
  char *arg9 = (char *) NULL ;
  int arg10 = (int) 0 ;
  float arg11 = (float) 1 ;
  int arg12 = (int) -1 ;
  int arg13 = (int) 1 ;
  int arg14 = (int) 0 ;
  int arg15 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  float val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  int val15 ;
  int ecode15 = 0 ;
  PyObject *swig_obj[15] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_insertString", 3, 15, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_insertString" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page_insertString" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page_insertString" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Page_insertString" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    arg8 = swig_obj[7];
  }
  if (swig_obj[8]) {
    res9 = SWIG_AsCharPtrAndSize(swig_obj[8], &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Page_insertString" "', argument " "9"" of type '" "char *""'");
    }
    arg9 = (char *)(buf9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Page_insertString" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    ecode11 = SWIG_AsVal_float(swig_obj[10], &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Page_insertString" "', argument " "11"" of type '" "float""'");
    } 
    arg11 = (float)(val11);
  }
  if (swig_obj[11]) {
    ecode12 = SWIG_AsVal_int(swig_obj[11], &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "Page_insertString" "', argument " "12"" of type '" "int""'");
    } 
    arg12 = (int)(val12);
  }
  if (swig_obj[12]) {
    ecode13 = SWIG_AsVal_int(swig_obj[12], &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "Page_insertString" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = (int)(val13);
  }
  if (swig_obj[13]) {
    ecode14 = SWIG_AsVal_int(swig_obj[13], &val14);
    if (!SWIG_IsOK(ecode14)) {
      SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "Page_insertString" "', argument " "14"" of type '" "int""'");
    } 
    arg14 = (int)(val14);
  }
  if (swig_obj[14]) {
    ecode15 = SWIG_AsVal_int(swig_obj[14], &val15);
    if (!SWIG_IsOK(ecode15)) {
      SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "Page_insertString" "', argument " "15"" of type '" "int""'");
    } 
    arg15 = (int)(val15);
  }
  {
    result = (PyObject *)fz_page_s_insertString(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_setMediaBox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_setMediaBox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_setMediaBox" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_page_s_setMediaBox(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_setCropBox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_setCropBox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_setCropBox" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_page_s_setCropBox(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_loadLinks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_link_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_loadLinks" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (struct fz_link_s *)fz_page_s_loadLinks(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_link_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_firstAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_firstAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (struct pdf_annot_s *)fz_page_s_firstAnnot(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_firstWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_firstWidget" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (struct pdf_annot_s *)fz_page_s_firstWidget(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_deleteLink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_deleteLink", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_deleteLink" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  fz_page_s_deleteLink(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_deleteAnnot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_deleteAnnot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_deleteAnnot" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_deleteAnnot" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  result = (struct pdf_annot_s *)fz_page_s_deleteAnnot(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_MediaBox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_MediaBox" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_MediaBox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_CropBox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_CropBox" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s_CropBox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_rotation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (int)fz_page_s_rotation(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_setRotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_setRotation", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_setRotation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_setRotation" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_page_s_setRotation(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addAnnot_FromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__addAnnot_FromString", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addAnnot_FromString" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_page_s__addAnnot_FromString(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getLinkXrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getLinkXrefs" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s__getLinkXrefs(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__cleanContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__cleanContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s__cleanContents(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__showPDFpage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  int arg3 = (int) 1 ;
  PyObject *arg4 = (PyObject *) NULL ;
  int arg5 = (int) 0 ;
  PyObject *arg6 = (PyObject *) NULL ;
  struct pdf_graft_map_s *arg7 = (struct pdf_graft_map_s *) NULL ;
  char *arg8 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  PyObject *swig_obj[8] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__showPDFpage", 2, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__showPDFpage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__showPDFpage" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__showPDFpage" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__showPDFpage" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    res7 = SWIG_ConvertPtr(swig_obj[6], &argp7,SWIGTYPE_p_pdf_graft_map_s, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Page__showPDFpage" "', argument " "7"" of type '" "struct pdf_graft_map_s *""'"); 
    }
    arg7 = (struct pdf_graft_map_s *)(argp7);
  }
  if (swig_obj[7]) {
    res8 = SWIG_AsCharPtrAndSize(swig_obj[7], &buf8, NULL, &alloc8);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Page__showPDFpage" "', argument " "8"" of type '" "char *""'");
    }
    arg8 = (char *)(buf8);
  }
  {
    result = (PyObject *)fz_page_s__showPDFpage(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__insertImage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  char *arg2 = (char *) NULL ;
  struct fz_pixmap_s *arg3 = (struct fz_pixmap_s *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  int arg5 = (int) 1 ;
  PyObject *arg6 = (PyObject *) NULL ;
  char *arg7 = (char *) NULL ;
  PyObject *arg8 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject *swig_obj[8] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__insertImage", 1, 8, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__insertImage" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__insertImage" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__insertImage" "', argument " "3"" of type '" "struct fz_pixmap_s *""'"); 
    }
    arg3 = (struct fz_pixmap_s *)(argp3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__insertImage" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    res7 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Page__insertImage" "', argument " "7"" of type '" "char const *""'");
    }
    arg7 = (char *)(buf7);
  }
  if (swig_obj[7]) {
    arg8 = swig_obj[7];
  }
  {
    result = (PyObject *)fz_page_s__insertImage(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,(char const *)arg7,arg8);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_refresh(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_refresh" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (PyObject *)fz_page_s_refresh(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__insertFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  PyObject *arg5 = (PyObject *) 0 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  PyObject *swig_obj[11] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__insertFont", 11, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__insertFont" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__insertFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__insertFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__insertFont" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = swig_obj[4];
  ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__insertFont" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page__insertFont" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page__insertFont" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Page__insertFont" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Page__insertFont" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(swig_obj[10], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Page__insertFont" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  {
    result = (PyObject *)fz_page_s__insertFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getTransformation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getTransformation" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  result = (PyObject *)fz_page_s__getTransformation(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  {
    result = (PyObject *)fz_page_s__getContents(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__setContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_page_s *arg1 = (struct fz_page_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__setContents", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__setContents" "', argument " "1"" of type '" "struct fz_page_s *""'"); 
  }
  arg1 = (struct fz_page_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page__setContents" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)fz_page_s__setContents(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Page_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_page_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_Pixmap_x_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_x_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_x_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_x_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->x = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_x_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_x_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->x);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_y_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_y_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_y_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_y_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->y = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_y_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_y_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->y);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_w_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_w_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_w_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_w_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->w = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_w_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_w_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->w);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_h_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_h_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_h_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_h_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->h = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_h_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_h_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->h);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_n_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_n_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_n_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_n_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->n = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_n_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->n);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_xres_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_xres_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_xres_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_xres_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->xres = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_xres_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_xres_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->xres);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_yres_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_yres_set", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_yres_set" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_yres_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->yres = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_yres_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_yres_get" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int) ((arg1)->yres);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Pixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  delete_fz_pixmap_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_0(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  struct fz_pixmap_s *arg2 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg2 = (struct fz_pixmap_s *)(argp2);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_1(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  float arg2 ;
  float arg3 ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = (float)(val3);
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_2(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_3(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = swig_obj[3];
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Pixmap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_4(arg1,arg2,arg3,arg4,arg5);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = (char *)(buf1);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_5(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_6(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct fz_pixmap_s *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (struct fz_pixmap_s *)new_fz_pixmap_s__SWIG_7(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Pixmap", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Pixmap__SWIG_3(self, argc, argv);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Pixmap__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_Pixmap__SWIG_6(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Pixmap__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Pixmap__SWIG_0(self, argc, argv);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Pixmap__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_document_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_7(self, argc, argv);
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_float(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_float(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Pixmap__SWIG_2(self, argc, argv);
          }
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_Pixmap__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_colorspace_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Pixmap__SWIG_4(self, argc, argv);
            }
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Pixmap__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Pixmap'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,PyObject *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,struct fz_pixmap_s *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_pixmap_s *,float,float,PyObject *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_pixmap_s *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_colorspace_s *,int,int,PyObject *,int)\n"
    "    fz_pixmap_s::fz_pixmap_s(char *)\n"
    "    fz_pixmap_s::fz_pixmap_s(PyObject *)\n"
    "    fz_pixmap_s::fz_pixmap_s(struct fz_document_s *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_shrink", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_shrink" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  fz_pixmap_s_shrink(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_gammaWith(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_gammaWith", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_gammaWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_gammaWith" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  fz_pixmap_s_gammaWith(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_tintWith(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_tintWith", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_tintWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_tintWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_tintWith" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  fz_pixmap_s_tintWith(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  fz_pixmap_s_clearWith__SWIG_0(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clearWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  fz_pixmap_s_clearWith__SWIG_1(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clearWith" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clearWith" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  arg3 = swig_obj[2];
  fz_pixmap_s_clearWith__SWIG_2(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clearWith(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Pixmap_clearWith", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Pixmap_clearWith__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Pixmap_clearWith__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_Pixmap_clearWith__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Pixmap_clearWith'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    fz_pixmap_s::clearWith()\n"
    "    fz_pixmap_s::clearWith(int)\n"
    "    fz_pixmap_s::clearWith(int,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_copyPixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  struct fz_pixmap_s *arg2 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_copyPixmap", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_copyPixmap" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap_copyPixmap" "', argument " "2"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg2 = (struct fz_pixmap_s *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)fz_pixmap_s_copyPixmap(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setAlpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_setAlpha", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setAlpha" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  {
    result = (PyObject *)fz_pixmap_s_setAlpha(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__getImageData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap__getImageData", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__getImageData" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap__getImageData" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_pixmap_s__getImageData(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__writeIMG(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap__writeIMG", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__writeIMG" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap__writeIMG" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap__writeIMG" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_pixmap_s__writeIMG(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_invertIRect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_invertIRect", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_invertIRect" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)fz_pixmap_s_invertIRect(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_pixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_pixel", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_pixel" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_pixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_pixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_pixmap_s_pixel(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setPixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_setPixel", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setPixel" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_setPixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_setPixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = swig_obj[3];
  {
    result = (PyObject *)fz_pixmap_s_setPixel(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setResolution(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_setResolution", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setResolution" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_setResolution" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_setResolution" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)fz_pixmap_s_setResolution(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_setRect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_setRect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_setRect" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  {
    result = (PyObject *)fz_pixmap_s_setRect(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_stride(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_stride" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_stride(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_alpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_alpha" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_alpha(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_colorspace_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_colorspace" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (struct fz_colorspace_s *)fz_pixmap_s_colorspace(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_irect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_irect" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (PyObject *)fz_pixmap_s_irect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_size" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (int)fz_pixmap_s_size(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_samples(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_samples" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  result = (PyObject *)fz_pixmap_s_samples(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Pixmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_pixmap_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Pixmap_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Colorspace" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  delete_fz_colorspace_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_colorspace_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Colorspace" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (struct fz_colorspace_s *)new_fz_colorspace_s(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_colorspace_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace_n(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace_n" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  result = (PyObject *)fz_colorspace_s_n(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace__name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_colorspace_s *arg1 = (struct fz_colorspace_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace__name" "', argument " "1"" of type '" "struct fz_colorspace_s *""'"); 
  }
  arg1 = (struct fz_colorspace_s *)(argp1);
  result = (PyObject *)fz_colorspace_s__name(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Colorspace_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_colorspace_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Colorspace_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Device__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_pixmap_s *arg1 = (struct fz_pixmap_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_pixmap_s *""'"); 
  }
  arg1 = (struct fz_pixmap_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_0(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_1(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Device" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_2(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Device", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_display_list_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Device__SWIG_1(self, argc, argv);
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_stext_page_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Device__SWIG_2(self, argc, argv);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Device__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_fz_pixmap_s, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_Device__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Device'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_pixmap_s *,PyObject *)\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_display_list_s *)\n"
    "    DeviceWrapper::DeviceWrapper(struct fz_stext_page_s *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Device(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DeviceWrapper *arg1 = (struct DeviceWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Device" "', argument " "1"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg1 = (struct DeviceWrapper *)(argp1);
  delete_DeviceWrapper(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Device_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_DeviceWrapper, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Device_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Outline_title_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_title_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (char *) ((arg1)->title);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_page_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_page_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (int) ((arg1)->page);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_next_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_outline_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_next_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (struct fz_outline_s *) ((arg1)->next);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_down_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_outline_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_down_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (struct fz_outline_s *) ((arg1)->down);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_outline_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_is_open_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_is_open_get" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (int) ((arg1)->is_open);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_uri" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (PyObject *)fz_outline_s_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_isExternal" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  result = (PyObject *)fz_outline_s_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Outline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_outline_s *arg1 = (struct fz_outline_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_outline_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Outline" "', argument " "1"" of type '" "struct fz_outline_s *""'"); 
  }
  arg1 = (struct fz_outline_s *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Outline_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_outline_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Annot" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  delete_pdf_annot_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_rect" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_xref" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_xref(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_blendMode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_blendMode" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_blendMode(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setBlendMode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setBlendMode", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setBlendMode" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Annot_setBlendMode" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)pdf_annot_s_setBlendMode(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__getAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__getAP" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s__getAP(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__setAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot__setAP", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__setAP" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot__setAP" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)pdf_annot_s__setAP(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__get_redact_values(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__get_redact_values" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s__get_redact_values(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setName", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setName" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Annot_setName" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (PyObject *)pdf_annot_s_setName(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setRect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setRect", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setRect" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  arg2 = swig_obj[1];
  result = (PyObject *)pdf_annot_s_setRect(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_vertices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_vertices" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_vertices(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_colors" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_colors(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__update_appearance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  float arg2 = (float) -1 ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  int arg5 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot__update_appearance", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__update_appearance" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot__update_appearance" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = (float)(val2);
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot__update_appearance" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Annot__update_appearance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (PyObject *)pdf_annot_s__update_appearance(arg1,arg2,arg3,arg4,arg5);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setColors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setColors", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setColors" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  pdf_annot_s_setColors(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_lineEnds(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_lineEnds" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_lineEnds(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setLineEnds(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setLineEnds", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setLineEnds" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setLineEnds" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_setLineEnds" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  pdf_annot_s_setLineEnds(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_type" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_type(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_opacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_opacity" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_opacity(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setOpacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setOpacity", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setOpacity" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setOpacity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  pdf_annot_s_setOpacity(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileInfo" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s_fileInfo(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileGet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileGet" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s_fileGet(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_fileUpd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_fileUpd", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_fileUpd" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_fileUpd" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_fileUpd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Annot_fileUpd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  {
    result = (PyObject *)pdf_annot_s_fileUpd(arg1,arg2,arg3,arg4,arg5);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_info" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_info(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  char *arg7 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setInfo", 1, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setInfo" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_setInfo" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_setInfo" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Annot_setInfo" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Annot_setInfo" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    res7 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Annot_setInfo" "', argument " "7"" of type '" "char *""'");
    }
    arg7 = (char *)(buf7);
  }
  {
    result = (PyObject *)pdf_annot_s_setInfo(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_border" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (PyObject *)pdf_annot_s_border(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setBorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  float arg3 = (float) 0 ;
  char *arg4 = (char *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setBorder", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setBorder" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_setBorder" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_setBorder" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  result = (PyObject *)pdf_annot_s_setBorder(arg1,arg2,arg3,arg4,arg5);
  resultobj = result;
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_flags" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (int)pdf_annot_s_flags(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__cleanContents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__cleanContents" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s__cleanContents(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_setFlags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_setFlags", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_setFlags" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_setFlags" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  pdf_annot_s_setFlags(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_delete_responses(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_delete_responses" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  {
    result = (PyObject *)pdf_annot_s_delete_responses(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_annot_s *arg1 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct pdf_annot_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_next" "', argument " "1"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg1 = (struct pdf_annot_s *)(argp1);
  result = (struct pdf_annot_s *)pdf_annot_s_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Annot_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_pdf_annot_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Link(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Link" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  delete_fz_link_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__border", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__border" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__border" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__border" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)fz_link_s__border(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setBorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct fz_document_s *arg3 = (struct fz_document_s *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__setBorder", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setBorder" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setBorder" "', argument " "3"" of type '" "struct fz_document_s *""'"); 
  }
  arg3 = (struct fz_document_s *)(argp3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setBorder" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)fz_link_s__setBorder(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  struct fz_document_s *arg2 = (struct fz_document_s *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__colors", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__colors" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__colors" "', argument " "2"" of type '" "struct fz_document_s *""'"); 
  }
  arg2 = (struct fz_document_s *)(argp2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__colors" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)fz_link_s__colors(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setColors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct fz_document_s *arg3 = (struct fz_document_s *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__setColors", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setColors" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setColors" "', argument " "3"" of type '" "struct fz_document_s *""'"); 
  }
  arg3 = (struct fz_document_s *)(argp3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setColors" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)fz_link_s__setColors(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_uri" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_isExternal" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_rect" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (PyObject *)fz_link_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_link_s *arg1 = (struct fz_link_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct fz_link_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_link_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_next" "', argument " "1"" of type '" "struct fz_link_s *""'"); 
  }
  arg1 = (struct fz_link_s *)(argp1);
  result = (struct fz_link_s *)fz_link_s_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_link_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Link_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_link_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DisplayList" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  delete_fz_display_list_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  struct fz_display_list_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = swig_obj[0];
  {
    result = (struct fz_display_list_s *)new_fz_display_list_s(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_display_list_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_run", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_run" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DisplayList_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = swig_obj[2];
  arg4 = swig_obj[3];
  {
    result = (PyObject *)fz_display_list_s_run(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_rect" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  result = (PyObject *)fz_display_list_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_getPixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  struct fz_colorspace_s *arg3 = (struct fz_colorspace_s *) NULL ;
  int arg4 = (int) 1 ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[5] ;
  struct fz_pixmap_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_getPixmap", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_getPixmap" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_fz_colorspace_s, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DisplayList_getPixmap" "', argument " "3"" of type '" "struct fz_colorspace_s *""'"); 
    }
    arg3 = (struct fz_colorspace_s *)(argp3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DisplayList_getPixmap" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  {
    result = (struct fz_pixmap_s *)fz_display_list_s_getPixmap(arg1,arg2,arg3,arg4,arg5);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_pixmap_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_getTextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_display_list_s *arg1 = (struct fz_display_list_s *) 0 ;
  int arg2 = (int) 3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct fz_stext_page_s *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_getTextPage", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_display_list_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_getTextPage" "', argument " "1"" of type '" "struct fz_display_list_s *""'"); 
  }
  arg1 = (struct fz_display_list_s *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DisplayList_getTextPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct fz_stext_page_s *)fz_display_list_s_getTextPage(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DisplayList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_display_list_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DisplayList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  struct fz_stext_page_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = swig_obj[0];
  {
    result = (struct fz_stext_page_s *)new_fz_stext_page_s(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_fz_stext_page_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TextPage" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  delete_fz_stext_page_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_search(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 16 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_search", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_search" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextPage_search" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextPage_search" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextPage_search" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (PyObject *)fz_stext_page_s_search(arg1,(char const *)arg2,arg3,arg4);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__getNewBlockList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage__getNewBlockList", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__getNewBlockList" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextPage__getNewBlockList" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)fz_stext_page_s__getNewBlockList(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractBLOCKS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_extractBLOCKS", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractBLOCKS" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_stext_page_s_extractBLOCKS(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractWORDS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_extractWORDS", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractWORDS" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)fz_stext_page_s_extractWORDS(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_rect" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  result = (PyObject *)fz_stext_page_s_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__extractText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_stext_page_s *arg1 = (struct fz_stext_page_s *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage__extractText", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_stext_page_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__extractText" "', argument " "1"" of type '" "struct fz_stext_page_s *""'"); 
  }
  arg1 = (struct fz_stext_page_s *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextPage__extractText" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)fz_stext_page_s__extractText(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TextPage_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_fz_stext_page_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *TextPage_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct pdf_graft_map_s *arg1 = (struct pdf_graft_map_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_pdf_graft_map_s, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Graftmap" "', argument " "1"" of type '" "struct pdf_graft_map_s *""'"); 
  }
  arg1 = (struct pdf_graft_map_s *)(argp1);
  delete_pdf_graft_map_s(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct fz_document_s *arg1 = (struct fz_document_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct pdf_graft_map_s *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_fz_document_s, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Graftmap" "', argument " "1"" of type '" "struct fz_document_s *""'"); 
  }
  arg1 = (struct fz_document_s *)(argp1);
  {
    result = (struct pdf_graft_map_s *)new_pdf_graft_map_s(arg1);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_pdf_graft_map_s, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Graftmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_pdf_graft_map_s, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Graftmap_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Tools_gen_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_gen_id" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_gen_id(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_icc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_icc", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_icc" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_icc" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Tools_set_icc(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_store_shrink", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_shrink" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_store_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (PyObject *)Tools_store_shrink(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_show_aa_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_show_aa_level" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_show_aa_level(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_aa_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_aa_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_aa_level" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_aa_level" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Tools_set_aa_level(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_graphics_min_line_width(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_graphics_min_line_width", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_graphics_min_line_width" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_graphics_min_line_width" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  Tools_set_graphics_min_line_width(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_image_profile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_image_profile", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_image_profile" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Tools_image_profile" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (PyObject *)Tools_image_profile(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__derotate_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__derotate_point", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__derotate_point" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__derotate_point" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__derotate_point(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__derotate_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__derotate_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__derotate_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__derotate_rect" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__derotate_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__rotate_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__rotate_point", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__rotate_point" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__rotate_point" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__rotate_point(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__rotate_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__rotate_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__rotate_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__rotate_rect" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__rotate_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_size" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_size(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_maxsize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_maxsize" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_maxsize(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_config(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_config" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_fitz_config(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_glyph_cache_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_glyph_cache_empty" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_glyph_cache_empty(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__fill_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__fill_widget", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__fill_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__fill_widget" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Tools__fill_widget(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__save_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__save_widget", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__save_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__save_widget" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Tools__save_widget(arg1,arg2,arg3);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__reset_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__reset_widget", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__reset_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__reset_widget" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  {
    result = (PyObject *)Tools__reset_widget(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__parse_da(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__parse_da", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__parse_da" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__parse_da" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  {
    result = (PyObject *)Tools__parse_da(arg1,arg2);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__update_da(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct pdf_annot_s *arg2 = (struct pdf_annot_s *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__update_da", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__update_da" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_pdf_annot_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__update_da" "', argument " "2"" of type '" "struct pdf_annot_s *""'"); 
  }
  arg2 = (struct pdf_annot_s *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tools__update_da" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  result = (PyObject *)Tools__update_da(arg1,arg2,arg3);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__insert_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct fz_page_s *arg2 = (struct fz_page_s *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  int arg4 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__insert_contents", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__insert_contents" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_fz_page_s, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__insert_contents" "', argument " "2"" of type '" "struct fz_page_s *""'"); 
  }
  arg2 = (struct fz_page_s *)(argp2);
  arg3 = swig_obj[2];
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools__insert_contents" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)Tools__insert_contents(arg1,arg2,arg3,arg4);
    if (!result)
    {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));
      return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_version(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_version" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_mupdf_version(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_warnings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_mupdf_warnings", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_warnings" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_mupdf_warnings" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)Tools_mupdf_warnings(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_reset_mupdf_warnings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_reset_mupdf_warnings" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_reset_mupdf_warnings(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_display_errors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_mupdf_display_errors", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_display_errors" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_mupdf_display_errors(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__transform_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__transform_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__transform_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__transform_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__intersect_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__intersect_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__intersect_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__intersect_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__include_point_in_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__include_point_in_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__include_point_in_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__include_point_in_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__transform_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__transform_point", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__transform_point" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__transform_point(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__union_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__union_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__union_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__union_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__concat_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__concat_matrix", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__concat_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__concat_matrix(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__invert_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__invert_matrix", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__invert_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  result = (PyObject *)Tools__invert_matrix(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_measure_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_measure_string", 4, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_measure_string" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools_measure_string" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tools_measure_string" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools_measure_string" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = (float)(val4);
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Tools_measure_string" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (float)Tools_measure_string(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  resultobj = SWIG_From_float((float)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_Tools", 0, 0, 0)) SWIG_fail;
  result = (struct Tools *)calloc(1, sizeof(struct Tools));
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Tools, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Tools" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Tools_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Tools, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Tools_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { "delete_Document", _wrap_delete_Document, METH_O, "delete_Document(self)"},
	 { "new_Document", _wrap_new_Document, METH_VARARGS, "new_Document(filename=None, stream=None, filetype=None, rect=None, width=0, height=0, fontsize=11) -> Document"},
	 { "Document_close", _wrap_Document_close, METH_O, "Document_close(self)"},
	 { "Document_loadPage", _wrap_Document_loadPage, METH_VARARGS, "Document_loadPage(self, number=0) -> Page"},
	 { "Document__remove_links_to", _wrap_Document__remove_links_to, METH_VARARGS, "Document__remove_links_to(self, first, last) -> PyObject *"},
	 { "Document__loadOutline", _wrap_Document__loadOutline, METH_O, "Document__loadOutline(self) -> Outline"},
	 { "Document__dropOutline", _wrap_Document__dropOutline, METH_VARARGS, "Document__dropOutline(self, ol)"},
	 { "Document__embeddedFileNames", _wrap_Document__embeddedFileNames, METH_VARARGS, "Document__embeddedFileNames(self, namelist) -> PyObject *"},
	 { "Document__embeddedFileDel", _wrap_Document__embeddedFileDel, METH_VARARGS, "Document__embeddedFileDel(self, idx) -> PyObject *"},
	 { "Document__embeddedFileInfo", _wrap_Document__embeddedFileInfo, METH_VARARGS, "Document__embeddedFileInfo(self, idx, infodict) -> PyObject *"},
	 { "Document__embeddedFileUpd", _wrap_Document__embeddedFileUpd, METH_VARARGS, "Document__embeddedFileUpd(self, idx, buffer=None, filename=None, ufilename=None, desc=None) -> PyObject *"},
	 { "Document__embeddedFileGet", _wrap_Document__embeddedFileGet, METH_VARARGS, "Document__embeddedFileGet(self, idx) -> PyObject *"},
	 { "Document__embeddedFileAdd", _wrap_Document__embeddedFileAdd, METH_VARARGS, "Document__embeddedFileAdd(self, name, buffer, filename=None, ufilename=None, desc=None) -> PyObject *"},
	 { "Document_convertToPDF", _wrap_Document_convertToPDF, METH_VARARGS, "Convert document to PDF selecting page range and optional rotation. Output bytes object."},
	 { "Document_pageCount", _wrap_Document_pageCount, METH_O, "Document_pageCount(self) -> PyObject *"},
	 { "Document__getMetadata", _wrap_Document__getMetadata, METH_VARARGS, "Document__getMetadata(self, key) -> char *"},
	 { "Document_needsPass", _wrap_Document_needsPass, METH_O, "Document_needsPass(self) -> PyObject *"},
	 { "Document_resolveLink", _wrap_Document_resolveLink, METH_VARARGS, "Calculate internal link destination."},
	 { "Document_layout", _wrap_Document_layout, METH_VARARGS, "Re-layout a reflowable document."},
	 { "Document_makeBookmark", _wrap_Document_makeBookmark, METH_VARARGS, "Make page bookmark in a reflowable document."},
	 { "Document_findBookmark", _wrap_Document_findBookmark, METH_VARARGS, "Find page number after layouting a document."},
	 { "Document_isReflowable", _wrap_Document_isReflowable, METH_O, "Document_isReflowable(self) -> PyObject *"},
	 { "Document__deleteObject", _wrap_Document__deleteObject, METH_VARARGS, "Delete an object given its xref."},
	 { "Document__getPDFroot", _wrap_Document__getPDFroot, METH_O, "Get XREF number of PDF catalog."},
	 { "Document__getPDFfileid", _wrap_Document__getPDFfileid, METH_O, "Return PDF file /ID strings (hexadecimal)."},
	 { "Document_isPDF", _wrap_Document_isPDF, METH_O, "Document_isPDF(self) -> PyObject *"},
	 { "Document__hasXrefStream", _wrap_Document__hasXrefStream, METH_O, "Document__hasXrefStream(self) -> PyObject *"},
	 { "Document__hasXrefOldStyle", _wrap_Document__hasXrefOldStyle, METH_O, "Document__hasXrefOldStyle(self) -> PyObject *"},
	 { "Document_isDirty", _wrap_Document_isDirty, METH_O, "Document_isDirty(self) -> PyObject *"},
	 { "Document_can_save_incrementally", _wrap_Document_can_save_incrementally, METH_O, "Check if can be saved incrementally."},
	 { "Document_authenticate", _wrap_Document_authenticate, METH_VARARGS, "Decrypt document with a password."},
	 { "Document_save", _wrap_Document_save, METH_VARARGS, "Document_save(self, filename, garbage=0, clean=0, deflate=0, incremental=0, ascii=0, expand=0, linear=0, pretty=0, encryption=1, permissions=-1, owner_pw=None, user_pw=None) -> PyObject *"},
	 { "Document_write", _wrap_Document_write, METH_VARARGS, "Write document to a bytes object."},
	 { "Document_insertPDF", _wrap_Document_insertPDF, METH_VARARGS, "Copy page range ['from', 'to'] of source PDF, starting as page number 'start_at'."},
	 { "Document__newPage", _wrap_Document__newPage, METH_VARARGS, "Document__newPage(self, pno=-1, width=595, height=842) -> PyObject *"},
	 { "Document_select", _wrap_Document_select, METH_VARARGS, "Build sub-pdf with page numbers in 'list'."},
	 { "Document__deletePage", _wrap_Document__deletePage, METH_VARARGS, "Document__deletePage(self, pno) -> PyObject *"},
	 { "Document_permissions", _wrap_Document_permissions, METH_O, "Get document permissions."},
	 { "Document__getCharWidths", _wrap_Document__getCharWidths, METH_VARARGS, "Return list of glyphs and glyph widths of a font."},
	 { "Document__getPageObjNumber", _wrap_Document__getPageObjNumber, METH_VARARGS, "Document__getPageObjNumber(self, pno) -> PyObject *"},
	 { "Document__getPageInfo", _wrap_Document__getPageInfo, METH_VARARGS, "Show fonts or images used on a page."},
	 { "Document_extractFont", _wrap_Document_extractFont, METH_VARARGS, "Document_extractFont(self, xref=0, info_only=0) -> PyObject *"},
	 { "Document_extractImage", _wrap_Document_extractImage, METH_VARARGS, "Extract image pointed to by 'xref'."},
	 { "Document__delToC", _wrap_Document__delToC, METH_O, "Document__delToC(self) -> PyObject *"},
	 { "Document_isStream", _wrap_Document_isStream, METH_VARARGS, "Document_isStream(self, xref=0) -> PyObject *"},
	 { "Document_getSigFlags", _wrap_Document_getSigFlags, METH_O, "Document_getSigFlags(self) -> PyObject *"},
	 { "Document_isFormPDF", _wrap_Document_isFormPDF, METH_O, "Document_isFormPDF(self) -> PyObject *"},
	 { "Document_FormFonts", _wrap_Document_FormFonts, METH_O, "Document_FormFonts(self) -> PyObject *"},
	 { "Document__addFormFont", _wrap_Document__addFormFont, METH_VARARGS, "Document__addFormFont(self, name, font) -> PyObject *"},
	 { "Document__getOLRootNumber", _wrap_Document__getOLRootNumber, METH_O, "Document__getOLRootNumber(self) -> PyObject *"},
	 { "Document__getNewXref", _wrap_Document__getNewXref, METH_O, "Document__getNewXref(self) -> PyObject *"},
	 { "Document__getXrefLength", _wrap_Document__getXrefLength, METH_O, "Document__getXrefLength(self) -> PyObject *"},
	 { "Document__getXmlMetadataXref", _wrap_Document__getXmlMetadataXref, METH_O, "Document__getXmlMetadataXref(self) -> PyObject *"},
	 { "Document__delXmlMetadata", _wrap_Document__delXmlMetadata, METH_O, "Document__delXmlMetadata(self) -> PyObject *"},
	 { "Document__getXrefString", _wrap_Document__getXrefString, METH_VARARGS, "Document__getXrefString(self, xref, compressed=0, ascii=0) -> PyObject *"},
	 { "Document__getTrailerString", _wrap_Document__getTrailerString, METH_VARARGS, "Document__getTrailerString(self, compressed=0, ascii=0) -> PyObject *"},
	 { "Document__getXrefStreamRaw", _wrap_Document__getXrefStreamRaw, METH_VARARGS, "Document__getXrefStreamRaw(self, xref) -> PyObject *"},
	 { "Document__getXrefStream", _wrap_Document__getXrefStream, METH_VARARGS, "Document__getXrefStream(self, xref) -> PyObject *"},
	 { "Document__updateObject", _wrap_Document__updateObject, METH_VARARGS, "Document__updateObject(self, xref, text, page=None) -> PyObject *"},
	 { "Document__updateStream", _wrap_Document__updateStream, METH_VARARGS, "Document__updateStream(self, xref=0, stream=None, new=0) -> PyObject *"},
	 { "Document__setMetadata", _wrap_Document__setMetadata, METH_VARARGS, "Document__setMetadata(self, text) -> PyObject *"},
	 { "Document__make_page_map", _wrap_Document__make_page_map, METH_O, "Document__make_page_map(self) -> PyObject *"},
	 { "Document_fullcopyPage", _wrap_Document_fullcopyPage, METH_VARARGS, "Document_fullcopyPage(self, pno, to=-1) -> PyObject *"},
	 { "Document__move_copy_page", _wrap_Document__move_copy_page, METH_VARARGS, "Document__move_copy_page(self, pno, nb, before, copy) -> PyObject *"},
	 { "Document_swigregister", Document_swigregister, METH_O, NULL},
	 { "Document_swiginit", Document_swiginit, METH_VARARGS, NULL},
	 { "delete_Page", _wrap_delete_Page, METH_O, "delete_Page(self)"},
	 { "Page_bound", _wrap_Page_bound, METH_O, "Page_bound(self) -> PyObject *"},
	 { "Page_run", _wrap_Page_run, METH_VARARGS, "Page_run(self, dw, m) -> PyObject *"},
	 { "Page_getTextPage", _wrap_Page_getTextPage, METH_VARARGS, "Create a TextPage directly from the page."},
	 { "Page_getSVGimage", _wrap_Page_getSVGimage, METH_VARARGS, "Create an SVG image from the page."},
	 { "Page_addCaretAnnot", _wrap_Page_addCaretAnnot, METH_VARARGS, "Add a 'Caret' annot on the page."},
	 { "Page_addRedactAnnot", _wrap_Page_addRedactAnnot, METH_VARARGS, "Add a 'Redaction' annot on the page."},
	 { "Page_addLineAnnot", _wrap_Page_addLineAnnot, METH_VARARGS, "Add a 'Line' annot for points p1 and p2."},
	 { "Page_addTextAnnot", _wrap_Page_addTextAnnot, METH_VARARGS, "Add a 'sticky note' at position 'point'."},
	 { "Page_addInkAnnot", _wrap_Page_addInkAnnot, METH_VARARGS, "Add a 'handwriting' as a list of list of point-likes. Each sublist forms an independent stroke."},
	 { "Page_addStampAnnot", _wrap_Page_addStampAnnot, METH_VARARGS, "Add a 'rubber stamp' in a rectangle."},
	 { "Page_addFileAnnot", _wrap_Page_addFileAnnot, METH_VARARGS, "Add a 'FileAttachment' annotation at location 'point'."},
	 { "Page__add_text_marker", _wrap_Page__add_text_marker, METH_VARARGS, "Add a text marker annotation."},
	 { "Page__add_square_or_circle", _wrap_Page__add_square_or_circle, METH_VARARGS, "Add a 'Square' or 'Circle' annotation."},
	 { "Page__add_multiline", _wrap_Page__add_multiline, METH_VARARGS, "Add a multiline annotation."},
	 { "Page_addFreetextAnnot", _wrap_Page_addFreetextAnnot, METH_VARARGS, "Add a 'FreeText' annotation in rectangle 'rect'."},
	 { "Page_load_annot", _wrap_Page_load_annot, METH_VARARGS, "Page_load_annot(self, name) -> Annot"},
	 { "Page_annot_names", _wrap_Page_annot_names, METH_O, "Page_annot_names(self) -> PyObject *"},
	 { "Page__addWidget", _wrap_Page__addWidget, METH_VARARGS, "Page__addWidget(self, Widget) -> Annot"},
	 { "Page_getDisplayList", _wrap_Page_getDisplayList, METH_VARARGS, "Page_getDisplayList(self, annots=1) -> DisplayList"},
	 { "Page__apply_redactions", _wrap_Page__apply_redactions, METH_O, "Page__apply_redactions(self) -> PyObject *"},
	 { "Page__makePixmap", _wrap_Page__makePixmap, METH_VARARGS, "Page__makePixmap(self, doc, ctm, cs, alpha=0, annots=1, clip=None) -> Pixmap"},
	 { "Page_insertString", _wrap_Page_insertString, METH_VARARGS, "Insert a string on a page"},
	 { "Page_setMediaBox", _wrap_Page_setMediaBox, METH_VARARGS, "Page_setMediaBox(self, rect) -> PyObject *"},
	 { "Page_setCropBox", _wrap_Page_setCropBox, METH_VARARGS, "Page_setCropBox(self, rect) -> PyObject *"},
	 { "Page_loadLinks", _wrap_Page_loadLinks, METH_O, "Page_loadLinks(self) -> Link"},
	 { "Page_firstAnnot", _wrap_Page_firstAnnot, METH_O, "Points to first annotation on page"},
	 { "Page_firstWidget", _wrap_Page_firstWidget, METH_O, "Page_firstWidget(self) -> Annot"},
	 { "Page_deleteLink", _wrap_Page_deleteLink, METH_VARARGS, "Delete link if PDF"},
	 { "Page_deleteAnnot", _wrap_Page_deleteAnnot, METH_VARARGS, "Delete annot and return next one."},
	 { "Page_MediaBox", _wrap_Page_MediaBox, METH_O, "Retrieve the /MediaBox."},
	 { "Page_CropBox", _wrap_Page_CropBox, METH_O, "Retrieve the /CropBox."},
	 { "Page_rotation", _wrap_Page_rotation, METH_O, "Retrieve page rotation."},
	 { "Page_setRotation", _wrap_Page_setRotation, METH_VARARGS, "Set page rotation to 'rot' degrees."},
	 { "Page__addAnnot_FromString", _wrap_Page__addAnnot_FromString, METH_VARARGS, "Page__addAnnot_FromString(self, linklist) -> PyObject *"},
	 { "Page__getLinkXrefs", _wrap_Page__getLinkXrefs, METH_O, "Page__getLinkXrefs(self) -> PyObject *"},
	 { "Page__cleanContents", _wrap_Page__cleanContents, METH_O, "Page__cleanContents(self) -> PyObject *"},
	 { "Page__showPDFpage", _wrap_Page__showPDFpage, METH_VARARGS, "Page__showPDFpage(self, fz_srcpage, overlay=1, matrix=None, xref=0, clip=None, graftmap=None, _imgname=None) -> PyObject *"},
	 { "Page__insertImage", _wrap_Page__insertImage, METH_VARARGS, "Page__insertImage(self, filename=None, pixmap=None, stream=None, overlay=1, matrix=None, _imgname=None, _imgpointer=None) -> PyObject *"},
	 { "Page_refresh", _wrap_Page_refresh, METH_O, "Refresh page after link/annot/widget updates."},
	 { "Page__insertFont", _wrap_Page__insertFont, METH_VARARGS, "Page__insertFont(self, fontname, bfname, fontfile, fontbuffer, set_simple, idx, wmode, serif, encoding, ordering) -> PyObject *"},
	 { "Page__getTransformation", _wrap_Page__getTransformation, METH_O, "Return page transformation matrix."},
	 { "Page__getContents", _wrap_Page__getContents, METH_O, "Return list of /Contents objects as xref integers."},
	 { "Page__setContents", _wrap_Page__setContents, METH_VARARGS, "Set the /Contents object in page definition"},
	 { "Page_swigregister", Page_swigregister, METH_O, NULL},
	 { "Pixmap_x_set", _wrap_Pixmap_x_set, METH_VARARGS, "Pixmap_x_set(self, x)"},
	 { "Pixmap_x_get", _wrap_Pixmap_x_get, METH_O, "Pixmap_x_get(self) -> int"},
	 { "Pixmap_y_set", _wrap_Pixmap_y_set, METH_VARARGS, "Pixmap_y_set(self, y)"},
	 { "Pixmap_y_get", _wrap_Pixmap_y_get, METH_O, "Pixmap_y_get(self) -> int"},
	 { "Pixmap_w_set", _wrap_Pixmap_w_set, METH_VARARGS, "Pixmap_w_set(self, w)"},
	 { "Pixmap_w_get", _wrap_Pixmap_w_get, METH_O, "Pixmap_w_get(self) -> int"},
	 { "Pixmap_h_set", _wrap_Pixmap_h_set, METH_VARARGS, "Pixmap_h_set(self, h)"},
	 { "Pixmap_h_get", _wrap_Pixmap_h_get, METH_O, "Pixmap_h_get(self) -> int"},
	 { "Pixmap_n_set", _wrap_Pixmap_n_set, METH_VARARGS, "Pixmap_n_set(self, n)"},
	 { "Pixmap_n_get", _wrap_Pixmap_n_get, METH_O, "Pixmap_n_get(self) -> int"},
	 { "Pixmap_xres_set", _wrap_Pixmap_xres_set, METH_VARARGS, "Pixmap_xres_set(self, xres)"},
	 { "Pixmap_xres_get", _wrap_Pixmap_xres_get, METH_O, "Pixmap_xres_get(self) -> int"},
	 { "Pixmap_yres_set", _wrap_Pixmap_yres_set, METH_VARARGS, "Pixmap_yres_set(self, yres)"},
	 { "Pixmap_yres_get", _wrap_Pixmap_yres_get, METH_O, "Pixmap_yres_get(self) -> int"},
	 { "delete_Pixmap", _wrap_delete_Pixmap, METH_O, "delete_Pixmap(self)"},
	 { "new_Pixmap", _wrap_new_Pixmap, METH_VARARGS, "\n"
		"Pixmap(cs, bbox, alpha=0)\n"
		"Pixmap(cs, spix)\n"
		"Pixmap(spix, w, h, clip=None)\n"
		"Pixmap(spix, alpha=1)\n"
		"Pixmap(cs, w, h, samples, alpha=0)\n"
		"Pixmap(filename)\n"
		"Pixmap(imagedata)\n"
		"new_Pixmap(doc, xref) -> Pixmap\n"
		""},
	 { "Pixmap_shrink", _wrap_Pixmap_shrink, METH_VARARGS, "Pixmap_shrink(self, factor)"},
	 { "Pixmap_gammaWith", _wrap_Pixmap_gammaWith, METH_VARARGS, "Pixmap_gammaWith(self, gamma)"},
	 { "Pixmap_tintWith", _wrap_Pixmap_tintWith, METH_VARARGS, "Pixmap_tintWith(self, black, white)"},
	 { "Pixmap_clearWith", _wrap_Pixmap_clearWith, METH_VARARGS, "\n"
		"Pixmap_clearWith(self)\n"
		"Pixmap_clearWith(self, value)\n"
		"Pixmap_clearWith(self, value, bbox)\n"
		""},
	 { "Pixmap_copyPixmap", _wrap_Pixmap_copyPixmap, METH_VARARGS, "Pixmap_copyPixmap(self, src, bbox) -> PyObject *"},
	 { "Pixmap_setAlpha", _wrap_Pixmap_setAlpha, METH_VARARGS, "Pixmap_setAlpha(self, alphavalues=None) -> PyObject *"},
	 { "Pixmap__getImageData", _wrap_Pixmap__getImageData, METH_VARARGS, "Pixmap__getImageData(self, format) -> PyObject *"},
	 { "Pixmap__writeIMG", _wrap_Pixmap__writeIMG, METH_VARARGS, "Pixmap__writeIMG(self, filename, format) -> PyObject *"},
	 { "Pixmap_invertIRect", _wrap_Pixmap_invertIRect, METH_VARARGS, "Pixmap_invertIRect(self, irect=None) -> PyObject *"},
	 { "Pixmap_pixel", _wrap_Pixmap_pixel, METH_VARARGS, "Return the pixel at (x,y) as a list. Last item is the alpha if Pixmap.alpha is true."},
	 { "Pixmap_setPixel", _wrap_Pixmap_setPixel, METH_VARARGS, "Set the pixel at (x,y) to the integers in sequence 'color'."},
	 { "Pixmap_setResolution", _wrap_Pixmap_setResolution, METH_VARARGS, "Set the resolution."},
	 { "Pixmap_setRect", _wrap_Pixmap_setRect, METH_VARARGS, "Set a rectangle to the integers in sequence 'color'."},
	 { "Pixmap_stride", _wrap_Pixmap_stride, METH_O, "Pixmap_stride(self) -> int"},
	 { "Pixmap_alpha", _wrap_Pixmap_alpha, METH_O, "Pixmap_alpha(self) -> int"},
	 { "Pixmap_colorspace", _wrap_Pixmap_colorspace, METH_O, "Pixmap_colorspace(self) -> Colorspace"},
	 { "Pixmap_irect", _wrap_Pixmap_irect, METH_O, "Pixmap_irect(self) -> PyObject *"},
	 { "Pixmap_size", _wrap_Pixmap_size, METH_O, "Pixmap_size(self) -> int"},
	 { "Pixmap_samples", _wrap_Pixmap_samples, METH_O, "Pixmap_samples(self) -> PyObject *"},
	 { "Pixmap_swigregister", Pixmap_swigregister, METH_O, NULL},
	 { "Pixmap_swiginit", Pixmap_swiginit, METH_VARARGS, NULL},
	 { "delete_Colorspace", _wrap_delete_Colorspace, METH_O, "delete_Colorspace(self)"},
	 { "new_Colorspace", _wrap_new_Colorspace, METH_O, "new_Colorspace(type) -> Colorspace"},
	 { "Colorspace_n", _wrap_Colorspace_n, METH_O, "Colorspace_n(self) -> PyObject *"},
	 { "Colorspace__name", _wrap_Colorspace__name, METH_O, "Colorspace__name(self) -> PyObject *"},
	 { "Colorspace_swigregister", Colorspace_swigregister, METH_O, NULL},
	 { "Colorspace_swiginit", Colorspace_swiginit, METH_VARARGS, NULL},
	 { "new_Device", _wrap_new_Device, METH_VARARGS, "\n"
		"Device(pm, clip)\n"
		"Device(dl)\n"
		"new_Device(tp, flags=0) -> Device\n"
		""},
	 { "delete_Device", _wrap_delete_Device, METH_O, "delete_Device(self)"},
	 { "Device_swigregister", Device_swigregister, METH_O, NULL},
	 { "Device_swiginit", Device_swiginit, METH_VARARGS, NULL},
	 { "Outline_title_get", _wrap_Outline_title_get, METH_O, "Outline_title_get(self) -> char *"},
	 { "Outline_page_get", _wrap_Outline_page_get, METH_O, "Outline_page_get(self) -> int"},
	 { "Outline_next_get", _wrap_Outline_next_get, METH_O, "Outline_next_get(self) -> Outline"},
	 { "Outline_down_get", _wrap_Outline_down_get, METH_O, "Outline_down_get(self) -> Outline"},
	 { "Outline_is_open_get", _wrap_Outline_is_open_get, METH_O, "Outline_is_open_get(self) -> int"},
	 { "Outline_uri", _wrap_Outline_uri, METH_O, "Outline_uri(self) -> PyObject *"},
	 { "Outline_isExternal", _wrap_Outline_isExternal, METH_O, "Outline_isExternal(self) -> PyObject *"},
	 { "delete_Outline", _wrap_delete_Outline, METH_O, "delete_Outline(self)"},
	 { "Outline_swigregister", Outline_swigregister, METH_O, NULL},
	 { "delete_Annot", _wrap_delete_Annot, METH_O, "delete_Annot(self)"},
	 { "Annot_rect", _wrap_Annot_rect, METH_O, "Rectangle containing the annot"},
	 { "Annot_xref", _wrap_Annot_xref, METH_O, "Annot_xref(self) -> PyObject *"},
	 { "Annot_blendMode", _wrap_Annot_blendMode, METH_O, "Show the annotation's blend mode."},
	 { "Annot_setBlendMode", _wrap_Annot_setBlendMode, METH_VARARGS, "Set the annotation's blend mode."},
	 { "Annot__getAP", _wrap_Annot__getAP, METH_O, "Get contents source of a PDF annot"},
	 { "Annot__setAP", _wrap_Annot__setAP, METH_VARARGS, "Update contents source of a PDF annot"},
	 { "Annot__get_redact_values", _wrap_Annot__get_redact_values, METH_O, "Get values of a redaction annot."},
	 { "Annot_setName", _wrap_Annot_setName, METH_VARARGS, "Set the (icon) name"},
	 { "Annot_setRect", _wrap_Annot_setRect, METH_VARARGS, "Set the rectangle"},
	 { "Annot_vertices", _wrap_Annot_vertices, METH_O, "Point coordinates for various annot types"},
	 { "Annot_colors", _wrap_Annot_colors, METH_O, "dictionary of the annot's colors"},
	 { "Annot__update_appearance", _wrap_Annot__update_appearance, METH_VARARGS, "Annot__update_appearance(self, opacity=-1, blend_mode=None, fill_color=None, rotate=-1) -> PyObject *"},
	 { "Annot_setColors", _wrap_Annot_setColors, METH_VARARGS, "\n"
		"setColors(dict)\n"
		"Changes the 'stroke' and 'fill' colors of an annotation. If provided, values must be sequences of up to 4 floats.\n"
		""},
	 { "Annot_lineEnds", _wrap_Annot_lineEnds, METH_O, "Annot_lineEnds(self) -> PyObject *"},
	 { "Annot_setLineEnds", _wrap_Annot_setLineEnds, METH_VARARGS, "Annot_setLineEnds(self, start, end)"},
	 { "Annot_type", _wrap_Annot_type, METH_O, "Annot_type(self) -> PyObject *"},
	 { "Annot_opacity", _wrap_Annot_opacity, METH_O, "Annot_opacity(self) -> PyObject *"},
	 { "Annot_setOpacity", _wrap_Annot_setOpacity, METH_VARARGS, "Annot_setOpacity(self, opacity)"},
	 { "Annot_fileInfo", _wrap_Annot_fileInfo, METH_O, "Retrieve attached file information."},
	 { "Annot_fileGet", _wrap_Annot_fileGet, METH_O, "Retrieve annotation attached file content."},
	 { "Annot_fileUpd", _wrap_Annot_fileUpd, METH_VARARGS, "Update annotation attached file."},
	 { "Annot_info", _wrap_Annot_info, METH_O, "Return various annotation properties."},
	 { "Annot_setInfo", _wrap_Annot_setInfo, METH_VARARGS, "Set various annotation properties."},
	 { "Annot_border", _wrap_Annot_border, METH_O, "Annot_border(self) -> PyObject *"},
	 { "Annot_setBorder", _wrap_Annot_setBorder, METH_VARARGS, "Annot_setBorder(self, border=None, width=0, style=None, dashes=None) -> PyObject *"},
	 { "Annot_flags", _wrap_Annot_flags, METH_O, "Annot_flags(self) -> int"},
	 { "Annot__cleanContents", _wrap_Annot__cleanContents, METH_O, "Annot__cleanContents(self) -> PyObject *"},
	 { "Annot_setFlags", _wrap_Annot_setFlags, METH_VARARGS, "Annot_setFlags(self, flags)"},
	 { "Annot_delete_responses", _wrap_Annot_delete_responses, METH_O, "Delete PopUp and responses to this annotation."},
	 { "Annot_next", _wrap_Annot_next, METH_O, "Annot_next(self) -> Annot"},
	 { "Annot_swigregister", Annot_swigregister, METH_O, NULL},
	 { "delete_Link", _wrap_delete_Link, METH_O, "delete_Link(self)"},
	 { "Link__border", _wrap_Link__border, METH_VARARGS, "Link__border(self, doc, xref) -> PyObject *"},
	 { "Link__setBorder", _wrap_Link__setBorder, METH_VARARGS, "Link__setBorder(self, border, doc, xref) -> PyObject *"},
	 { "Link__colors", _wrap_Link__colors, METH_VARARGS, "Link__colors(self, doc, xref) -> PyObject *"},
	 { "Link__setColors", _wrap_Link__setColors, METH_VARARGS, "Link__setColors(self, colors, doc, xref) -> PyObject *"},
	 { "Link_uri", _wrap_Link_uri, METH_O, "Link_uri(self) -> PyObject *"},
	 { "Link_isExternal", _wrap_Link_isExternal, METH_O, "Link_isExternal(self) -> PyObject *"},
	 { "Link_rect", _wrap_Link_rect, METH_O, "Link_rect(self) -> PyObject *"},
	 { "Link_next", _wrap_Link_next, METH_O, "Link_next(self) -> Link"},
	 { "Link_swigregister", Link_swigregister, METH_O, NULL},
	 { "delete_DisplayList", _wrap_delete_DisplayList, METH_O, "delete_DisplayList(self)"},
	 { "new_DisplayList", _wrap_new_DisplayList, METH_O, "new_DisplayList(mediabox) -> DisplayList"},
	 { "DisplayList_run", _wrap_DisplayList_run, METH_VARARGS, "DisplayList_run(self, dw, m, area) -> PyObject *"},
	 { "DisplayList_rect", _wrap_DisplayList_rect, METH_O, "DisplayList_rect(self) -> PyObject *"},
	 { "DisplayList_getPixmap", _wrap_DisplayList_getPixmap, METH_VARARGS, "DisplayList_getPixmap(self, matrix=None, colorspace=None, alpha=1, clip=None) -> Pixmap"},
	 { "DisplayList_getTextPage", _wrap_DisplayList_getTextPage, METH_VARARGS, "DisplayList_getTextPage(self, flags=3) -> TextPage"},
	 { "DisplayList_swigregister", DisplayList_swigregister, METH_O, NULL},
	 { "DisplayList_swiginit", DisplayList_swiginit, METH_VARARGS, NULL},
	 { "new_TextPage", _wrap_new_TextPage, METH_O, "new_TextPage(mediabox) -> TextPage"},
	 { "delete_TextPage", _wrap_delete_TextPage, METH_O, "delete_TextPage(self)"},
	 { "TextPage_search", _wrap_TextPage_search, METH_VARARGS, "TextPage_search(self, needle, hit_max=16, quads=0) -> PyObject *"},
	 { "TextPage__getNewBlockList", _wrap_TextPage__getNewBlockList, METH_VARARGS, "TextPage__getNewBlockList(self, page_dict, raw) -> PyObject *"},
	 { "TextPage_extractBLOCKS", _wrap_TextPage_extractBLOCKS, METH_VARARGS, "Fill a given list with text block information."},
	 { "TextPage_extractWORDS", _wrap_TextPage_extractWORDS, METH_VARARGS, "Fill a given list with text word information."},
	 { "TextPage_rect", _wrap_TextPage_rect, METH_O, "TextPage_rect(self) -> PyObject *"},
	 { "TextPage__extractText", _wrap_TextPage__extractText, METH_VARARGS, "TextPage__extractText(self, format) -> PyObject *"},
	 { "TextPage_swigregister", TextPage_swigregister, METH_O, NULL},
	 { "TextPage_swiginit", TextPage_swiginit, METH_VARARGS, NULL},
	 { "delete_Graftmap", _wrap_delete_Graftmap, METH_O, "delete_Graftmap(self)"},
	 { "new_Graftmap", _wrap_new_Graftmap, METH_O, "new_Graftmap(doc) -> Graftmap"},
	 { "Graftmap_swigregister", Graftmap_swigregister, METH_O, NULL},
	 { "Graftmap_swiginit", Graftmap_swiginit, METH_VARARGS, NULL},
	 { "Tools_gen_id", _wrap_Tools_gen_id, METH_O, "Return a unique positive integer."},
	 { "Tools_set_icc", _wrap_Tools_set_icc, METH_VARARGS, "Set ICC color handling on or off."},
	 { "Tools_store_shrink", _wrap_Tools_store_shrink, METH_VARARGS, "Free 'percent' of current store size."},
	 { "Tools_show_aa_level", _wrap_Tools_show_aa_level, METH_O, "Show anti-aliasing values."},
	 { "Tools_set_aa_level", _wrap_Tools_set_aa_level, METH_VARARGS, "Set anti-aliasing level."},
	 { "Tools_set_graphics_min_line_width", _wrap_Tools_set_graphics_min_line_width, METH_VARARGS, "Set graphics min. line width."},
	 { "Tools_image_profile", _wrap_Tools_image_profile, METH_VARARGS, "Determine dimension and other image data."},
	 { "Tools__derotate_point", _wrap_Tools__derotate_point, METH_VARARGS, "Tools__derotate_point(self, page, point) -> PyObject *"},
	 { "Tools__derotate_rect", _wrap_Tools__derotate_rect, METH_VARARGS, "Tools__derotate_rect(self, page, rect) -> PyObject *"},
	 { "Tools__rotate_point", _wrap_Tools__rotate_point, METH_VARARGS, "Tools__rotate_point(self, page, point) -> PyObject *"},
	 { "Tools__rotate_rect", _wrap_Tools__rotate_rect, METH_VARARGS, "Tools__rotate_rect(self, page, rect) -> PyObject *"},
	 { "Tools_store_size", _wrap_Tools_store_size, METH_O, "Current store size."},
	 { "Tools_store_maxsize", _wrap_Tools_store_maxsize, METH_O, "Maximum store size."},
	 { "Tools_fitz_config", _wrap_Tools_fitz_config, METH_O, "Show configuration data."},
	 { "Tools_glyph_cache_empty", _wrap_Tools_glyph_cache_empty, METH_O, "Empty the glyph cache."},
	 { "Tools__fill_widget", _wrap_Tools__fill_widget, METH_VARARGS, "Tools__fill_widget(self, annot, widget) -> PyObject *"},
	 { "Tools__save_widget", _wrap_Tools__save_widget, METH_VARARGS, "Tools__save_widget(self, annot, widget) -> PyObject *"},
	 { "Tools__reset_widget", _wrap_Tools__reset_widget, METH_VARARGS, "Tools__reset_widget(self, annot) -> PyObject *"},
	 { "Tools__parse_da", _wrap_Tools__parse_da, METH_VARARGS, "Tools__parse_da(self, annot) -> PyObject *"},
	 { "Tools__update_da", _wrap_Tools__update_da, METH_VARARGS, "Tools__update_da(self, annot, da_str) -> PyObject *"},
	 { "Tools__insert_contents", _wrap_Tools__insert_contents, METH_VARARGS, "Make a new /Contents object for a page from bytes, and return its xref."},
	 { "Tools_mupdf_version", _wrap_Tools_mupdf_version, METH_O, "Return compiled MuPDF version."},
	 { "Tools_mupdf_warnings", _wrap_Tools_mupdf_warnings, METH_VARARGS, "Return the MuPDF warnings store."},
	 { "Tools_reset_mupdf_warnings", _wrap_Tools_reset_mupdf_warnings, METH_O, "Reset MuPDF warnings."},
	 { "Tools_mupdf_display_errors", _wrap_Tools_mupdf_display_errors, METH_VARARGS, "Set MuPDF error display to True or False."},
	 { "Tools__transform_rect", _wrap_Tools__transform_rect, METH_VARARGS, "Transform rectangle with matrix."},
	 { "Tools__intersect_rect", _wrap_Tools__intersect_rect, METH_VARARGS, "Intersect two rectangles."},
	 { "Tools__include_point_in_rect", _wrap_Tools__include_point_in_rect, METH_VARARGS, "Include point in a rect."},
	 { "Tools__transform_point", _wrap_Tools__transform_point, METH_VARARGS, "Transform point with matrix."},
	 { "Tools__union_rect", _wrap_Tools__union_rect, METH_VARARGS, "Replace r1 with smallest rect containing both."},
	 { "Tools__concat_matrix", _wrap_Tools__concat_matrix, METH_VARARGS, "Concatenate matrices m1, m2."},
	 { "Tools__invert_matrix", _wrap_Tools__invert_matrix, METH_VARARGS, "Invert a matrix."},
	 { "Tools_measure_string", _wrap_Tools_measure_string, METH_VARARGS, "Measure length of a string for a Base14 font."},
	 { "new_Tools", _wrap_new_Tools, METH_NOARGS, "new_Tools() -> Tools"},
	 { "delete_Tools", _wrap_delete_Tools, METH_O, "delete_Tools(self)"},
	 { "Tools_swigregister", Tools_swigregister, METH_O, NULL},
	 { "Tools_swiginit", Tools_swiginit, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_DeviceWrapper = {"_p_DeviceWrapper", "struct DeviceWrapper *|DeviceWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tools = {"_p_Tools", "struct Tools *|Tools *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_colorspace_s = {"_p_fz_colorspace_s", "struct fz_colorspace_s *|fz_colorspace_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_display_list_s = {"_p_fz_display_list_s", "struct fz_display_list_s *|fz_display_list_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_document_s = {"_p_fz_document_s", "struct fz_document_s *|fz_document_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_link_s = {"_p_fz_link_s", "struct fz_link_s *|fz_link_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_outline_s = {"_p_fz_outline_s", "struct fz_outline_s *|fz_outline_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_page_s = {"_p_fz_page_s", "struct fz_page_s *|fz_page_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_pixmap_s = {"_p_fz_pixmap_s", "struct fz_pixmap_s *|fz_pixmap_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fz_stext_page_s = {"_p_fz_stext_page_s", "struct fz_stext_page_s *|fz_stext_page_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdf_annot_s = {"_p_pdf_annot_s", "struct pdf_annot_s *|pdf_annot_s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pdf_graft_map_s = {"_p_pdf_graft_map_s", "struct pdf_graft_map_s *|pdf_graft_map_s *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_DeviceWrapper,
  &_swigt__p_Tools,
  &_swigt__p_char,
  &_swigt__p_fz_colorspace_s,
  &_swigt__p_fz_display_list_s,
  &_swigt__p_fz_document_s,
  &_swigt__p_fz_link_s,
  &_swigt__p_fz_outline_s,
  &_swigt__p_fz_page_s,
  &_swigt__p_fz_pixmap_s,
  &_swigt__p_fz_stext_page_s,
  &_swigt__p_pdf_annot_s,
  &_swigt__p_pdf_graft_map_s,
};

static swig_cast_info _swigc__p_DeviceWrapper[] = {  {&_swigt__p_DeviceWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tools[] = {  {&_swigt__p_Tools, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_colorspace_s[] = {  {&_swigt__p_fz_colorspace_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_display_list_s[] = {  {&_swigt__p_fz_display_list_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_document_s[] = {  {&_swigt__p_fz_document_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_link_s[] = {  {&_swigt__p_fz_link_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_outline_s[] = {  {&_swigt__p_fz_outline_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_page_s[] = {  {&_swigt__p_fz_page_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_pixmap_s[] = {  {&_swigt__p_fz_pixmap_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fz_stext_page_s[] = {  {&_swigt__p_fz_stext_page_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdf_annot_s[] = {  {&_swigt__p_pdf_annot_s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pdf_graft_map_s[] = {  {&_swigt__p_pdf_graft_map_s, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_DeviceWrapper,
  _swigc__p_Tools,
  _swigc__p_char,
  _swigc__p_fz_colorspace_s,
  _swigc__p_fz_display_list_s,
  _swigc__p_fz_document_s,
  _swigc__p_fz_link_s,
  _swigc__p_fz_outline_s,
  _swigc__p_fz_page_s,
  _swigc__p_fz_pixmap_s,
  _swigc__p_fz_stext_page_s,
  _swigc__p_pdf_annot_s,
  _swigc__p_pdf_graft_map_s,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
        0,                                  /* tp_prev */
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : NULL;
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
#if PY_VERSION_HEX >= 0x03000000
    return PyInstanceMethod_New(func);
#else
    return PyMethod_New(func, NULL, NULL);
#endif
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
#if JM_MEMORY == 1
  gctx = fz_new_context(&JM_Alloc_Context, NULL, FZ_STORE_DEFAULT);
#else
  gctx = fz_new_context(NULL, NULL, FZ_STORE_DEFAULT);
#endif
  if(!gctx)
  {
    PyErr_SetString(PyExc_RuntimeError, "Fatal error: could not create global context.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  fz_register_document_handlers(gctx);
  
  //-----------------------------------------------------------------------------
  // START redirect stdout/stderr
  //-----------------------------------------------------------------------------
  JM_mupdf_warnings_store = PyList_New(0);
  JM_mupdf_show_errors = Py_True;
  char user[] = "PyMuPDF";
  fz_set_warning_callback(gctx, JM_mupdf_warning, &user);
  fz_set_error_callback(gctx, JM_mupdf_error, &user);
  //-----------------------------------------------------------------------------
  // STOP redirect stdout/stderr
  //-----------------------------------------------------------------------------
  // init global constants
  //-----------------------------------------------------------------------------
  dictkey_align = PyString_InternFromString("align");
  dictkey_bbox = PyString_InternFromString("bbox");
  dictkey_blocks = PyString_InternFromString("blocks");
  dictkey_bpc = PyString_InternFromString("bpc");
  dictkey_c = PyString_InternFromString("c");
  dictkey_chars = PyString_InternFromString("chars");
  dictkey_color = PyString_InternFromString("color");
  dictkey_colorspace = PyString_InternFromString("colorspace");
  dictkey_content = PyString_InternFromString("content");
  dictkey_creationDate = PyString_InternFromString("creationDate");
  dictkey_cs_name = PyString_InternFromString("cs-name");
  dictkey_da = PyString_InternFromString("da");
  dictkey_dashes = PyString_InternFromString("dashes");
  dictkey_desc = PyString_InternFromString("desc");
  dictkey_dir = PyString_InternFromString("dir");
  dictkey_effect = PyString_InternFromString("effect");
  dictkey_ext = PyString_InternFromString("ext");
  dictkey_filename = PyString_InternFromString("filename");
  dictkey_fill = PyString_InternFromString("fill");
  dictkey_flags = PyString_InternFromString("flags");
  dictkey_font = PyString_InternFromString("font");
  dictkey_height = PyString_InternFromString("height");
  dictkey_id = PyString_InternFromString("id");
  dictkey_image = PyString_InternFromString("image");
  dictkey_length = PyString_InternFromString("length");
  dictkey_lines = PyString_InternFromString("lines");
  dictkey_modDate = PyString_InternFromString("modDate");
  dictkey_name = PyString_InternFromString("name");
  dictkey_origin = PyString_InternFromString("origin");
  dictkey_size = PyString_InternFromString("size");
  dictkey_smask = PyString_InternFromString("smask");
  dictkey_spans = PyString_InternFromString("spans");
  dictkey_stroke = PyString_InternFromString("stroke");
  dictkey_style = PyString_InternFromString("style");
  dictkey_subject = PyString_InternFromString("subject");
  dictkey_text = PyString_InternFromString("text");
  dictkey_title = PyString_InternFromString("title");
  dictkey_type = PyString_InternFromString("type");
  dictkey_ufilename = PyString_InternFromString("ufilename");
  dictkey_width = PyString_InternFromString("width");
  dictkey_wmode = PyString_InternFromString("wmode");
  dictkey_xref = PyString_InternFromString("xref");
  dictkey_xres = PyString_InternFromString("xres");
  dictkey_yres = PyString_InternFromString("yres");
  
  SWIG_Python_SetConstant(d, "EPSILON",SWIG_From_double((double)(1e-5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_TEXT",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LINK",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_FREE_TEXT",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LINE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SQUARE",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_CIRCLE",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POLYGON",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POLYLINE",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_HIGHLIGHT",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_UNDERLINE",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SQUIGGLY",SWIG_From_int((int)(10)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_STRIKEOUT",SWIG_From_int((int)(11)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_REDACT",SWIG_From_int((int)(12)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_STAMP",SWIG_From_int((int)(13)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_CARET",SWIG_From_int((int)(14)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_INK",SWIG_From_int((int)(15)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POPUP",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_FILEATTACHMENT",SWIG_From_int((int)(17)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SOUND",SWIG_From_int((int)(18)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_MOVIE",SWIG_From_int((int)(19)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_WIDGET",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SCREEN",SWIG_From_int((int)(21)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_PRINTERMARK",SWIG_From_int((int)(22)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_TRAPNET",SWIG_From_int((int)(23)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_WATERMARK",SWIG_From_int((int)(24)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_3D",SWIG_From_int((int)(25)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_UNKNOWN",SWIG_From_int((int)(-1)));
  SWIG_Python_SetConstant(d, "ANNOT_TEXT",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_LINK",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_FREETEXT",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_LINE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_SQUARE",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_CIRCLE",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_POLYGON",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "ANNOT_POLYLINE",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_HIGHLIGHT",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "ANNOT_UNDERLINE",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "ANNOT_SQUIGGLY",SWIG_From_int((int)(10)));
  SWIG_Python_SetConstant(d, "ANNOT_STRIKEOUT",SWIG_From_int((int)(11)));
  SWIG_Python_SetConstant(d, "ANNOT_STAMP",SWIG_From_int((int)(13)));
  SWIG_Python_SetConstant(d, "ANNOT_CARET",SWIG_From_int((int)(14)));
  SWIG_Python_SetConstant(d, "ANNOT_INK",SWIG_From_int((int)(15)));
  SWIG_Python_SetConstant(d, "ANNOT_POPUP",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "ANNOT_FILEATTACHMENT",SWIG_From_int((int)(17)));
  SWIG_Python_SetConstant(d, "ANNOT_SOUND",SWIG_From_int((int)(18)));
  SWIG_Python_SetConstant(d, "ANNOT_MOVIE",SWIG_From_int((int)(19)));
  SWIG_Python_SetConstant(d, "ANNOT_WIDGET",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "ANNOT_SCREEN",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "ANNOT_PRINTERMARK",SWIG_From_int((int)(22)));
  SWIG_Python_SetConstant(d, "ANNOT_TRAPNET",SWIG_From_int((int)(23)));
  SWIG_Python_SetConstant(d, "ANNOT_WATERMARK",SWIG_From_int((int)(24)));
  SWIG_Python_SetConstant(d, "ANNOT_3D",SWIG_From_int((int)(25)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_Invisible",SWIG_From_int((int)(1 << (1-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_Hidden",SWIG_From_int((int)(1 << (2-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_Print",SWIG_From_int((int)(1 << (3-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NoZoom",SWIG_From_int((int)(1 << (4-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NoRotate",SWIG_From_int((int)(1 << (5-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NoView",SWIG_From_int((int)(1 << (6-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_ReadOnly",SWIG_From_int((int)(1 << (7-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_Locked",SWIG_From_int((int)(1 << (8-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_ToggleNoView",SWIG_From_int((int)(1 << (9-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_LockedContents",SWIG_From_int((int)(1 << (10-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Invisible",SWIG_From_int((int)(1 << (1-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Hidden",SWIG_From_int((int)(1 << (2-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Print",SWIG_From_int((int)(1 << (3-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoZoom",SWIG_From_int((int)(1 << (4-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoRotate",SWIG_From_int((int)(1 << (5-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_NoView",SWIG_From_int((int)(1 << (6-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_ReadOnly",SWIG_From_int((int)(1 << (7-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_Locked",SWIG_From_int((int)(1 << (8-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_ToggleNoView",SWIG_From_int((int)(1 << (9-1))));
  SWIG_Python_SetConstant(d, "ANNOT_XF_LockedContents",SWIG_From_int((int)(1 << (10-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_NONE",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_SQUARE",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_CIRCLE",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_DIAMOND",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_OPEN_ARROW",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_CLOSED_ARROW",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_BUTT",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_R_OPEN_ARROW",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_R_CLOSED_ARROW",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_SLASH",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_None",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Square",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Circle",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Diamond",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_OpenArrow",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_ClosedArrow",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Butt",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_ROpenArrow",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_RClosedArrow",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "ANNOT_LE_Slash",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_UNKNOWN",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_BUTTON",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_CHECKBOX",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_COMBOBOX",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_LISTBOX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_RADIOBUTTON",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_SIGNATURE",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_TEXT",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_NOT_WIDGET",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_PUSHBUTTON",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_CHECKBOX",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_RADIOBUTTON",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_LISTBOX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_COMBOBOX",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_SIGNATURE",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_NONE",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_NUMBER",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_SPECIAL",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_DATE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_TIME",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_UNRESTRAINED",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_NUMBER",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_SPECIAL",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_DATE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "ANNOT_WG_TEXT_TIME",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_READ_ONLY",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_REQUIRED",SWIG_From_int((int)(1 << 1)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_NO_EXPORT",SWIG_From_int((int)(1 << 2)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_ReadOnly",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Required",SWIG_From_int((int)(1 << 1)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_NoExport",SWIG_From_int((int)(1 << 2)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_MULTILINE",SWIG_From_int((int)(1 << 12)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_PASSWORD",SWIG_From_int((int)(1 << 13)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_FILE_SELECT",SWIG_From_int((int)(1 << 20)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK",SWIG_From_int((int)(1 << 22)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_DO_NOT_SCROLL",SWIG_From_int((int)(1 << 23)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_COMB",SWIG_From_int((int)(1 << 24)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_RICH_TEXT",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Multiline",SWIG_From_int((int)(1 << 12)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Password",SWIG_From_int((int)(1 << 13)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_FileSelect",SWIG_From_int((int)(1 << 20)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_DoNotSpellCheck",SWIG_From_int((int)(1 << 22)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_DoNotScroll",SWIG_From_int((int)(1 << 23)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Comb",SWIG_From_int((int)(1 << 24)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_RichText",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF",SWIG_From_int((int)(1 << 14)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_RADIO",SWIG_From_int((int)(1 << 15)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_PUSHBUTTON",SWIG_From_int((int)(1 << 16)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_RADIOS_IN_UNISON",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_NoToggleToOff",SWIG_From_int((int)(1 << 14)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Radio",SWIG_From_int((int)(1 << 15)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Pushbutton",SWIG_From_int((int)(1 << 16)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_RadioInUnison",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_COMBO",SWIG_From_int((int)(1 << 17)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_EDIT",SWIG_From_int((int)(1 << 18)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_SORT",SWIG_From_int((int)(1 << 19)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_MULTI_SELECT",SWIG_From_int((int)(1 << 21)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK",SWIG_From_int((int)(1 << 22)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE",SWIG_From_int((int)(1 << 26)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Combo",SWIG_From_int((int)(1 << 17)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Edit",SWIG_From_int((int)(1 << 18)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_Sort",SWIG_From_int((int)(1 << 19)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_MultiSelect",SWIG_From_int((int)(1 << 21)));
  SWIG_Python_SetConstant(d, "WIDGET_Ff_CommitOnSelCHange",SWIG_From_int((int)(1 << 26)));
  SWIG_Python_SetConstant(d, "CS_RGB",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "CS_GRAY",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "CS_CMYK",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_KEEP",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_NONE",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_RC4_40",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_RC4_128",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_AES_128",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_AES_256",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_UNKNOWN",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_PERM_PRINT",SWIG_From_int((int)(1 << 2)));
  SWIG_Python_SetConstant(d, "PDF_PERM_MODIFY",SWIG_From_int((int)(1 << 3)));
  SWIG_Python_SetConstant(d, "PDF_PERM_COPY",SWIG_From_int((int)(1 << 4)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ANNOTATE",SWIG_From_int((int)(1 << 5)));
  SWIG_Python_SetConstant(d, "PDF_PERM_FORM",SWIG_From_int((int)(1 << 8)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ACCESSIBILITY",SWIG_From_int((int)(1 << 9)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ASSEMBLE",SWIG_From_int((int)(1 << 10)));
  SWIG_Python_SetConstant(d, "PDF_PERM_PRINT_HQ",SWIG_From_int((int)(1 << 11)));
  SWIG_Python_SetConstant(d, "PDF_BM_Color",SWIG_FromCharPtr("Color"));
  SWIG_Python_SetConstant(d, "PDF_BM_ColorBurn",SWIG_FromCharPtr("ColorBurn"));
  SWIG_Python_SetConstant(d, "PDF_BM_ColorDodge",SWIG_FromCharPtr("ColorDodge"));
  SWIG_Python_SetConstant(d, "PDF_BM_Darken",SWIG_FromCharPtr("Darken"));
  SWIG_Python_SetConstant(d, "PDF_BM_Difference",SWIG_FromCharPtr("Difference"));
  SWIG_Python_SetConstant(d, "PDF_BM_Exclusion",SWIG_FromCharPtr("Exclusion"));
  SWIG_Python_SetConstant(d, "PDF_BM_HardLight",SWIG_FromCharPtr("HardLight"));
  SWIG_Python_SetConstant(d, "PDF_BM_Hue",SWIG_FromCharPtr("Hue"));
  SWIG_Python_SetConstant(d, "PDF_BM_Lighten",SWIG_FromCharPtr("Lighten"));
  SWIG_Python_SetConstant(d, "PDF_BM_Luminosity",SWIG_FromCharPtr("Luminosity"));
  SWIG_Python_SetConstant(d, "PDF_BM_Multiply",SWIG_FromCharPtr("Multiply"));
  SWIG_Python_SetConstant(d, "PDF_BM_Normal",SWIG_FromCharPtr("Normal"));
  SWIG_Python_SetConstant(d, "PDF_BM_Overlay",SWIG_FromCharPtr("Overlay"));
  SWIG_Python_SetConstant(d, "PDF_BM_Saturation",SWIG_FromCharPtr("Saturation"));
  SWIG_Python_SetConstant(d, "PDF_BM_Screen",SWIG_FromCharPtr("Screen"));
  SWIG_Python_SetConstant(d, "PDF_BM_SoftLight",SWIG_FromCharPtr("Softlight"));
  SWIG_Python_SetConstant(d, "TEXT_FONT_SUPERSCRIPT",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_ITALIC",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_SERIFED",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_MONOSPACED",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_BOLD",SWIG_From_int((int)(16)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

